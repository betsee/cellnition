{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Cellnition is an open source simulator to create and analyze Network Finite State Machines (NFSMs) from regulatory network models.</p> <p>Regulatory networks, such as Gene Regulatory Networks (GRNs), preside over so many complex phenomena in biological systems, yet given a specific regulatory network, how do we know what it's capable of doing?</p> <p>Cellnition aims to provide a detailed answer to that question, by treating regulatory networks as analogue computers, where NFSMs map the sequential logic,  or analogue \"software program\", inherent in the regulatory network's dynamics.</p> <p>NFSMs have a range of potential applications, including facilitating the  identification of potential strategies to renormalize cancer.</p>"},{"location":"#installation","title":"Installation","text":"<p>Cellnition is installable with pip,  the standard package installer officially bundled with Python:</p> <pre><code>pip install cellnition\n</code></pre>"},{"location":"#issues","title":"Issues","text":"<p>Please use the Cellnition issue tracker to  report any problems or feedback pertaining to the codebase.  </p>"},{"location":"#about","title":"About","text":"<p>Read more about Cellnition's NFSMs in our pre-print publication: Harnessing the Analogue Computing Power of Regulatory Networks with the Regulatory Network Machine.</p> <p>Please cite our publication in any work that utilizes Cellnition:</p> <pre><code>Pietak, Alexis, and Michael Levin.\n \u201cHarnessing the Analog Computing Power of Regulatory Networks \n with the Regulatory Network Machine.\u201d OSF Preprints, 2 Dec. 2024. Web.\n</code></pre> <p>Cellnition is portably implemented in Python, continuously stress-tested via GitHub Actions \u00d7 tox \u00d7 pytest \u00d7 Codecov, and licensed under a non-commercial use, open source APACHE license with Tufts Open Source License Rider v.1. For maintainability, cellnition officially supports only the most recently released version of CPython.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Cellnition creator Alexis Pietak is grateful for collaboration opportunities and funding support from the Levin Lab at Tufts University, via a  Templeton World Charity Foundation grant 0606. Thanks goes out to Brian Curry for his volunteer assistance with the Cellnition code repository. </p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Alexis Pietak created Cellnition, and co-authored the associated scientific manuscript, as an  external contractor (\"Affiliate Research Scientist\") for Tufts University.  Under the established terms of  Tufts University, as an external contractor, Alexis receives no royalties nor other financial benefits or  entitlements in connection with any intellectual property associated with the Cellnition project or its associated  scientific manuscript. </p> <p>Note that the functionality provided and work presented in Cellnition and its associated scientific manuscript are at a  theoretical and computational stage, with any and all potential applications for the work requiring verification by real world experiments and by comprehensive testing.   </p>"},{"location":"#license","title":"License","text":"<p>Cellnition is non-commerical use open source software licensed under an Apache 2.0 license with Tufts Open Source License Rider v.1, restricting use to academic purposes only.</p>"},{"location":"about/","title":"Background","text":"<p>Cellnition is an open source simulator to create and analyze Network Finite State Machines (NFSMs) from regulatory network models.</p> <p>Regulatory networks, such as Gene Regulatory Networks (GRNs), preside over so many complex phenomena in biological systems, yet given a specific regulatory network, how do we know what it's capable of doing?</p> <p>Cellnition aims to provide a detailed answer to that question, by treating regulatory networks as analogue computers, where NFSMs map the sequential logic,  or analogue \"software program\", inherent in the regulatory network's dynamics. </p> <p>As an extension and improvement upon attractor landscape analysis, NFSMs reveal the analogue computing operations inherent in regulatory networks, allowing for identification of associated \"intelligent behaviors\".</p> <p>By capturing the analog programming of regulatory networks,  NFSMs provide clear identification of:</p> <ul> <li>Interventions that can potentially induce transitions between stable states (e.g. from \"diseased\" to \"healthy\").</li> <li>Identification of path-dependencies, representing stable changes occurring after a transient intervention is applied (e.g. evaluating if a transient treatment with pharmacological agent might permanently heal a condition).</li> <li>Identification of potential inducible cycles of behavior that take the system through a complex multi-phase process (e.g. wound healing).</li> <li>Potential targets of dynamic activity in a regulatory network (e.g. how to engage a genetic oscillator instead of a monotonic gene expression in time).</li> </ul> <p>NFSMs have a range of applications, including facilitating the  identification of potential strategies to renormalize cancer.</p> <p>Read more about Cellnition's NFSMs in our pre-print publication: Harnessing the Analogue Computing Power of Regulatory Networks with the Regulatory Network Machine.</p> <p>Please cite our publication in any work that utilizes Cellnition:</p> <pre><code>Pietak, Alexis, and Michael Levin.\n \u201cHarnessing the Analog Computing Power of Regulatory Networks \n with the Regulatory Network Machine.\u201d OSF Preprints, 2 Dec. 2024. Web.\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>Cellnition embodies a range of functionality, including:</p> <ul> <li>Work with regulatory networks imported from Cellnition's <code>network_library</code>, use Cellnition to procedurally generate regulatory networks  with random or scale-free degree distributions, or import your own user-defined regulatory networks as directed graphs with activating or inhibiting edge characteristics (see Tutorial 1 and Tutorial 2 for some examples).</li> <li>Analyze and characterize regulatory network graphs with a variety of metrics (see the <code>characterize_graph</code>  method and Tutorial 1 and Tutorial 2).</li> <li>Use directed graph representations of regulatory networks to build fully-continuous, differential-equation based simulators of network dynamics (see  <code>ProbabilityNet</code>  and Tutorial 1).</li> <li>Use directed graph representations of regulatory networks to build logic-equation based Boolean simulators of network dynamics (see <code>BooleanNet</code> and Tutorial 2).</li> <li>Explore regulatory network dynamics with comprehensive  equilibrium state search  and characterization capabilities, along with  temporal simulators  (see Tutorial 1 and Tutorial 2 for some examples).</li> <li>Create simulated datasets, including simulation of automated gene-knockout experiments  for a continuous regulatory network model (see  <code>GeneKnockout</code>).</li> <li>Generate NFSMs for continuous models (see  <code>StateMachine</code> and Tutorial 1)  or for Boolean models (see  <code>BoolStateMachine</code> and Tutorial 2).</li> <li>Create and export a variety of plots and visualizations, including of the regulatory network model analytic equations,  regulatory network directed graphs,  heatmaps of gene expressions  in equilibrium states,  gene expressions in temporal simulations,  and depictions of the general NFSM  and the event-driven NFSM (see Tutorial 1 and Tutorial 2 for some examples).</li> </ul>"},{"location":"usage/","title":"Basic Usage","text":"<p>The Jupyter Notebook Tutorials are a great  place to get started with Cellnition. </p> <p>The general workflow to create NFSMs in Cellnition comprises 6 main steps:</p> <ol> <li>Define via edges    (user-defined or imported), or  procedurally generate  a regulatory network as a directed graph in a  computationally-agnostic,  Continuous, or  Boolean oriented computational workflow.</li> <li>Characterize the graph  to automatically categorize input, output &amp; internal nodes, along with other features such as cycles and node hierarchical level.</li> <li>Build a computational model of the regulatory network for  Continuous  or  Boolean  models.</li> <li>Use the computational model in a state machine to identify all unique equilibrium  output states for each input state via state space search available for Continuous  or Boolean  models.</li> <li>Create the NFSMs in  Continuous  or  Boolean  systems. Cellnition does this by starting the system in each equilibrium state,  applying each input state, and determining the equilibrium state that the system transitions  to.</li> <li>Output, plot, and analyze the resulting Network Finite State Machines!</li> </ol>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/","title":"Boolean Network Model","text":"<p>               Bases: <code>NetworkABC</code></p> <p>This class builds a Boolean model of a regulatory network from a directed graph. The class can produce and characterize the directed graph upon which the Boolean model is based by importing from the Cellnition <code>network_library</code>, from user-defined edges, or by using procedurally generated graphs. One the directed graphs representing the regulatory network is formed, a Boolean, logic-equation based analytic model of the regulatory network is automatically generated, along with numerical counterparts for general simulation of the regulatory network. The simulation object produced by this class can be used to build Network Finite State Machines (NFSMs) using the <code>BoolStateMachine</code> class.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>class BooleanNet(NetworkABC):\n    '''\n    This class builds a Boolean model of a regulatory network from a directed graph. The\n    class can produce and characterize the directed graph upon which the Boolean model is based by importing\n    from the Cellnition [`network_library`][cellnition.science.network_models.network_library],\n    from user-defined edges, or by using procedurally generated\n    graphs. One the directed graphs representing the regulatory network is formed, a Boolean, logic-equation based\n    analytic model of the regulatory network is automatically generated, along with numerical counterparts for\n    general simulation of the regulatory network. The simulation object produced by this class can be used to\n    build Network Finite State Machines (NFSMs) using the\n    [`BoolStateMachine`][cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine] class.\n\n    Attributes\n    ----------\n\n    '''\n    def __init__(self):\n        '''\n\n        '''\n\n        super().__init__()  # Initialize the base class\n\n        # Init all core attributes:\n        self.edges_list = None\n        self.nodes_list = None\n        self.GG = None\n        self.N_edges = None\n        self.N_nodes = None\n        self.edges_index = None\n        self.nodes_index = None\n\n        self._c_vect_s = None\n        self._A_bool_s = None\n        self._A_bool_f = None\n\n    def build_adjacency_matrices(self,\n                        edge_types: list[EdgeType],\n                        edges_index: list[tuple[int,int]],\n                        ):\n        '''\n\n        '''\n        # Initialize an activator matrix:\n        A_acti_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        # Initialize an inhibitor matrix:\n        A_inhi_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:cc\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_acti_s[nde_j, nde_i] = 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_inhi_s[nde_j, nde_i] = 1\n\n        A_acti_s = sp.Matrix(A_acti_s)\n        A_inhi_s = sp.Matrix(A_inhi_s)\n\n        return A_acti_s, A_inhi_s\n\n\n    #----Boolean Model Building--------\n    def build_boolean_model(self, use_node_name: bool=True,\n                            multi_coupling_type: CouplingType=CouplingType.mix1,\n                            constitutive_express: bool = False):\n        '''\n        Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s)\n        as well as a vectorized numpy function (A_bool_f) that accepts the list or array of\n        node concentrations.\n\n        Parameters\n        ----------\n        use_node_name: bool = True\n            If True, the node label is used as the symbolic parameter name. Otherwise a shorter\n            parameter label of 'g_#\" is used, where # is the node's index in the network.\n\n        multi_coupling_type: CouplingType=CouplingType.mixed\n            Specify how factors are combined at individual target nodes.\n\n\n        '''\n        if use_node_name:\n            c_vect_s = sp.Matrix([sp.Symbol(nde_nme, positive=True) for nde_nme in self.nodes_list])\n        else: # use the node's numerical index as a label\n            c_vect_s = sp.Matrix([sp.Symbol(f'g_{nde_i}',\n                                            positive=True) for nde_i in self.nodes_index])\n\n        if multi_coupling_type is CouplingType.mix1:\n            # Case #1: Mixed coupling, where inhibitors always act in \"OR\"\n            # configuration and activators act in \"AND\" configuration.\n            # Initialize an activator matrix:\n            A_acti_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n            # onesv = np.ones(self.N_nodes, dtype=int)\n\n            # Initialize an inhibitor matrix:\n            A_inhi_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n            acti_count = [0 for i in range(self.N_nodes)]  # counts the number of activators acting on each node\n            inhi_count = [0 for i in range(self.N_nodes)]  # counts the number of inhibitors acting on each node\n\n            # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n            # and multiplicative interactions:cc\n            for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n                # print(type(nde_i))\n                # print(c_vect_s[nde_i])\n                if etype is EdgeType.A or etype is EdgeType.As:\n                    A_acti_so[nde_j, nde_i] = 1\n                    acti_count[nde_j] += 1\n                elif etype is EdgeType.I or etype is EdgeType.Is:\n                    A_inhi_so[nde_j, nde_i] = 1 - c_vect_s[nde_i]\n                    inhi_count[nde_j] += 1\n\n            # Combine so that presence of activators AND absence of inhibitors required for node expressions:\n            if constitutive_express is False:\n                # Need to create a normalized vector for managing cooperativity of the \"OR\"\n                denom = np.asarray(acti_count)  # total number of activators at each node\n                idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n                denom[idenom] = 1  # set those equal to 1\n                denom = np.int64(denom)\n                coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n                A_acti_so = (coopv * A_acti_so.T).T # multiply by the normalizing vector coopv\n                A_acti_ss = A_acti_so.dot(c_vect_s)\n\n                const_inds = [] # if there's inhibitor but no activator, node must be const expressed\n                for ndei, (act, ict) in enumerate(zip(acti_count, inhi_count)):\n                    if act == 0 and ict != 0:\n                        const_inds.append(ndei)\n\n                A_acti_ss[const_inds] = 1 # set this to 1 where the const expressed nodes should me\n\n                A_acti_s = sp.Matrix(A_acti_ss) # collect terms into \"OR\" activators at each node\n                A_inhi_s = sp.Matrix(np.prod(A_inhi_so, axis=1)) # collect terms into \"AND\" inhibitors at each node\n                A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s) # Use \"AND\" to combine acti and inhi\n\n            # We use and additive \"OR\" to specify the presence of an activator OR absence of an inhibitor\n            # is required for gene expression for all genes\n            else:\n                # Need to create a normalized vector for managing cooperativity of the \"OR\"\n                # sums the number of activators and if inhibitors at each node:\n                denom = np.asarray(acti_count) + np.sign(inhi_count)\n                idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n                denom[idenom] = 1  # set those equal to 1\n                denom = np.int64(denom)\n                coopv = sp.Matrix([sp.Rational(1, di) for di in denom]) # write as fractions for pretty display\n\n                # Multiply the system through with the normalizing coefficients:\n                A_acti_s = sp.hadamard_product(coopv, sp.Matrix(A_acti_so.dot(c_vect_s)))\n                A_inhi_s = sp.hadamard_product(coopv, sp.Matrix(np.sign(inhi_count) * np.prod(A_inhi_so, axis=1)))\n                # Combine activators and inhibitors as \"OR\" function:\n                A_bool_s = A_acti_s + A_inhi_s\n\n\n        elif multi_coupling_type is CouplingType.mix2:\n            # Mixed coupling #2, where inhibitors always act in \"AND\"\n            # configuration and activators act in \"OR\" configuration.\n            # Initialize an inhibitor matrix:\n            A_inhi_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n            onesv = np.ones(self.N_nodes, dtype=int)\n\n            acti_count = [0 for i in range(self.N_nodes)]  # counts the number of activators acting on each node\n            inhi_count = [0 for i in range(self.N_nodes)]  # counts the number of inhibitors acting on each node\n\n            # Initialize an activator matrix:\n            A_acti_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n            # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n            # and multiplicative interactions:cc\n            for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n                # print(type(nde_i))\n                # print(c_vect_s[nde_i])\n                if etype is EdgeType.A or etype is EdgeType.As:\n                    A_acti_so[nde_j, nde_i] = c_vect_s[nde_i]\n                    acti_count[nde_j] += 1\n                elif etype is EdgeType.I or etype is EdgeType.Is:\n                    A_inhi_so[nde_j, nde_i] = 1\n                    inhi_count[nde_j] += 1\n\n            # Combine so that presence of activators AND absence of inhibitors required for node expressions:\n            if constitutive_express is False:\n                # Need to create a normalized vector for managing cooperativity of the \"OR\"\n                denom = np.asarray(inhi_count)  # total number of activators at each node\n                idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n                denom[idenom] = 1  # set those equal to 1\n                denom = np.int64(denom)\n                coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n                A_inhi_so = (coopv * A_inhi_so.T).T  # multiply by the normalizing vector coopv\n                A_inhi_ss = A_inhi_so.dot(sp.Matrix(onesv) - c_vect_s)\n\n                const_inds = []  # if there's inhibitor but no activator, node must be const expressed\n                for ndei, (act, ict) in enumerate(zip(acti_count, inhi_count)):\n                    if act != 0 and ict == 0:\n                        const_inds.append(ndei)\n\n                A_inhi_ss[const_inds] = 1  # set this to 1 where the const expressed nodes should me\n\n                A_inhi_s = sp.Matrix(A_inhi_ss)  # collect terms into \"OR\" activators at each node\n                A_acti_s = sp.Matrix(\n                    np.prod(A_acti_so, axis=1))  # collect terms into \"AND\" inhibitors at each node\n                A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s)  # Use \"AND\" to combine acti and inhi\n\n            # We use and additive \"OR\" to specify the presence of an activator OR absence of an inhibitor\n            # is required for gene expression for all genes\n            else:\n                # Need to create a normalized vector for managing cooperativity of the \"OR\"\n                # sums the number of activators and if inhibitors at each node:\n                denom = np.asarray(inhi_count) + np.sign(acti_count)\n                idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n                denom[idenom] = 1  # set those equal to 1\n                denom = np.int64(denom)\n                coopv = sp.Matrix([sp.Rational(1, di) for di in denom])  # write as fractions for pretty display\n\n                # Multiply the system through with the normalizing coefficients:\n                A_inhi_s = sp.hadamard_product(coopv, sp.Matrix(A_inhi_so.dot(sp.Matrix(onesv) - c_vect_s)))\n                A_acti_s = sp.hadamard_product(coopv,\n                                               sp.Matrix(np.sign(acti_count) * np.prod(A_acti_so, axis=1)))\n                # Combine activators and inhibitors as \"OR\" function:\n                A_bool_s = A_acti_s + A_inhi_s\n\n\n        elif multi_coupling_type is CouplingType.additive:\n\n            # Case #2: Additive coupling, where all interactions inhibitors always act in\n            # \"AND\" configuration.\n            # Initialize an activator matrix:\n            A_acti_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n            # Initialize an inhibitor matrix:\n            A_inhi_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n            # Initialize a \"ones vector\" for each node:\n            onesv = np.ones(self.N_nodes, dtype=int)\n\n            # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n            # and multiplicative interactions:cc\n            for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n                # print(type(nde_i))\n                # print(c_vect_s[nde_i])\n                if etype is EdgeType.A or etype is EdgeType.As:\n                    A_acti_so[nde_j, nde_i] = 1\n                elif etype is EdgeType.I or etype is EdgeType.Is:\n                    A_inhi_so[nde_j, nde_i] = 1\n\n            ic_vect_s = sp.Matrix(onesv) - c_vect_s\n\n            denom = (A_acti_so + A_inhi_so).dot(onesv)\n            idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n            denom[idenom] = 1  # set those equal to 1\n            denom = np.int64(denom)\n            # coopv = 1 / denom\n            coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n            A_acti_so = (coopv * A_acti_so.T).T\n            A_inhi_so = (coopv * A_inhi_so.T).T\n\n            A_acti_s = sp.Matrix(A_acti_so.dot(c_vect_s))\n            A_inhi_s = sp.Matrix(A_inhi_so.dot(ic_vect_s))\n            A_bool_s = A_acti_s + A_inhi_s\n\n        elif multi_coupling_type is CouplingType.multiplicative:\n            # Case #1: Mixed coupling, where inhibitors always act in \"OR\"\n            # configuration and activators act in \"AND\" configuration.\n            # Initialize an activator matrix:\n            A_acti_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n            # Initialize an inhibitor matrix:\n            A_inhi_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n            # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n            # and multiplicative interactions:cc\n            for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n                # print(type(nde_i))\n                # print(c_vect_s[nde_i])\n                if etype is EdgeType.A or etype is EdgeType.As:\n                    A_acti_so[nde_j, nde_i] = c_vect_s[nde_i]\n                elif etype is EdgeType.I or etype is EdgeType.Is:\n                    A_inhi_so[nde_j, nde_i] = 1 - c_vect_s[nde_i]\n\n            A_acti_s = sp.Matrix(np.prod(A_acti_so, axis=1))\n            A_inhi_s = sp.Matrix(np.prod(A_inhi_so, axis=1))\n            A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s)\n\n        else:\n            raise Exception(\"Only additive, multiplicative, and mixed coupling types are supported\")\n\n        # Finally, create a vectorized numpy function to calculate the result:\n        A_bool_f = sp.lambdify([c_vect_s], A_bool_s.T)\n        self._c_vect_s = c_vect_s\n        self._A_bool_s = A_bool_s\n        self._A_bool_f = A_bool_f\n\n        return c_vect_s, A_bool_s, A_bool_f\n\n    #---Boolean Model Solving----------\n    def net_state_compute(self,\n                              cc_o: ndarray|list,\n                              A_bool_f: Callable,\n                              n_max_steps: int=20,\n                              constraint_inds: list|None=None,\n                              constraint_vals: list|None=None,\n                              verbose: bool=False\n                              ):\n        '''\n\n        '''\n        cc_i = cc_o  # initialize the function values (node values)\n        solsv = [cc_o]  # holds a list of transient solutions\n        sol_char = EquilibriumType.undetermined # initialize to undetermined\n\n        for ii in range(n_max_steps):\n\n            if verbose:\n                print(solsv[-1])\n            # A true \"OR\" function will return the maximum of the list of booleans. This can\n            # be achieved by using the \"np.sign\" as a \"ceiling\" function:\n\n            cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values for this next step i\n\n            # If there are constraints on some node vals, force them to the constraint:\n            if constraint_inds is not None and constraint_vals is not None:\n                cc_i[constraint_inds] = constraint_vals\n\n            solsv.append(cc_i)\n\n            # Detect whether we're at a steady-state at any point in this analysis:\n            if (solsv[ii] == solsv[ii - 1]).all() is NumpyTrue:\n                sol_char = EquilibriumType.attractor\n                break\n\n            # Otherwise, when we reach the end of the sequence, search for repeated motifs:\n            elif ii == n_max_steps -1:\n                # test to see if we have a more complicated repetition motif:\n                solvr = np.asarray(solsv)[:, self.noninput_node_inds] # get the reduced array\n                si = solvr[-1, :] # try selecting the last state to check for repetition...\n                matched_inds = [i for i, x in enumerate(solvr.tolist()) if x == si.tolist()] # look for repetition\n                if len(matched_inds) &gt; 1: # if there's more than one incidence of the state\n                    motif = np.asarray(solsv)[matched_inds[-2]:matched_inds[-1], :] # extract a motif from the full array\n                    cc_i = np.mean(motif, axis=0) # solution becomes the (non-integer!) mean of the motif\n                    if len(motif) &gt; 2:\n                        sol_char = EquilibriumType.limit_cycle\n                    else: # otherwise the motif is a saddle (metabstable state):\n                        sol_char = EquilibriumType.saddle\n\n        return cc_i, sol_char\n\n    def net_sequence_compute(self,\n                              cc_o: ndarray|list,\n                              A_bool_f: Callable,\n                              n_max_steps: int=20,\n                              constraint_inds: list|None=None,\n                              constraint_vals: list|None=None,\n                              verbose: bool=False\n                              ):\n        '''\n        Returns the sequence of n_max_step states occurring after an initial state, cc_o,\n        determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic\n        of the eq'm as a point attractor or limit cycle.\n        '''\n        cc_i = cc_o  # initialize the function values (node values)\n        solsv = [np.asarray(cc_o)]  # holds a list of transient solutions, beginning with the initial state\n        sol_char = EquilibriumType.undetermined # initialize to undetermined\n\n        motif = None\n\n        for i in range(n_max_steps):\n\n            if verbose:\n                print(solsv[-1])\n            # A true \"OR\" function will return the maximum of the list of booleans. This can\n            # be achieved by using the \"ceiling\" function. If cooperative interaction is\n            # desired, then rounding is better\n\n            cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values of the sequence\n\n            # If there are constraints on some node vals, force them to the constraint:\n            if constraint_inds is not None and constraint_vals is not None:\n                cc_i[constraint_inds] = constraint_vals\n\n            solsv.append(cc_i) # append the new state to the sequence vector\n\n        # Now that the sequence has been collected, determine if it's a steady-state, and if so,\n        # characterize the eq'm:\n        if (solsv[-1] == solsv[-2]).all() is NumpyTrue:\n            sol_char = EquilibriumType.attractor\n\n        else:\n            # test to see if we have a more complicated repetition motif:\n            solvr = np.asarray(solsv)[:, self.noninput_node_inds]  # get the reduced array\n            si = solvr[-1, :]  # try selecting the last state to check for repetition in the sequence...\n            matched_inds = [i for i, x in enumerate(solvr.tolist()) if x == si.tolist()]  # look for repetition\n            if len(matched_inds) &gt; 1:  # if there's more than one incidence of the state\n                motif = np.asarray(solsv)[matched_inds[-2]:matched_inds[-1], :]  # extract a motif from the full seq\n                cc_i = np.mean(motif, axis=0)  # solution becomes the (non-integer!) mean of the motif\n                if len(motif) &gt; 2:\n                    sol_char = EquilibriumType.limit_cycle\n                else:  # otherwise the motif is a saddle (metabstable state):\n                    sol_char = EquilibriumType.saddle\n\n        # convert solsv to a numpy array with n_max_steps rows and self.N_Nodes columns:\n        solsv = np.asarray(solsv)\n\n        return solsv, cc_i, sol_char, motif\n\n    def net_multisequence_compute(self,\n                                  cc_o: ndarray|list,\n                                  sigs_vect: ndarray|list,\n                                  A_bool_f: Callable,\n                                  n_max_steps: int=20,\n                                  constraint_inds: list|None=None,\n                                  verbose: bool=False):\n        '''\n\n        '''\n        sol_results = []\n        sol_char_results = []\n        sequence_results = None\n        pseudo_tvect = None\n\n        phase_inds = [] # tuples marking the start and stop of each input intervention\n\n        tn_0 = 0\n        tn_1 = n_max_steps + 1\n\n        for ii, sig_vals in enumerate(sigs_vect):\n            phase_inds.append((tn_0, tn_1))\n\n            cc_o[constraint_inds] = sig_vals\n            solsv, cc_o, sol_char, motif = self.net_sequence_compute(cc_o,\n                                                                     A_bool_f,\n                                                                     n_max_steps=n_max_steps,\n                                                                     constraint_inds=constraint_inds,\n                                                                     constraint_vals=sig_vals,\n                                                                     verbose=verbose\n                                                                     )\n\n            pseudo_tvect_i = np.arange(tn_0, tn_1)\n            # update the tn vectors for next time:\n            tn_0 = tn_1\n            tn_1 += n_max_steps + 1\n\n            if ii == 0:\n                sequence_results = solsv\n                pseudo_tvect = pseudo_tvect_i\n\n            else:\n                sequence_results = np.vstack((sequence_results, solsv))\n                pseudo_tvect = np.hstack((pseudo_tvect, pseudo_tvect_i))\n\n            sol_results.append(cc_o) # append the final eq'm state value\n            sol_char_results.append(sol_char) # append the eq'm characterization\n\n        return pseudo_tvect, sequence_results, sol_results, sol_char_results, phase_inds\n\n\n    def run_iter_sim(self,\n                     tvect: ndarray|list, # main time vector\n                     cvecti: ndarray|list, # initial state of all the network nodes\n                     A_bool_f: Callable,\n                     sig_inds: ndarray|list,\n                     sig_vals: ndarray,\n                         ):\n        '''\n        Returns the sequence of n_max_step states occurring after an initial state, cc_o,\n        under a dynamically specified stimulation applied to constraint_inds with value\n        constraint_vals.\n        '''\n        cc_i = cvecti  # initialize the function values (node values)\n        solsv = []  # holds a list of transient solutions\n\n        if len(tvect) != sig_vals.shape[0]:\n            raise Exception('Rows of sig_vals array must equal the '\n                            'number of time iterations in tvect!')\n\n        for tt in tvect:\n\n            solsv.append(cc_i)  # append the new state to the sequence vector\n\n            cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values of the sequence\n\n            # Force node values to the value of the dynamic constraint:\n            cc_i[sig_inds] = sig_vals[tt, :]\n\n        solsv = np.asarray(solsv)\n\n        return solsv\n\n\n\n\n    def solve_system_equms(self,\n                           A_bool_f: Callable,\n                           constraint_inds: list|None = None,\n                           constraint_vals: list|None = None,\n                           signal_constr_vals: list|None = None,\n                           search_main_nodes_only: bool=False,\n                           n_max_steps: int = 20,\n                           verbose: bool=False,\n                           node_num_max: int|None=None,\n                           ):\n        '''\n        Solve for the equilibrium states of gene product in\n        terms of a given set of boolean (0, 1) values.\n        '''\n\n        # For any network, there may be nodes without regulation that require constraints\n        # (these are in self._constrained_nodes). Therefore, add these to any user-supplied\n        # constraints:\n        constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                            constraint_vals,\n                                                                            signal_constr_vals=signal_constr_vals)\n\n        if node_num_max is not None:\n            sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n            self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n        if constrained_inds is None or constrained_vals is None:\n            unconstrained_inds = self.nodes_index\n        else:\n            unconstrained_inds = np.setdiff1d(self.nodes_index, constrained_inds).tolist()\n\n        if search_main_nodes_only is False:\n            if len(unconstrained_inds) &lt;= 31:\n                # If the number of nodes is less than 32, use the faster numpy-based method:\n                # NOTE: 32 is a number that is hard-coded into Numpy\n                M_pstates, _, _ = self.generate_state_space(unconstrained_inds)\n\n            else:\n                M_pstates = self.generate_bool_state_space(unconstrained_inds)\n\n        else:\n            if len(self.main_nodes):\n                if node_num_max is None:\n                    M_pstates = self.generate_bool_state_space(self.main_nodes)\n                elif len(self.main_nodes) &lt; node_num_max:\n                    M_pstates, _, _ = self.generate_state_space(self.main_nodes)\n                else:\n                    M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n            else:\n                raise Exception(\"No main nodes; cannot perform state search with \"\n                                \"search_main_nodes_only=True.\")\n\n        sol_Mo = []\n        sol_char = []\n\n        for cvecto in M_pstates: # for each test vector:\n            # Need to modify the cvect vector to hold the value of the input nodes:\n            if constrained_inds is not None and constrained_vals is not None:\n                cvecto[constrained_inds] = constrained_vals\n\n            # get values for the genes we're solving for:\n            sol_i, char_i = self.net_state_compute(cvecto,\n                                                   A_bool_f,\n                                                   n_max_steps=n_max_steps,\n                                                   verbose=False,\n                                                   constraint_inds = constrained_inds,\n                                                   constraint_vals = constrained_vals\n                                                   )\n\n            sol_Mo.append(sol_i)\n            sol_char.append(char_i)\n\n            # if i == 0:\n            #     sol_Mo.append(sol_i)\n            #     sol_char.append(char_i)\n            #     i += 1\n            #\n            # else:\n            #     if sol_i not in np.asarray(sol_Mo):\n            #         sol_Mo.append(sol_i)\n            #         sol_char.append(char_i)\n\n            if verbose:\n                print(cvecto, sol_i, char_i)\n\n\n        _, unique_inds = np.unique(sol_Mo, axis=0, return_index=True)\n\n        sol_M = (np.asarray(sol_Mo)[unique_inds]).T\n        sol_char = np.asarray(sol_char)[unique_inds]\n\n        return sol_M, sol_char\n\n    def generate_state_space(self,\n                             c_inds: list,\n                             ) -&gt; tuple[ndarray, list, ndarray]:\n        '''\n        Generate a discrete state space over the range of probabilities of\n        each individual gene in the network.\n        '''\n        c_lins = []\n\n        for i in c_inds:\n            c_lins.append(np.asarray([0, 1], dtype=int))\n\n        cGrid = np.meshgrid(*c_lins)\n\n        N_pts = len(cGrid[0].ravel())\n\n        cM = np.zeros((N_pts, self.N_nodes), dtype=int)\n\n        for i, cGrid in zip(c_inds, cGrid):\n            cM[:, i] = cGrid.ravel()\n\n        return cM, c_lins, cGrid\n\n    def generate_bool_state_space(self,\n                             c_inds: list,\n                             ) -&gt; ndarray:\n        '''\n        Generate a discrete state space over the range of probabilities of\n        each individual gene in the network.\n        '''\n\n        # FIXME: this should not be expanded but code should be redeveloped to use only the iterator...\n        c_lins = list(itertools.product([0,1], repeat=len(c_inds)))\n        cM = np.zeros((len(c_lins), self.N_nodes), dtype=int)\n        cM[:, c_inds] = c_lins\n\n        return cM\n\n    def _handle_constrained_nodes(self,\n                                  constr_inds: list | None,\n                                  constr_vals: list | None,\n                                  signal_constr_vals: list | None = None\n                                  ) -&gt; tuple[list, list]:\n        '''\n        Networks will often have nodes without regulation that need to\n        be constrained during optimization. This helper-method augments\n        these naturally-occuring nodes with any additional constraints\n        supplied by the user.\n        '''\n        len_constr = len(self.input_node_inds)\n\n        if signal_constr_vals is None: # default to zero\n            sig_vals = (np.int8(np.zeros(len_constr))).tolist()\n        else:\n            sig_vals = signal_constr_vals\n\n        if len_constr != 0:\n            if constr_inds is None or constr_vals is None:\n                constrained_inds = self.input_node_inds.copy()\n                constrained_vals = sig_vals\n            else:\n                constrained_inds = constr_inds + self.input_node_inds.copy()\n                constrained_vals = constr_vals + sig_vals\n        else:\n            if constr_inds is None or constr_vals is None:\n                constrained_inds = []\n                constrained_vals = []\n\n            else:\n                constrained_inds = constr_inds*1\n                constrained_vals = constr_vals*1\n\n        return constrained_inds, constrained_vals\n\n\n    #---State Space Search -----------------\n    def bool_state_space(self,\n                         A_bool_f: Callable,\n                         constraint_inds: list | None = None,\n                         constraint_vals: list | None = None,\n                         signal_constr_vals: list | None = None,\n                         search_main_nodes_only: bool = False,\n                         n_max_steps: int = 20,\n                         node_num_max: int|None = None\n                         ):\n        '''\n\n        '''\n\n        constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                            constraint_vals,\n                                                                            signal_constr_vals=signal_constr_vals)\n\n        sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n        self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n        if constrained_inds is None or constrained_vals is None:\n            unconstrained_inds = self.nodes_index\n        else:\n            unconstrained_inds = np.setdiff1d(self.nodes_index, constrained_inds).tolist()\n\n        if search_main_nodes_only is False:\n            if len(unconstrained_inds) &lt; node_num_max:\n                # If the number of nodes is less than 32, use the faster numpy-based method:\n                # NOTE: 32 is a number that is hard-coded into Numpy\n                M_pstates, _, _ = self.generate_state_space(unconstrained_inds)\n\n            elif node_num_max is None:\n                # if it's greater than 32, numpy can't work with this, therefore use python itertools method:\n                M_pstates = self.generate_bool_state_space(unconstrained_inds)\n\n            else:\n                M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n        else:\n            if len(self.main_nodes):\n                if len(self.main_nodes) &lt; node_num_max:\n                    M_pstates, _, _ = self.generate_state_space(self.main_nodes)\n                elif node_num_max is None:\n                    M_pstates = self.generate_bool_state_space(self.main_nodes)\n                else:\n                    M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n            else:\n                raise Exception(\"No main nodes; cannot perform state search with \"\n                                \"search_main_nodes_only=True.\")\n\n        net_edges = set()  # store the edges of the boolean state diagram\n        pos={} # Holds node state position on the state transition diagram\n\n        # FIXME: this should be an enumeration not a matrix of 1 gillion states in M_pstates!!\n        for ci, cvecto in enumerate(M_pstates): # for each test vector:\n            # Need to modify the cvect vector to hold the value of the input nodes:\n            if constrained_inds is not None and constrained_vals is not None:\n                cvecto[constrained_inds] = constrained_vals\n\n            cc_i = cvecto  # initialize the function values (node values)\n\n            for i in range(n_max_steps):\n                cc_o = cc_i # save the initial value\n                cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values\n\n                # Need to modify the new concentrations vector to hold the value of the input nodes:\n                if constrained_inds is not None and constrained_vals is not None:\n                    cc_i[constrained_inds] = constrained_vals\n\n                nde1 = str(tuple(cc_o[self.noninput_node_inds]))\n                nde2 = str(tuple(cc_i[self.noninput_node_inds]))\n\n                # nde1 = ''.join(str(int(i)) for i in cc_o[self.noninput_node_inds])\n                # nde2 = ''.join(str(int(i)) for i in cc_i[self.noninput_node_inds])\n\n                net_edges.add((nde1, nde2))\n                pos[nde1] = tuple(cc_o[self.noninput_node_inds])\n                pos[nde2] = tuple(cc_i[self.noninput_node_inds])\n\n                # Detect whether we're at a steady-state:\n                if (cc_i == cc_o).all() is NumpyTrue:\n                    break\n\n        boolG = nx.DiGraph(net_edges)\n        return boolG, pos\n\n\n    # ----Plots and Data Export---------------\n\n    # FIXME: work this up\n    def save_model_equations(self,\n                             save_eqn_image: str,\n                             save_eqn_csv: str | None = None,\n                             ):\n        '''\n        Save images of the model equations, as well as a csv file that has\n        model equations written in LaTeX format.\n\n        Parameters\n        -----------\n        save_eqn_image : str\n            The path and filename to save the main model equations as an image.\n\n        save_reduced_eqn_image : str|None = None\n            The path and filename to save the reduced main model equations as an image (if model is reduced).\n\n        save_eqn_csv : str|None = None\n            The path and filename to save the main and reduced model equations as LaTex in a csv file.\n\n        '''\n        if self._A_bool_s is None:\n            raise Exception(\"No model built; cannot save model equations.\")\n\n        _c_vect_s = self._c_vect_s\n\n        c_name = sp.Matrix([ci for ci in _c_vect_s])\n        # eqn_net = sp.Eq(c_name, self._A_bool_s)\n\n        for ii, (cnme, beqn) in enumerate(zip(c_name, self._A_bool_s)):\n            eqn_net = sp.Eq(cnme, beqn)\n\n            save_eqn_image_i = save_eqn_image + f'_{cnme}_.png'\n\n            sp.preview(eqn_net,\n                       viewer='file',\n                       filename=save_eqn_image_i,\n                       euler=False,\n                       dvioptions=[\"-T\",\n                                   \"tight\",\n                                   \"-z\", \"0\",\n                                   \"--truecolor\",\n                                   \"-D 600\",\n                                   \"-bg\",\n                                   \"Transparent\"])\n\n        # Save the equations for the graph to a file:\n        header = ['Concentrations', 'Formula']\n        eqns_to_write = [[sp.latex(_c_vect_s), sp.latex(self._A_bool_s)]]\n\n        if save_eqn_csv is not None:\n            with open(save_eqn_csv, 'w', newline=\"\") as file:\n                csvwriter = csv.writer(file)  # 2. create a csvwriter object\n                csvwriter.writerow(header)  # 4. write the header\n                csvwriter.writerows(eqns_to_write)  # 5. write the rest of the data\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.__init__","title":"<code>__init__()</code>","text":"Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def __init__(self):\n    '''\n\n    '''\n\n    super().__init__()  # Initialize the base class\n\n    # Init all core attributes:\n    self.edges_list = None\n    self.nodes_list = None\n    self.GG = None\n    self.N_edges = None\n    self.N_nodes = None\n    self.edges_index = None\n    self.nodes_index = None\n\n    self._c_vect_s = None\n    self._A_bool_s = None\n    self._A_bool_f = None\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.bool_state_space","title":"<code>bool_state_space(A_bool_f, constraint_inds=None, constraint_vals=None, signal_constr_vals=None, search_main_nodes_only=False, n_max_steps=20, node_num_max=None)</code>","text":"Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def bool_state_space(self,\n                     A_bool_f: Callable,\n                     constraint_inds: list | None = None,\n                     constraint_vals: list | None = None,\n                     signal_constr_vals: list | None = None,\n                     search_main_nodes_only: bool = False,\n                     n_max_steps: int = 20,\n                     node_num_max: int|None = None\n                     ):\n    '''\n\n    '''\n\n    constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                        constraint_vals,\n                                                                        signal_constr_vals=signal_constr_vals)\n\n    sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n    self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n    if constrained_inds is None or constrained_vals is None:\n        unconstrained_inds = self.nodes_index\n    else:\n        unconstrained_inds = np.setdiff1d(self.nodes_index, constrained_inds).tolist()\n\n    if search_main_nodes_only is False:\n        if len(unconstrained_inds) &lt; node_num_max:\n            # If the number of nodes is less than 32, use the faster numpy-based method:\n            # NOTE: 32 is a number that is hard-coded into Numpy\n            M_pstates, _, _ = self.generate_state_space(unconstrained_inds)\n\n        elif node_num_max is None:\n            # if it's greater than 32, numpy can't work with this, therefore use python itertools method:\n            M_pstates = self.generate_bool_state_space(unconstrained_inds)\n\n        else:\n            M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n    else:\n        if len(self.main_nodes):\n            if len(self.main_nodes) &lt; node_num_max:\n                M_pstates, _, _ = self.generate_state_space(self.main_nodes)\n            elif node_num_max is None:\n                M_pstates = self.generate_bool_state_space(self.main_nodes)\n            else:\n                M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n        else:\n            raise Exception(\"No main nodes; cannot perform state search with \"\n                            \"search_main_nodes_only=True.\")\n\n    net_edges = set()  # store the edges of the boolean state diagram\n    pos={} # Holds node state position on the state transition diagram\n\n    # FIXME: this should be an enumeration not a matrix of 1 gillion states in M_pstates!!\n    for ci, cvecto in enumerate(M_pstates): # for each test vector:\n        # Need to modify the cvect vector to hold the value of the input nodes:\n        if constrained_inds is not None and constrained_vals is not None:\n            cvecto[constrained_inds] = constrained_vals\n\n        cc_i = cvecto  # initialize the function values (node values)\n\n        for i in range(n_max_steps):\n            cc_o = cc_i # save the initial value\n            cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values\n\n            # Need to modify the new concentrations vector to hold the value of the input nodes:\n            if constrained_inds is not None and constrained_vals is not None:\n                cc_i[constrained_inds] = constrained_vals\n\n            nde1 = str(tuple(cc_o[self.noninput_node_inds]))\n            nde2 = str(tuple(cc_i[self.noninput_node_inds]))\n\n            # nde1 = ''.join(str(int(i)) for i in cc_o[self.noninput_node_inds])\n            # nde2 = ''.join(str(int(i)) for i in cc_i[self.noninput_node_inds])\n\n            net_edges.add((nde1, nde2))\n            pos[nde1] = tuple(cc_o[self.noninput_node_inds])\n            pos[nde2] = tuple(cc_i[self.noninput_node_inds])\n\n            # Detect whether we're at a steady-state:\n            if (cc_i == cc_o).all() is NumpyTrue:\n                break\n\n    boolG = nx.DiGraph(net_edges)\n    return boolG, pos\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.build_adjacency_matrices","title":"<code>build_adjacency_matrices(edge_types, edges_index)</code>","text":"Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def build_adjacency_matrices(self,\n                    edge_types: list[EdgeType],\n                    edges_index: list[tuple[int,int]],\n                    ):\n    '''\n\n    '''\n    # Initialize an activator matrix:\n    A_acti_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n    # Initialize an inhibitor matrix:\n    A_inhi_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n    # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n    # and multiplicative interactions:cc\n    for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n        if etype is EdgeType.A or etype is EdgeType.As:\n            A_acti_s[nde_j, nde_i] = 1\n        elif etype is EdgeType.I or etype is EdgeType.Is:\n            A_inhi_s[nde_j, nde_i] = 1\n\n    A_acti_s = sp.Matrix(A_acti_s)\n    A_inhi_s = sp.Matrix(A_inhi_s)\n\n    return A_acti_s, A_inhi_s\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.build_boolean_model","title":"<code>build_boolean_model(use_node_name=True, multi_coupling_type=CouplingType.mix1, constitutive_express=False)</code>","text":"<p>Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s) as well as a vectorized numpy function (A_bool_f) that accepts the list or array of node concentrations.</p> <p>Parameters:</p> Name Type Description Default <code>use_node_name</code> <code>bool</code> <p>If True, the node label is used as the symbolic parameter name. Otherwise a shorter parameter label of 'g_#\" is used, where # is the node's index in the network.</p> <code>True</code> <code>multi_coupling_type</code> <code>CouplingType</code> <p>Specify how factors are combined at individual target nodes.</p> <code>mix1</code> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def build_boolean_model(self, use_node_name: bool=True,\n                        multi_coupling_type: CouplingType=CouplingType.mix1,\n                        constitutive_express: bool = False):\n    '''\n    Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s)\n    as well as a vectorized numpy function (A_bool_f) that accepts the list or array of\n    node concentrations.\n\n    Parameters\n    ----------\n    use_node_name: bool = True\n        If True, the node label is used as the symbolic parameter name. Otherwise a shorter\n        parameter label of 'g_#\" is used, where # is the node's index in the network.\n\n    multi_coupling_type: CouplingType=CouplingType.mixed\n        Specify how factors are combined at individual target nodes.\n\n\n    '''\n    if use_node_name:\n        c_vect_s = sp.Matrix([sp.Symbol(nde_nme, positive=True) for nde_nme in self.nodes_list])\n    else: # use the node's numerical index as a label\n        c_vect_s = sp.Matrix([sp.Symbol(f'g_{nde_i}',\n                                        positive=True) for nde_i in self.nodes_index])\n\n    if multi_coupling_type is CouplingType.mix1:\n        # Case #1: Mixed coupling, where inhibitors always act in \"OR\"\n        # configuration and activators act in \"AND\" configuration.\n        # Initialize an activator matrix:\n        A_acti_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        # onesv = np.ones(self.N_nodes, dtype=int)\n\n        # Initialize an inhibitor matrix:\n        A_inhi_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n        acti_count = [0 for i in range(self.N_nodes)]  # counts the number of activators acting on each node\n        inhi_count = [0 for i in range(self.N_nodes)]  # counts the number of inhibitors acting on each node\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:cc\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n            # print(type(nde_i))\n            # print(c_vect_s[nde_i])\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_acti_so[nde_j, nde_i] = 1\n                acti_count[nde_j] += 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_inhi_so[nde_j, nde_i] = 1 - c_vect_s[nde_i]\n                inhi_count[nde_j] += 1\n\n        # Combine so that presence of activators AND absence of inhibitors required for node expressions:\n        if constitutive_express is False:\n            # Need to create a normalized vector for managing cooperativity of the \"OR\"\n            denom = np.asarray(acti_count)  # total number of activators at each node\n            idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n            denom[idenom] = 1  # set those equal to 1\n            denom = np.int64(denom)\n            coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n            A_acti_so = (coopv * A_acti_so.T).T # multiply by the normalizing vector coopv\n            A_acti_ss = A_acti_so.dot(c_vect_s)\n\n            const_inds = [] # if there's inhibitor but no activator, node must be const expressed\n            for ndei, (act, ict) in enumerate(zip(acti_count, inhi_count)):\n                if act == 0 and ict != 0:\n                    const_inds.append(ndei)\n\n            A_acti_ss[const_inds] = 1 # set this to 1 where the const expressed nodes should me\n\n            A_acti_s = sp.Matrix(A_acti_ss) # collect terms into \"OR\" activators at each node\n            A_inhi_s = sp.Matrix(np.prod(A_inhi_so, axis=1)) # collect terms into \"AND\" inhibitors at each node\n            A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s) # Use \"AND\" to combine acti and inhi\n\n        # We use and additive \"OR\" to specify the presence of an activator OR absence of an inhibitor\n        # is required for gene expression for all genes\n        else:\n            # Need to create a normalized vector for managing cooperativity of the \"OR\"\n            # sums the number of activators and if inhibitors at each node:\n            denom = np.asarray(acti_count) + np.sign(inhi_count)\n            idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n            denom[idenom] = 1  # set those equal to 1\n            denom = np.int64(denom)\n            coopv = sp.Matrix([sp.Rational(1, di) for di in denom]) # write as fractions for pretty display\n\n            # Multiply the system through with the normalizing coefficients:\n            A_acti_s = sp.hadamard_product(coopv, sp.Matrix(A_acti_so.dot(c_vect_s)))\n            A_inhi_s = sp.hadamard_product(coopv, sp.Matrix(np.sign(inhi_count) * np.prod(A_inhi_so, axis=1)))\n            # Combine activators and inhibitors as \"OR\" function:\n            A_bool_s = A_acti_s + A_inhi_s\n\n\n    elif multi_coupling_type is CouplingType.mix2:\n        # Mixed coupling #2, where inhibitors always act in \"AND\"\n        # configuration and activators act in \"OR\" configuration.\n        # Initialize an inhibitor matrix:\n        A_inhi_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        onesv = np.ones(self.N_nodes, dtype=int)\n\n        acti_count = [0 for i in range(self.N_nodes)]  # counts the number of activators acting on each node\n        inhi_count = [0 for i in range(self.N_nodes)]  # counts the number of inhibitors acting on each node\n\n        # Initialize an activator matrix:\n        A_acti_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:cc\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n            # print(type(nde_i))\n            # print(c_vect_s[nde_i])\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_acti_so[nde_j, nde_i] = c_vect_s[nde_i]\n                acti_count[nde_j] += 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_inhi_so[nde_j, nde_i] = 1\n                inhi_count[nde_j] += 1\n\n        # Combine so that presence of activators AND absence of inhibitors required for node expressions:\n        if constitutive_express is False:\n            # Need to create a normalized vector for managing cooperativity of the \"OR\"\n            denom = np.asarray(inhi_count)  # total number of activators at each node\n            idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n            denom[idenom] = 1  # set those equal to 1\n            denom = np.int64(denom)\n            coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n            A_inhi_so = (coopv * A_inhi_so.T).T  # multiply by the normalizing vector coopv\n            A_inhi_ss = A_inhi_so.dot(sp.Matrix(onesv) - c_vect_s)\n\n            const_inds = []  # if there's inhibitor but no activator, node must be const expressed\n            for ndei, (act, ict) in enumerate(zip(acti_count, inhi_count)):\n                if act != 0 and ict == 0:\n                    const_inds.append(ndei)\n\n            A_inhi_ss[const_inds] = 1  # set this to 1 where the const expressed nodes should me\n\n            A_inhi_s = sp.Matrix(A_inhi_ss)  # collect terms into \"OR\" activators at each node\n            A_acti_s = sp.Matrix(\n                np.prod(A_acti_so, axis=1))  # collect terms into \"AND\" inhibitors at each node\n            A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s)  # Use \"AND\" to combine acti and inhi\n\n        # We use and additive \"OR\" to specify the presence of an activator OR absence of an inhibitor\n        # is required for gene expression for all genes\n        else:\n            # Need to create a normalized vector for managing cooperativity of the \"OR\"\n            # sums the number of activators and if inhibitors at each node:\n            denom = np.asarray(inhi_count) + np.sign(acti_count)\n            idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n            denom[idenom] = 1  # set those equal to 1\n            denom = np.int64(denom)\n            coopv = sp.Matrix([sp.Rational(1, di) for di in denom])  # write as fractions for pretty display\n\n            # Multiply the system through with the normalizing coefficients:\n            A_inhi_s = sp.hadamard_product(coopv, sp.Matrix(A_inhi_so.dot(sp.Matrix(onesv) - c_vect_s)))\n            A_acti_s = sp.hadamard_product(coopv,\n                                           sp.Matrix(np.sign(acti_count) * np.prod(A_acti_so, axis=1)))\n            # Combine activators and inhibitors as \"OR\" function:\n            A_bool_s = A_acti_s + A_inhi_s\n\n\n    elif multi_coupling_type is CouplingType.additive:\n\n        # Case #2: Additive coupling, where all interactions inhibitors always act in\n        # \"AND\" configuration.\n        # Initialize an activator matrix:\n        A_acti_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        # Initialize an inhibitor matrix:\n        A_inhi_so = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n        # Initialize a \"ones vector\" for each node:\n        onesv = np.ones(self.N_nodes, dtype=int)\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:cc\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n            # print(type(nde_i))\n            # print(c_vect_s[nde_i])\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_acti_so[nde_j, nde_i] = 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_inhi_so[nde_j, nde_i] = 1\n\n        ic_vect_s = sp.Matrix(onesv) - c_vect_s\n\n        denom = (A_acti_so + A_inhi_so).dot(onesv)\n        idenom = (denom == 0).nonzero()[0]  # indices where denom is zero\n        denom[idenom] = 1  # set those equal to 1\n        denom = np.int64(denom)\n        # coopv = 1 / denom\n        coopv = np.asarray([sp.Rational(1, di) for di in denom])\n\n        A_acti_so = (coopv * A_acti_so.T).T\n        A_inhi_so = (coopv * A_inhi_so.T).T\n\n        A_acti_s = sp.Matrix(A_acti_so.dot(c_vect_s))\n        A_inhi_s = sp.Matrix(A_inhi_so.dot(ic_vect_s))\n        A_bool_s = A_acti_s + A_inhi_s\n\n    elif multi_coupling_type is CouplingType.multiplicative:\n        # Case #1: Mixed coupling, where inhibitors always act in \"OR\"\n        # configuration and activators act in \"AND\" configuration.\n        # Initialize an activator matrix:\n        A_acti_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n        # Initialize an inhibitor matrix:\n        A_inhi_so = np.ones((self.N_nodes, self.N_nodes), dtype=sp.Symbol)\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:cc\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(self.edges_index, self.edge_types)):\n            # print(type(nde_i))\n            # print(c_vect_s[nde_i])\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_acti_so[nde_j, nde_i] = c_vect_s[nde_i]\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_inhi_so[nde_j, nde_i] = 1 - c_vect_s[nde_i]\n\n        A_acti_s = sp.Matrix(np.prod(A_acti_so, axis=1))\n        A_inhi_s = sp.Matrix(np.prod(A_inhi_so, axis=1))\n        A_bool_s = sp.hadamard_product(A_acti_s, A_inhi_s)\n\n    else:\n        raise Exception(\"Only additive, multiplicative, and mixed coupling types are supported\")\n\n    # Finally, create a vectorized numpy function to calculate the result:\n    A_bool_f = sp.lambdify([c_vect_s], A_bool_s.T)\n    self._c_vect_s = c_vect_s\n    self._A_bool_s = A_bool_s\n    self._A_bool_f = A_bool_f\n\n    return c_vect_s, A_bool_s, A_bool_f\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.generate_bool_state_space","title":"<code>generate_bool_state_space(c_inds)</code>","text":"<p>Generate a discrete state space over the range of probabilities of each individual gene in the network.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def generate_bool_state_space(self,\n                         c_inds: list,\n                         ) -&gt; ndarray:\n    '''\n    Generate a discrete state space over the range of probabilities of\n    each individual gene in the network.\n    '''\n\n    # FIXME: this should not be expanded but code should be redeveloped to use only the iterator...\n    c_lins = list(itertools.product([0,1], repeat=len(c_inds)))\n    cM = np.zeros((len(c_lins), self.N_nodes), dtype=int)\n    cM[:, c_inds] = c_lins\n\n    return cM\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.generate_state_space","title":"<code>generate_state_space(c_inds)</code>","text":"<p>Generate a discrete state space over the range of probabilities of each individual gene in the network.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def generate_state_space(self,\n                         c_inds: list,\n                         ) -&gt; tuple[ndarray, list, ndarray]:\n    '''\n    Generate a discrete state space over the range of probabilities of\n    each individual gene in the network.\n    '''\n    c_lins = []\n\n    for i in c_inds:\n        c_lins.append(np.asarray([0, 1], dtype=int))\n\n    cGrid = np.meshgrid(*c_lins)\n\n    N_pts = len(cGrid[0].ravel())\n\n    cM = np.zeros((N_pts, self.N_nodes), dtype=int)\n\n    for i, cGrid in zip(c_inds, cGrid):\n        cM[:, i] = cGrid.ravel()\n\n    return cM, c_lins, cGrid\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.net_multisequence_compute","title":"<code>net_multisequence_compute(cc_o, sigs_vect, A_bool_f, n_max_steps=20, constraint_inds=None, verbose=False)</code>","text":"Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def net_multisequence_compute(self,\n                              cc_o: ndarray|list,\n                              sigs_vect: ndarray|list,\n                              A_bool_f: Callable,\n                              n_max_steps: int=20,\n                              constraint_inds: list|None=None,\n                              verbose: bool=False):\n    '''\n\n    '''\n    sol_results = []\n    sol_char_results = []\n    sequence_results = None\n    pseudo_tvect = None\n\n    phase_inds = [] # tuples marking the start and stop of each input intervention\n\n    tn_0 = 0\n    tn_1 = n_max_steps + 1\n\n    for ii, sig_vals in enumerate(sigs_vect):\n        phase_inds.append((tn_0, tn_1))\n\n        cc_o[constraint_inds] = sig_vals\n        solsv, cc_o, sol_char, motif = self.net_sequence_compute(cc_o,\n                                                                 A_bool_f,\n                                                                 n_max_steps=n_max_steps,\n                                                                 constraint_inds=constraint_inds,\n                                                                 constraint_vals=sig_vals,\n                                                                 verbose=verbose\n                                                                 )\n\n        pseudo_tvect_i = np.arange(tn_0, tn_1)\n        # update the tn vectors for next time:\n        tn_0 = tn_1\n        tn_1 += n_max_steps + 1\n\n        if ii == 0:\n            sequence_results = solsv\n            pseudo_tvect = pseudo_tvect_i\n\n        else:\n            sequence_results = np.vstack((sequence_results, solsv))\n            pseudo_tvect = np.hstack((pseudo_tvect, pseudo_tvect_i))\n\n        sol_results.append(cc_o) # append the final eq'm state value\n        sol_char_results.append(sol_char) # append the eq'm characterization\n\n    return pseudo_tvect, sequence_results, sol_results, sol_char_results, phase_inds\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.net_sequence_compute","title":"<code>net_sequence_compute(cc_o, A_bool_f, n_max_steps=20, constraint_inds=None, constraint_vals=None, verbose=False)</code>","text":"<p>Returns the sequence of n_max_step states occurring after an initial state, cc_o, determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic of the eq'm as a point attractor or limit cycle.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def net_sequence_compute(self,\n                          cc_o: ndarray|list,\n                          A_bool_f: Callable,\n                          n_max_steps: int=20,\n                          constraint_inds: list|None=None,\n                          constraint_vals: list|None=None,\n                          verbose: bool=False\n                          ):\n    '''\n    Returns the sequence of n_max_step states occurring after an initial state, cc_o,\n    determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic\n    of the eq'm as a point attractor or limit cycle.\n    '''\n    cc_i = cc_o  # initialize the function values (node values)\n    solsv = [np.asarray(cc_o)]  # holds a list of transient solutions, beginning with the initial state\n    sol_char = EquilibriumType.undetermined # initialize to undetermined\n\n    motif = None\n\n    for i in range(n_max_steps):\n\n        if verbose:\n            print(solsv[-1])\n        # A true \"OR\" function will return the maximum of the list of booleans. This can\n        # be achieved by using the \"ceiling\" function. If cooperative interaction is\n        # desired, then rounding is better\n\n        cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values of the sequence\n\n        # If there are constraints on some node vals, force them to the constraint:\n        if constraint_inds is not None and constraint_vals is not None:\n            cc_i[constraint_inds] = constraint_vals\n\n        solsv.append(cc_i) # append the new state to the sequence vector\n\n    # Now that the sequence has been collected, determine if it's a steady-state, and if so,\n    # characterize the eq'm:\n    if (solsv[-1] == solsv[-2]).all() is NumpyTrue:\n        sol_char = EquilibriumType.attractor\n\n    else:\n        # test to see if we have a more complicated repetition motif:\n        solvr = np.asarray(solsv)[:, self.noninput_node_inds]  # get the reduced array\n        si = solvr[-1, :]  # try selecting the last state to check for repetition in the sequence...\n        matched_inds = [i for i, x in enumerate(solvr.tolist()) if x == si.tolist()]  # look for repetition\n        if len(matched_inds) &gt; 1:  # if there's more than one incidence of the state\n            motif = np.asarray(solsv)[matched_inds[-2]:matched_inds[-1], :]  # extract a motif from the full seq\n            cc_i = np.mean(motif, axis=0)  # solution becomes the (non-integer!) mean of the motif\n            if len(motif) &gt; 2:\n                sol_char = EquilibriumType.limit_cycle\n            else:  # otherwise the motif is a saddle (metabstable state):\n                sol_char = EquilibriumType.saddle\n\n    # convert solsv to a numpy array with n_max_steps rows and self.N_Nodes columns:\n    solsv = np.asarray(solsv)\n\n    return solsv, cc_i, sol_char, motif\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.net_state_compute","title":"<code>net_state_compute(cc_o, A_bool_f, n_max_steps=20, constraint_inds=None, constraint_vals=None, verbose=False)</code>","text":"Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def net_state_compute(self,\n                          cc_o: ndarray|list,\n                          A_bool_f: Callable,\n                          n_max_steps: int=20,\n                          constraint_inds: list|None=None,\n                          constraint_vals: list|None=None,\n                          verbose: bool=False\n                          ):\n    '''\n\n    '''\n    cc_i = cc_o  # initialize the function values (node values)\n    solsv = [cc_o]  # holds a list of transient solutions\n    sol_char = EquilibriumType.undetermined # initialize to undetermined\n\n    for ii in range(n_max_steps):\n\n        if verbose:\n            print(solsv[-1])\n        # A true \"OR\" function will return the maximum of the list of booleans. This can\n        # be achieved by using the \"np.sign\" as a \"ceiling\" function:\n\n        cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values for this next step i\n\n        # If there are constraints on some node vals, force them to the constraint:\n        if constraint_inds is not None and constraint_vals is not None:\n            cc_i[constraint_inds] = constraint_vals\n\n        solsv.append(cc_i)\n\n        # Detect whether we're at a steady-state at any point in this analysis:\n        if (solsv[ii] == solsv[ii - 1]).all() is NumpyTrue:\n            sol_char = EquilibriumType.attractor\n            break\n\n        # Otherwise, when we reach the end of the sequence, search for repeated motifs:\n        elif ii == n_max_steps -1:\n            # test to see if we have a more complicated repetition motif:\n            solvr = np.asarray(solsv)[:, self.noninput_node_inds] # get the reduced array\n            si = solvr[-1, :] # try selecting the last state to check for repetition...\n            matched_inds = [i for i, x in enumerate(solvr.tolist()) if x == si.tolist()] # look for repetition\n            if len(matched_inds) &gt; 1: # if there's more than one incidence of the state\n                motif = np.asarray(solsv)[matched_inds[-2]:matched_inds[-1], :] # extract a motif from the full array\n                cc_i = np.mean(motif, axis=0) # solution becomes the (non-integer!) mean of the motif\n                if len(motif) &gt; 2:\n                    sol_char = EquilibriumType.limit_cycle\n                else: # otherwise the motif is a saddle (metabstable state):\n                    sol_char = EquilibriumType.saddle\n\n    return cc_i, sol_char\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.run_iter_sim","title":"<code>run_iter_sim(tvect, cvecti, A_bool_f, sig_inds, sig_vals)</code>","text":"<p>Returns the sequence of n_max_step states occurring after an initial state, cc_o, under a dynamically specified stimulation applied to constraint_inds with value constraint_vals.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def run_iter_sim(self,\n                 tvect: ndarray|list, # main time vector\n                 cvecti: ndarray|list, # initial state of all the network nodes\n                 A_bool_f: Callable,\n                 sig_inds: ndarray|list,\n                 sig_vals: ndarray,\n                     ):\n    '''\n    Returns the sequence of n_max_step states occurring after an initial state, cc_o,\n    under a dynamically specified stimulation applied to constraint_inds with value\n    constraint_vals.\n    '''\n    cc_i = cvecti  # initialize the function values (node values)\n    solsv = []  # holds a list of transient solutions\n\n    if len(tvect) != sig_vals.shape[0]:\n        raise Exception('Rows of sig_vals array must equal the '\n                        'number of time iterations in tvect!')\n\n    for tt in tvect:\n\n        solsv.append(cc_i)  # append the new state to the sequence vector\n\n        cc_i = np.sign(A_bool_f(cc_i)[0])  # calculate new state values of the sequence\n\n        # Force node values to the value of the dynamic constraint:\n        cc_i[sig_inds] = sig_vals[tt, :]\n\n    solsv = np.asarray(solsv)\n\n    return solsv\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.save_model_equations","title":"<code>save_model_equations(save_eqn_image, save_eqn_csv=None)</code>","text":"<p>Save images of the model equations, as well as a csv file that has model equations written in LaTeX format.</p> <p>Parameters:</p> Name Type Description Default <code>save_eqn_image</code> <code>str</code> <p>The path and filename to save the main model equations as an image.</p> required <code>save_reduced_eqn_image</code> <code>str|None = None</code> <p>The path and filename to save the reduced main model equations as an image (if model is reduced).</p> required <code>save_eqn_csv</code> <code>str|None = None</code> <p>The path and filename to save the main and reduced model equations as LaTex in a csv file.</p> <code>None</code> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def save_model_equations(self,\n                         save_eqn_image: str,\n                         save_eqn_csv: str | None = None,\n                         ):\n    '''\n    Save images of the model equations, as well as a csv file that has\n    model equations written in LaTeX format.\n\n    Parameters\n    -----------\n    save_eqn_image : str\n        The path and filename to save the main model equations as an image.\n\n    save_reduced_eqn_image : str|None = None\n        The path and filename to save the reduced main model equations as an image (if model is reduced).\n\n    save_eqn_csv : str|None = None\n        The path and filename to save the main and reduced model equations as LaTex in a csv file.\n\n    '''\n    if self._A_bool_s is None:\n        raise Exception(\"No model built; cannot save model equations.\")\n\n    _c_vect_s = self._c_vect_s\n\n    c_name = sp.Matrix([ci for ci in _c_vect_s])\n    # eqn_net = sp.Eq(c_name, self._A_bool_s)\n\n    for ii, (cnme, beqn) in enumerate(zip(c_name, self._A_bool_s)):\n        eqn_net = sp.Eq(cnme, beqn)\n\n        save_eqn_image_i = save_eqn_image + f'_{cnme}_.png'\n\n        sp.preview(eqn_net,\n                   viewer='file',\n                   filename=save_eqn_image_i,\n                   euler=False,\n                   dvioptions=[\"-T\",\n                               \"tight\",\n                               \"-z\", \"0\",\n                               \"--truecolor\",\n                               \"-D 600\",\n                               \"-bg\",\n                               \"Transparent\"])\n\n    # Save the equations for the graph to a file:\n    header = ['Concentrations', 'Formula']\n    eqns_to_write = [[sp.latex(_c_vect_s), sp.latex(self._A_bool_s)]]\n\n    if save_eqn_csv is not None:\n        with open(save_eqn_csv, 'w', newline=\"\") as file:\n            csvwriter = csv.writer(file)  # 2. create a csvwriter object\n            csvwriter.writerow(header)  # 4. write the header\n            csvwriter.writerows(eqns_to_write)  # 5. write the rest of the data\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_boolean_networks/#cellnition.science.network_models.boolean_networks.BooleanNet.solve_system_equms","title":"<code>solve_system_equms(A_bool_f, constraint_inds=None, constraint_vals=None, signal_constr_vals=None, search_main_nodes_only=False, n_max_steps=20, verbose=False, node_num_max=None)</code>","text":"<p>Solve for the equilibrium states of gene product in terms of a given set of boolean (0, 1) values.</p> Source code in <code>cellnition/science/network_models/boolean_networks.py</code> <pre><code>def solve_system_equms(self,\n                       A_bool_f: Callable,\n                       constraint_inds: list|None = None,\n                       constraint_vals: list|None = None,\n                       signal_constr_vals: list|None = None,\n                       search_main_nodes_only: bool=False,\n                       n_max_steps: int = 20,\n                       verbose: bool=False,\n                       node_num_max: int|None=None,\n                       ):\n    '''\n    Solve for the equilibrium states of gene product in\n    terms of a given set of boolean (0, 1) values.\n    '''\n\n    # For any network, there may be nodes without regulation that require constraints\n    # (these are in self._constrained_nodes). Therefore, add these to any user-supplied\n    # constraints:\n    constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                        constraint_vals,\n                                                                        signal_constr_vals=signal_constr_vals)\n\n    if node_num_max is not None:\n        sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n        self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n    if constrained_inds is None or constrained_vals is None:\n        unconstrained_inds = self.nodes_index\n    else:\n        unconstrained_inds = np.setdiff1d(self.nodes_index, constrained_inds).tolist()\n\n    if search_main_nodes_only is False:\n        if len(unconstrained_inds) &lt;= 31:\n            # If the number of nodes is less than 32, use the faster numpy-based method:\n            # NOTE: 32 is a number that is hard-coded into Numpy\n            M_pstates, _, _ = self.generate_state_space(unconstrained_inds)\n\n        else:\n            M_pstates = self.generate_bool_state_space(unconstrained_inds)\n\n    else:\n        if len(self.main_nodes):\n            if node_num_max is None:\n                M_pstates = self.generate_bool_state_space(self.main_nodes)\n            elif len(self.main_nodes) &lt; node_num_max:\n                M_pstates, _, _ = self.generate_state_space(self.main_nodes)\n            else:\n                M_pstates = self.generate_bool_state_space(self.influence_node_inds)\n\n        else:\n            raise Exception(\"No main nodes; cannot perform state search with \"\n                            \"search_main_nodes_only=True.\")\n\n    sol_Mo = []\n    sol_char = []\n\n    for cvecto in M_pstates: # for each test vector:\n        # Need to modify the cvect vector to hold the value of the input nodes:\n        if constrained_inds is not None and constrained_vals is not None:\n            cvecto[constrained_inds] = constrained_vals\n\n        # get values for the genes we're solving for:\n        sol_i, char_i = self.net_state_compute(cvecto,\n                                               A_bool_f,\n                                               n_max_steps=n_max_steps,\n                                               verbose=False,\n                                               constraint_inds = constrained_inds,\n                                               constraint_vals = constrained_vals\n                                               )\n\n        sol_Mo.append(sol_i)\n        sol_char.append(char_i)\n\n        # if i == 0:\n        #     sol_Mo.append(sol_i)\n        #     sol_char.append(char_i)\n        #     i += 1\n        #\n        # else:\n        #     if sol_i not in np.asarray(sol_Mo):\n        #         sol_Mo.append(sol_i)\n        #         sol_char.append(char_i)\n\n        if verbose:\n            print(cvecto, sol_i, char_i)\n\n\n    _, unique_inds = np.unique(sol_Mo, axis=0, return_index=True)\n\n    sol_M = (np.asarray(sol_Mo)[unique_inds]).T\n    sol_char = np.asarray(sol_char)[unique_inds]\n\n    return sol_M, sol_char\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/","title":"Interaction Functions","text":"<p>This module contains different functions that can be applied as the influence of one node over another node (node-node interaction) when constructing an analytical model. These functions are intended to be used with symbolic computing (sympy).</p>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_acti_hill_s","title":"<code>f_acti_hill_s(cc, beta, nn)</code>","text":"<p>Activator function based on a Hill function. The entity, cc, will be activating another node.</p> <p>Parameters:</p> Name Type Description Default <code>cc</code> <code>float | ndarray | list</code> <p>Concentration or set of concentrations at which to compute the function.</p> required <code>beta</code> <code>Symbol | Indexed</code> <p>The network Hill coefficient, which is equal to the maximum rate of production of cc divided by the decay of cc multiplied by the standard Hill coefficient: (beta = r_max/(d_max*K_edge)).</p> required <code>nn</code> <code>float</code> <p>The Hill exponent.</p> required Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_acti_hill_s(cc: Symbol|Indexed, beta: Symbol|Indexed, nn: Symbol|Indexed):\n    '''\n    Activator function based on a Hill function.\n    The entity, cc, will be activating another node.\n\n    Parameters\n    ----------\n    cc : float|ndarray|list\n        Concentration or set of concentrations at which\n        to compute the function.\n    beta: float\n        The network Hill coefficient, which is equal to the\n        maximum rate of production of cc divided by the\n        decay of cc multiplied by the standard Hill coefficient:\n        (beta = r_max/(d_max*K_edge)).\n    nn : float\n        The Hill exponent.\n\n    '''\n    return ((cc * beta) ** nn) / (1 + (cc * beta) ** nn)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_acti_logi_s","title":"<code>f_acti_logi_s(cc, co, k)</code>","text":"<p>Activator function based on a logistic function. The entity, cc, will be activating another node. This function can only be used in symbolic Sympy equations.</p> <p>Parameters:</p> Name Type Description Default <code>cc</code> <code>float | ndarray | list</code> <p>Concentration or set of concentrations at which to compute the function.</p> required <code>co</code> <code>Symbol | Indexed</code> <p>The centre of the sigmoidal logistic curve.</p> required <code>k</code> <code>float</code> <p>The coupling strength/rise function. Here k&gt;0 to achieve an activator response.</p> required Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_acti_logi_s(cc: Symbol|Indexed, co: Symbol|Indexed, k: Symbol|Indexed):\n    '''\n    Activator function based on a logistic function.\n    The entity, cc, will be activating another node.\n    This function can only be used in symbolic Sympy\n    equations.\n\n    Parameters\n    ----------\n    cc : float|ndarray|list\n        Concentration or set of concentrations at which\n        to compute the function.\n    co: float\n        The centre of the sigmoidal logistic curve.\n    k : float\n        The coupling strength/rise function. Here k&gt;0 to\n        achieve an activator response.\n\n    '''\n    return 1/(1 + sp.exp(-k*(cc - co)))\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_hill_s","title":"<code>f_hill_s(i, j, pp, nn, beta)</code>","text":"<p>Generic hill function.</p> Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_hill_s(i, j, pp: MatrixSymbol, nn: MatrixSymbol, beta: MatrixSymbol):\n    '''\n    Generic hill function.\n\n    '''\n    return 1/(1 + (beta[j,i] * pp[j,i]) ** -nn[j,i])\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_inhi_hill_s","title":"<code>f_inhi_hill_s(cc, beta, nn)</code>","text":"<p>Inhibitor function based on a Hill function. The entity, cc, will be inhibiting another node.</p> <p>Parameters:</p> Name Type Description Default <code>cc</code> <code>float | ndarray | list</code> <p>Concentration or set of concentrations at which to compute the function.</p> required <code>beta</code> <code>Symbol | Indexed</code> <p>The network Hill coefficient, which is equal to the maximum rate of production of cc divided by the decay of cc multiplied by the standard Hill coefficient: (beta = r_max/(d_max*K_edge)).</p> required <code>nn</code> <code>float</code> <p>The Hill exponent.</p> required Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_inhi_hill_s(cc: Symbol|Indexed, beta: Symbol|Indexed, nn: Symbol|Indexed):\n    '''\n    Inhibitor function based on a Hill function.\n    The entity, cc, will be inhibiting another node.\n\n    Parameters\n    ----------\n    cc : float|ndarray|list\n        Concentration or set of concentrations at which\n        to compute the function.\n    beta: float\n        The network Hill coefficient, which is equal to the\n        maximum rate of production of cc divided by the\n        decay of cc multiplied by the standard Hill coefficient:\n        (beta = r_max/(d_max*K_edge)).\n    nn : float\n        The Hill exponent.\n\n    '''\n    return 1 / (1 + (cc * beta) ** nn)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_inhi_logi_s","title":"<code>f_inhi_logi_s(cc, co, k)</code>","text":"<p>Activator function based on a logistic function. The entity, cc, will be activating another node. This function can only be used in symbolic Sympy equations.</p> <p>Parameters:</p> Name Type Description Default <code>cc</code> <code>float | ndarray | list</code> <p>Concentration or set of concentrations at which to compute the function.</p> required <code>co</code> <code>Symbol | Indexed</code> <p>The centre of the sigmoidal logistic curve.</p> required <code>k</code> <code>float</code> <p>The coupling strength/rise function. Here k&gt;0 to achieve an inhibition response.</p> required Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_inhi_logi_s(cc: Symbol|Indexed, co: Symbol|Indexed, k: Symbol|Indexed):\n    '''\n    Activator function based on a logistic function.\n    The entity, cc, will be activating another node.\n    This function can only be used in symbolic Sympy\n    equations.\n\n    Parameters\n    ----------\n    cc : float|ndarray|list\n        Concentration or set of concentrations at which\n        to compute the function.\n    co: float\n        The centre of the sigmoidal logistic curve.\n    k : float\n        The coupling strength/rise function. Here k&gt;0 to\n        achieve an inhibition response.\n\n    '''\n    return 1/(1 + sp.exp(k*(cc - co)))\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_logi_s","title":"<code>f_logi_s(i, j, pp, kk, mu)</code>","text":"<p>Generic logistic function.</p> Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_logi_s(i, j, pp: MatrixSymbol, kk: MatrixSymbol, mu: MatrixSymbol):\n    '''\n    Generic logistic function.\n\n    '''\n    return 1 / (1 + sp.exp(-kk[j,i]*(pp[j,i] - mu[j,i])))\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_interaction_functions/#cellnition.science.network_models.interaction_functions.f_neut_s","title":"<code>f_neut_s(cc, kk, nn)</code>","text":"<p>Calculates a \"neutral\" edge interaction, where there is neither an activation nor inhibition response.</p> Source code in <code>cellnition/science/network_models/interaction_functions.py</code> <pre><code>def f_neut_s(cc: Symbol|Indexed, kk: Symbol|Indexed, nn: Symbol|Indexed):\n    '''\n    Calculates a \"neutral\" edge interaction, where\n    there is neither an activation nor inhibition response.\n    '''\n    return 1\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/","title":"Network Base Class","text":"<p>               Bases: <code>object</code></p> <p>This baseclass allows one to generate a regulatory network as a graph using a procedural construction algorithm, or from user-input edges. It can then perform analysis on the resulting graph to determine cycles, input and output degree distributions, hierarchical attributes, and other characteristics. The baseclass comes equipt with various visualization methods to plot network degree distributions and visualize state heatmaps.</p> <p>Attributes:</p> Name Type Description <code>N_edges</code> <code>int</code> <p>Total number of edges in the regulatory network.</p> <code>N_nodes</code> <code>int</code> <p>Total number of nodes in the regulatory network.</p> <code>edges_list</code> <code>list[tuples]</code> <p>List of the edges as tuples containing node names.</p> <code>nodes_list</code> <code>list</code> <p>List of the nodes by numerical node index.</p> <code>edges_index</code> <code>list</code> <p>List of the edges as edge indices.</p> <code>nodes_index</code> <code>list</code> <p>List of the nodes by node name.</p> <code>GG</code> <code>DiGraph</code> <p>The regulatory network graph as a networkx.DiGraph object.</p> <code>selfloop_edge_inds</code> <code>list</code> <p>The edge indices that are self-loops (i.e. node A --&gt; node A).</p> <code>in_degree_sequence</code> <code>list</code> <p>The in-degree sequence of nodes, arranged according to node index order.</p> <code>out_degree_sequence</code> <code>list</code> <p>The out-degree sequence of nodes, arranged according to node index order.</p> <code>in_dmax</code> <code>int</code> <p>The maximum in-degree of the regulatory network.</p> <code>out_dmax</code> <code>int</code> <p>The maximum out-degree of the regulatory network.</p> <code>node_divergence</code> <code>list</code> <p>The divergence of each node, as the difference between in- and out- degree.</p> <code>in_bins</code> <code>list</code> <p>Bins used to count of how many nodes have each binned in-degree (used to plot degree distribution histograms).</p> <code>in_degree_counts</code> <code>list</code> <p>A count of how many nodes have each in-degree bin (used to plot degree distribution histograms).</p> <code>out_bins</code> <code>list</code> <p>Bins used to count of how many nodes have each binned out-degree (used to plot degree distribution histograms).</p> <code>out_degree_counts</code> <code>list</code> <p>A count of how many nodes have each out-degree bin (used to plot degree distribution histograms).</p> <code>nodes_by_out_degree</code> <code>list</code> <p>Nodes arranged according to the number of outputs (out degree).</p> <code>nodes_by_in_degree</code> <code>list</code> <p>Nodes arranged according to the number of inputs (in degree).</p> <code>graph_cycles</code> <code>list(tuple)</code> <p>Cycles of the regulatory network, as defined by network nodes.</p> <code>N_cycles</code> <code>int</code> <p>Number of simple cycles detected in the regulatory network.</p> <code>nodes_in_cycles</code> <code>list</code> <p>Nodes of the regulatory network that do participate in cycles.</p> <code>nodes_acyclic</code> <code>list</code> <p>Nodes of the regulatory network that do not participate in cycles.</p> <code>hier_node_level</code> <code>list</code> <p>Overall hierarchical node levels of the graph (this is akin to a y-coordinate for each node of the network).</p> <code>dem_coeff</code> <code>float</code> <p>The democracy coefficient parameter, measuring how much the influencers of a graph are influenced themselves.</p> <code>hier_incoherence</code> <code>float</code> <p>The hierarchical incoherence parameter, measuring how much feedback there is in the network, with higher levels indicating more feedback, and lower levels indicating more hierarchy.</p> <code>input_node_inds</code> <code>list[int]</code> <p>These are nodes with zero in degree, which represent the input nodes of the regulatory network.</p> <code>output_node_inds</code> <code>list[int]</code> <p>These are nodes with zero out degree, which represent output nodes and potential effectors.</p> <code>main_nodes</code> <code>list[int]</code> <p>The main nodes of the regulatory network, which are nodes that are neither input nor output nodes (these are the internal nodes).</p> <code>sensor_node_inds</code> <code>list[int]</code> <p>User-defined nodes with NodeType.sensor node types.</p> <code>process_node_inds</code> <code>list[int]</code> <p>User-defined nodes with NodeType.process node types.</p> <code>noninput_node_inds</code> <code>list[int]</code> <p>Nodes of the network excluding the input nodes, but still representing internal and output nodes.</p> <code>factor_node_inds</code> <code>list[int]</code> <p>User-defined nodes with NodeType.factor node types.</p> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>class NetworkABC(object):\n    '''\n    This baseclass allows one to generate a regulatory network as a graph using a\n    procedural construction algorithm, or from user-input edges. It can then perform\n    analysis on the resulting graph to determine cycles, input and output degree distributions,\n    hierarchical attributes, and other characteristics. The baseclass comes equipt with\n    various visualization methods to plot network degree distributions and visualize state heatmaps.\n\n    Attributes\n    ----------\n    N_edges : int\n        Total number of edges in the regulatory network.\n    N_nodes : int\n        Total number of nodes in the regulatory network.\n    edges_list : list[tuples]\n        List of the edges as tuples containing node names.\n    nodes_list : list\n        List of the nodes by numerical node index.\n    edges_index : list\n        List of the edges as edge indices.\n    nodes_index : list\n        List of the nodes by node name.\n    GG : networkx.DiGraph\n        The regulatory network graph as a networkx.DiGraph object.\n    selfloop_edge_inds : list\n        The edge indices that are self-loops (i.e. node A --&gt; node A).\n    in_degree_sequence : list\n        The in-degree sequence of nodes, arranged according to node index order.\n    out_degree_sequence : list\n        The out-degree sequence of nodes, arranged according to node index order.\n    in_dmax : int\n        The maximum in-degree of the regulatory network.\n    out_dmax : int\n        The maximum out-degree of the regulatory network.\n    node_divergence : list\n        The divergence of each node, as the difference between in- and out- degree.\n    in_bins : list\n        Bins used to count of how many nodes have each binned in-degree (used to plot degree distribution histograms).\n    in_degree_counts : list\n        A count of how many nodes have each in-degree bin (used to plot degree distribution histograms).\n    out_bins : list\n        Bins used to count of how many nodes have each binned out-degree (used to plot degree distribution histograms).\n    out_degree_counts : list\n        A count of how many nodes have each out-degree bin (used to plot degree distribution histograms).\n    nodes_by_out_degree : list\n        Nodes arranged according to the number of outputs (out degree).\n    nodes_by_in_degree : list\n        Nodes arranged according to the number of inputs (in degree).\n    graph_cycles : list(tuple)\n        Cycles of the regulatory network, as defined by network nodes.\n    N_cycles : int\n        Number of simple cycles detected in the regulatory network.\n    nodes_in_cycles : list\n        Nodes of the regulatory network that do participate in cycles.\n    nodes_acyclic : list\n        Nodes of the regulatory network that do not participate in cycles.\n    hier_node_level : list\n        Overall hierarchical node levels of the graph (this is akin to a y-coordinate for each node of the network).\n    dem_coeff : float\n        The democracy coefficient parameter, measuring how much the influencers of a graph are influenced\n        themselves.\n    hier_incoherence : float\n        The hierarchical incoherence parameter, measuring how much feedback there is in the network, with higher\n        levels indicating more feedback, and lower levels indicating more hierarchy.\n    input_node_inds : list[int]\n        These are nodes with zero in degree, which represent the input nodes of the regulatory network.\n    output_node_inds : list[int]\n        These are nodes with zero out degree, which represent output nodes and potential effectors.\n    main_nodes : list[int]\n        The main nodes of the regulatory network, which are nodes that are neither input nor output nodes\n        (these are the internal nodes).\n    sensor_node_inds : list[int]\n        User-defined nodes with NodeType.sensor node types.\n    process_node_inds : list[int]\n        User-defined nodes with NodeType.process node types.\n    noninput_node_inds : list[int]\n        Nodes of the network excluding the input nodes, but still representing internal and output nodes.\n    factor_node_inds : list[int]\n        User-defined nodes with NodeType.factor node types.\n\n    '''\n\n    def __init__(self) -&gt; None:\n        '''\n        Initialize the class to begin building and characterizing a regulatory network graph.\n        '''\n        pass\n\n\n    def build_network_from_edges(self, edges: list[tuple]):\n        '''\n        Use a list of tuples defining directed edges between nodes to\n        build a regulatory network.\n\n        Parameters\n        ----------\n        edges : list[tuple]\n            List with tuples defining each directed edge in the regulatory\n            network as passing from the first to second node in the tuple.\n\n        '''\n        self._graph_type = GraphType.user\n        self.edges_list = edges\n        self.GG = nx.DiGraph(self.edges_list)\n        self.N_edges = len(self.edges_list)\n        self.nodes_list = sorted(self.GG.nodes())\n        self.N_nodes = len(self.nodes_list)  # re-assign the node number in case specification was wrong\n\n        self._make_node_edge_indices()\n\n    def randomly_generate_special_network(self,\n                                          N_nodes: int,\n                                          b_param: float=0.15,\n                                          g_param: float=0.8,\n                                          delta_in: float=0.0,\n                                          delta_out: float=0.0,\n                                          p_edge: float=0.5,\n                                          graph_type: GraphType = GraphType.scale_free\n                                          ):\n        '''\n        Procedurally generate a network with a scale-free or binomial (random) degree distribution.\n\n        Parameters\n        ----------\n        N_nodes : int\n            The number of nodes to build the network (only used in randomly built networks, otherwise the number of\n            nodes is calculated from the number of unique nodes supplied in the edges list).\n        graph_type : GraphType = GraphType.scale_free\n            The type of graph to generate in randomly-constructed networks.\n        b_param : float = 0.20\n            For scale-free randomly-constructed networks, this determines the amount of interconnectivity between\n            the in and out degree distributions, and in practical terms, increases the number of cycles in the graph.\n            Note that 1 - beta - gamma must be greater than 0.0.\n        g_param : float=0.75\n            For scale-free randomly-constructed networks, this determines the emphasis on the network's\n            out degree distribution, and in practical terms, increases the scale-free character of the out-distribution\n            of the graph. Note that 1 - beta - gamma must be greater than 0.0.\n        delta_in : float=0.0\n            A parameter that increases the complexity of the network core, leading to more nodes being involved in\n            cycles.\n        delta_out : float = 0.0\n            A parameter that increases the complexity of the network core, leading to more nodes being involved in\n            cycles.\n        p_edge : float=0.2\n            For randomly constructed binomial-type networks, this parameter determines the probability of forming\n            an edge. As p_edge increases, the number of network edges increases dramatically.\n\n        '''\n        # Save all the construction parameters to file:\n        self.N_nodes = N_nodes\n        self._beta = b_param\n        self._gamma = g_param\n        self._delta_in = delta_in\n        self._delta_out = delta_out\n        self._p_edge = p_edge\n        self._graph_type = graph_type\n\n        if graph_type is GraphType.scale_free:\n            # generate a scale-free network with the supplied parameters...\n            # The input scale-free probability is given as 1.0 minus beta and gamma, as all\n            # three parameters must be constrained to add to 1.0:\n            alpha = 1.0 - b_param - g_param\n\n            # Generate a scale free graph with the settings:\n            GGo = nx.scale_free_graph(self.N_nodes,\n                                      alpha=alpha,\n                                      beta=b_param,\n                                      gamma=g_param,\n                                      delta_in=delta_in,\n                                      delta_out=delta_out,\n                                      seed=None,\n                                      initial_graph=None)\n\n        elif graph_type is GraphType.random:\n            # generate a random Erdos-Renyi network\n            GGo = nx.erdos_renyi_graph(self.N_nodes,\n                                       p_edge,\n                                       seed=None,\n                                       directed=True)\n\n        else:\n            raise Exception(\"Only scale-free and random (binomial) networks supported.\")\n\n        # obtain the unique edges only:\n        self.edges_list = list(set(GGo.edges()))\n        self.N_edges = len(self.edges_list)\n\n        # As the scale_free_graph function can return duplicate edges, get rid of these\n        # by re-defining the graph with the unique edges only:\n        GG = nx.DiGraph(self.edges_list)\n\n        self.nodes_list = np.arange(self.N_nodes).tolist()\n        self.GG = GG\n        self.edges_index = self.edges_list\n        self.nodes_index = self.nodes_list\n\n        self._make_node_edge_indices()\n\n    #----Graph Building &amp; Characterizing Methods ------\n    def _make_node_edge_indices(self):\n        '''\n        Especially important for the case where node names are strings,\n        this method creates numerical (i.e. integer) indices for the nodes and\n        stores them in a nodes_index. It does the same for nodes in edges,\n        storing them in an edges_index object.\n\n        '''\n        # For this case the user may provide string names for\n        # nodes, so we need to make numerical node and edge listings:\n        self.nodes_index = []\n        for nde_i, nn in enumerate(self.nodes_list):\n            self.nodes_index.append(nde_i)\n\n        self.edges_index = []\n        for ei, (nni, nnj) in enumerate(self.edges_list):\n            nde_i = self.nodes_list.index(nni)\n            nde_j = self.nodes_list.index(nnj)\n            self.edges_index.append((nde_i, nde_j))\n        # self.nodes_list = np.arange(self.N_nodes)\n\n    def characterize_graph(self, count_cycles: bool=True, cycle_length_bound: int|None=None):\n        '''\n        Perform a number of graph-theory style characterizations on the network to determine\n        cycle number, analyze in- and out- degree distribution, and analyze hierarchy. Hierarchical\n        structure analysis was from the work of Moutsinas, G. et al. Scientific Reports 11 (2021).\n\n        Parameters\n        ----------\n        count_cycles : bool, default: True\n            Do you wish to perform a cycle count of the network (True)? Some regulatory networks have\n            very high numbers of cycles and in this case the cycle count can consume all the memory and\n            should therefore be disabled.\n        cycle_length_bound : int|None, default: None\n            Specify an upper bound for the length of a cycle in a network in terms of node number (e.g. 12).\n            For networks with large cycle numbers, specifying an upper bound can prevent the extreme counts\n            that would otherwise be produced.\n\n        '''\n\n        # print('Degree sequences...')\n        # Indices of edges with selfloops:\n        self.selfloop_edge_inds = [self.edges_list.index(ei)\n                                   for ei in list(nx.selfloop_edges(self.GG))]\n\n        # Degree analysis:\n        self.in_degree_sequence = [deg_i for nde_i, deg_i in\n                                   self.GG.in_degree(self.nodes_list)] # aligns with node order\n\n        self.in_dmax = np.max(self.in_degree_sequence)\n\n\n        self.out_degree_sequence = [deg_i for nde_i, deg_i in\n                                    self.GG.out_degree(self.nodes_list)]  # aligns with node order\n\n        # The outward flow of interaction at each node of the graph:\n        self.node_divergence = np.asarray(self.out_degree_sequence) - np.asarray(self.in_degree_sequence)\n\n        self.out_dmax = np.max(self.out_degree_sequence)\n        self.in_dmax = np.max(self.in_degree_sequence)\n\n        self.in_bins, self.in_degree_counts = np.unique(self.in_degree_sequence,\n                                                        return_counts=True)\n        self.out_bins, self.out_degree_counts = np.unique(self.out_degree_sequence,\n                                                          return_counts=True)\n\n        # Nodes sorted by number of out-degree edges:\n        self.nodes_by_out_degree = np.flip(np.argsort(self.out_degree_sequence))\n\n        self.nodes_by_in_degree = np.flip(np.argsort(self.in_degree_sequence))\n\n        self.root_hub = self.nodes_by_out_degree[0]\n        self.leaf_hub = self.nodes_by_out_degree[-1]\n\n        if count_cycles:\n            # print('Cycle Number...')\n            # Number of cycles:\n            self.graph_cycles = sorted(nx.simple_cycles(self.GG, length_bound=cycle_length_bound))\n            self.N_cycles = len(self.graph_cycles)\n\n            # Determine the nodes in the cycles:\n            nodes_in_cycles = set()\n            for nde_lst in self.graph_cycles:\n                for nde_ni in nde_lst:\n                    nde_i = self.nodes_list.index(nde_ni)\n                    nodes_in_cycles.add(nde_i)\n\n            self.nodes_in_cycles = list(nodes_in_cycles)\n            self.nodes_acyclic = np.setdiff1d(self.nodes_index, nodes_in_cycles)\n\n        # print('Graph hierarchical structure...')\n        # Graph structure characterization (from the amazing paper of Moutsinas, G. et al. Scientific Reports 11 (2021))\n        a_out = list(self.GG.adjacency())\n\n        # Adjacency matrix (outward connection directed)\n        self.A_out = np.zeros((self.N_nodes, self.N_nodes))\n        for nde_ni, nde_j_dict in a_out:\n            nde_i = self.nodes_list.index(nde_ni) # get the index in case nodes are names\n            for nde_nj, _ in nde_j_dict.items():\n                nde_j = self.nodes_list.index(nde_nj) # get the index in case nodes are names\n                self.A_out[nde_i, nde_j] += 1\n\n        # Diagonalized in and out degree sequences for the nodes:\n        D_in = np.diag(self.in_degree_sequence)\n        D_out = np.diag(self.out_degree_sequence)\n\n        if D_out.shape == self.A_out.shape:\n            # Graph Laplacians for out and in distributions:\n            L_out = D_out - self.A_out\n            L_in = D_in - self.A_out\n\n            # Moore-Penrose inverse of Graph Laplacians:\n            L_in_inv = np.linalg.pinv(L_in.T)\n            L_out_inv = np.linalg.pinv(L_out)\n\n            # Grading of hierarchical level of nodes:\n            # fwd hierachical levels grade vertices based on distance from source subgraphs\n            self.fwd_hier_node_level = L_in_inv.dot(self.in_degree_sequence)\n            # rev hierarchical levels grade vertices based on distance from sink subgraphs\n            self.rev_hier_node_level = L_out_inv.dot(self.out_degree_sequence)\n            # overall hierarchical levels of the graph (this is akin to a y-coordinate for each node of the network):\n            self.hier_node_level = (1 / 2) * (self.fwd_hier_node_level - self.rev_hier_node_level)\n\n            # Next, define a difference matrix for the network -- this calculates the difference between node i and j\n            # as an edge parameter when it is dotted with a parameter defined on nodes:\n            self.D_diff = np.zeros((self.N_edges, self.N_nodes))\n            for ei, (nde_i, nde_j) in enumerate(self.edges_index):\n                self.D_diff[ei, nde_i] = 1\n                self.D_diff[ei, nde_j] = -1\n\n            #Next calculate the forward and backward hierarchical differences:\n            self.fwd_hier_diff = self.D_diff.dot(self.fwd_hier_node_level)\n            self.rev_hier_diff = self.D_diff.dot(self.rev_hier_node_level)\n\n            #The democracy coefficient parameter (measures how much the influencers of a graph are influenced\n            #themselves):\n            self.dem_coeff = 1 - np.mean(self.fwd_hier_diff)\n            self.dem_coeff_rev = 1 - np.mean(self.rev_hier_diff)\n\n            # I don't think this is calculated correctly...\n            self.influence_centrality = (1 -\n                                         self.D_diff.T.dot(self.fwd_hier_diff)/(1 +\n                                                          np.asarray(self.in_degree_sequence))\n                                         )\n\n            # And the hierarchical incoherence parameter (measures how much feedback there is):\n            self.hier_incoherence = np.var(self.fwd_hier_diff)\n            self.hier_incoherence_rev = np.var(self.rev_hier_diff)\n\n            # A graph with high democracy coefficient and high incoherence has all verts with approximately the same\n            # hierarchical level. The graph is influenced by a high percentage of vertices. In a graph with low democracy\n            # coefficient and low incoherence, the graph is controlled by small percentage of vertices (maximally\n            # hierarchical at zero demo coeff and zero incoherence).\n\n        else:\n            self.hier_node_level = np.zeros(self.N_nodes)\n            self.hier_incoherence = 0.0\n            self.dem_coeff = 0.0\n\n    def get_paths_matrix(self) -&gt; ndarray:\n        '''\n        Compute a matrix showing the number of paths from starting node to end node. Note that this\n        matrix can be extraordinarily large in a complicated graph such as most binomial networks.\n\n        Returns\n        -------\n        ndarray\n            The paths matrix, which specifies the number of paths between one node index as row index and another\n            node index as the column index.\n\n        '''\n\n\n        # What we want to show is that the nodes with the highest degree have the most connectivity to nodes in the network:\n        # mn_i = 10 # index of the master node, organized according to nodes_by_out_degree\n        paths_matrix = []\n        for mn_i in range(len(self.nodes_index)):\n            number_paths_to_i = []\n            for i in range(len(self.nodes_index)):\n                # print(f'paths between {mn_i} and {i}')\n                try:\n                    paths_i = sorted(nx.shortest_simple_paths(self.GG,\n                                                              self.nodes_by_out_degree[mn_i],\n                                                              self.nodes_by_out_degree[i]),\n                                     reverse=True)\n                except:\n                    paths_i = []\n\n                num_paths_i = len(paths_i)\n                number_paths_to_i.append(num_paths_i)\n\n            paths_matrix.append(number_paths_to_i)\n\n        self.paths_matrix = np.asarray(paths_matrix)\n\n        return self.paths_matrix\n\n    def get_edge_types(self, p_acti: float=0.5, set_selfloops_acti: bool=True) -&gt; list:\n        '''\n        Automatically generate a list of EdgeType for use in model building.\n        The edge type specifies whether the edge is an activating or inhibiting\n        relationship between the nodes. This routine randomly chooses a set of\n        activating and inhibiting edge types for a model.\n\n        Parameters\n        ----------\n        p_acti : float, default: 0.5\n            The probability of an edge type being an activator. Note that this value\n            must be less than 1.0, and that the probability of an edge being an\n            inhibitor becomes 1.0 - p_acti.\n\n        set_selfloops_acti : bool, default: True\n            Work shows that, in general, self-inhibition does not generate models with\n            multistable states. Therefore, this edge-type assignment routine allows one to\n            automatically set all self-loops to be activation interactions.\n\n        Returns\n        -------\n        list\n            A list containing an EdgeType enum for every edge in the network.\n\n        '''\n\n        p_inhi = 1.0 - p_acti\n\n        edge_types_o = [EdgeType.A, EdgeType.I]\n        edge_prob = [p_acti, p_inhi]\n        edge_types = np.random.choice(edge_types_o, self.N_edges, p=edge_prob)\n\n        if set_selfloops_acti: # if self-loops of the network are forced to be activators:\n            edge_types[self.selfloop_edge_inds] = EdgeType.A\n\n        return edge_types.tolist()\n\n    def set_edge_types(self, edge_types: list|ndarray):\n        '''\n        Assign a list EdgeType to edges of the graph.\n\n        Parameters\n        ----------\n        edge_types : list|ndarray\n            A list of edge type enumerations; one for each edge of the network.\n        '''\n        self.edge_types = edge_types\n\n        # assign the edge types to the graph in case we decide to save the network:\n        edge_attr_dict = {}\n        for ei, et in zip(self.edges_list, edge_types):\n            edge_attr_dict[ei] = {\"edge_type\": et.name}\n\n        nx.set_edge_attributes(self.GG, edge_attr_dict)\n\n    def set_node_types(self, node_type_dict: dict|None = None, pure_gene_edges_only: bool = False):\n        '''\n        Assign a dictionary of NodeType to nodes of the graph.\n\n        Parameters\n        ----------\n        node_type_dict : dict|None, default: None\n            A list of node type enumerations for each node of the network.\n        pure_gene_edges_only : bool, default: False\n            Classify multiple non-process NodeType as \"genes\" (True) or only NodeType.gene (False).\n        '''\n\n        # Now that indices are set, give nodes a type attribute and classify node inds.\n        # First, initialize a dictionary to collect all node indices by their node type:\n        self.node_type_inds = {}\n        for nt in NodeType:\n            self.node_type_inds[nt.name] = []\n\n        # Next, set all nodes to the gene type by default:\n        node_types = [NodeType.gene for i in self.nodes_index]\n\n        # If there is a supplied node dictionary, go through it and\n        # override the default gene type with the user-specified type:\n        if node_type_dict is not None:\n            for ntag, ntype in node_type_dict.items():\n                for nde_i, nde_n in enumerate(self.nodes_list):\n                    if type(nde_n) is str:\n                        if nde_n.startswith(ntag):\n                            node_types[nde_i] = ntype\n                    else:\n                        if nde_n == ntag:\n                            node_types[nde_i] = ntype\n\n        # Set node types to the graph:\n        self.node_types = node_types\n        # Set node type as graph node attribute:\n        node_attr_dict = {}\n        for nde_i, nde_t in zip(self.nodes_list, node_types):\n            node_attr_dict[nde_i] = {\"node_type\": nde_t.name}\n\n        nx.set_node_attributes(self.GG, node_attr_dict)\n\n        # Collect node indices by their type:\n        for nde_i, nde_t in enumerate(self.node_types):\n            self.node_type_inds[nde_t.name].append(nde_i)\n\n        # Next, we need to distinguish edges based on their node type\n        # to separate out some node type interactions from the regular\n        # GRN-type interactions:\n        if pure_gene_edges_only:  # if the user wants to consider only gene type nodes\n            type_tags = [NodeType.gene.name]\n        else:  # Otherwise include all nodes that can form regular interaction edges:\n            type_tags = [NodeType.gene.name,\n                         NodeType.signal.name,\n                         NodeType.sensor.name,\n                         NodeType.effector.name]\n\n        self.regular_node_inds = []\n        for tt in type_tags:\n            self.regular_node_inds.extend(self.node_type_inds[tt])\n\n        # aliases for convenience:\n        # combine signals with factors as they have a similar 'setability' condition\n        # from the outside\n        # self.input_node_inds = self.node_type_inds[NodeType.signal.name] + self.node_type_inds[NodeType.factor.name]\n        self.input_node_inds = ((np.asarray(self.in_degree_sequence) == 0).nonzero()[0]).tolist()\n\n        self.output_node_inds = ((np.asarray(self.out_degree_sequence) == 0).nonzero()[0]).tolist()\n        self.sensor_node_inds = self.node_type_inds[NodeType.sensor.name]\n        self.process_node_inds = self.node_type_inds[NodeType.process.name]\n\n        if len(self.node_type_inds[NodeType.effector.name]) == 0:\n            self.effector_node_inds = ((np.asarray(self.out_degree_sequence) == 0).nonzero()[0]).tolist()\n        else:\n            self.effector_node_inds = self.node_type_inds[NodeType.effector.name]\n\n        self.noninput_node_inds = np.setdiff1d(self.nodes_index, self.input_node_inds).tolist()\n\n        self.factor_node_inds = self.node_type_inds[NodeType.factor.name]\n\n        # also determine the \"main nodes\", which are nodes that are not input and also are not effectors:\n        self.main_nodes = np.setdiff1d(self.noninput_node_inds, self.effector_node_inds).tolist()\n\n    def edges_from_path(self, path_nodes: list|ndarray) -&gt; list:\n        '''\n        If specifying a path in terms of a set of nodes, this method\n        returns the set of edges corresponding to the path.\n\n        Parameters\n        ----------\n        path_nodes : list\n            A list of nodes in the network over which the path is specified.\n\n        Returns\n        -------\n        list\n            The list of edges corresponding to the path.\n\n        '''\n        path_edges = []\n        for i in range(len(path_nodes)):\n            if i != len(path_nodes) - 1:\n                ei = (path_nodes[i], path_nodes[i + 1])\n                path_edges.append(ei)\n\n        return path_edges\n\n    def save_network(self, filename: str):\n        '''\n        Write a network, including edge types, to a saved file.\n\n        Parameters\n        ----------\n        filename : str\n            The full directory and filename to write the graph file to\n            as a gml format graph.\n        '''\n        nx.write_gml(self.GG, filename)\n\n    def save_network_image(self, save_filename: str, use_dot_layout: bool=False):\n        '''\n        Uses pygraphviz to create a basic plot of the network model.\n\n        Parameters\n        ----------\n        save_filename : str\n            The full directory and filename to write the graph image file to.\n            If the filename ends with '.png' the image will be a raster image, if it ends\n            with '.svg' it will be a vector graphics file.\n        use_dot_layout : bool, default: false\n            Use the 'dot' layout to build the graph.\n\n        '''\n        G_plt = pgv.AGraph(strict=False,\n                           splines=True,\n                           directed=True,\n                           randkdir='TB',\n                           nodesep=0.1,\n                           ranksep=0.3,\n                           dpi=300)\n\n        for nde_i in self.nodes_list:\n            G_plt.add_node(nde_i,\n                           style='filled',\n                           fillcolor='LightCyan',\n                           color='Black',\n                           shape='ellipse',\n                           fontcolor='Black',\n                           # fontname=net_font_name,\n                           fontsize=12)\n\n        for (ei, ej), etype in zip(self.edges_list, self.edge_types):\n            if etype is EdgeType.A:\n                G_plt.add_edge(ei, ej, arrowhead='dot', color='blue', penwidth=2.0)\n            elif etype is EdgeType.I:\n                G_plt.add_edge(ei, ej, arrowhead='tee', color='red', penwidth=2.0)\n            else:\n                G_plt.add_edge(ei, ej, arrowhead='normal', color='black', penwidth=2.0)\n\n        if use_dot_layout:\n            G_plt.layout(prog=\"dot\")\n        else:\n            G_plt.layout()\n\n        G_plt.draw(save_filename)\n\n    def plot_degree_distributions(self) -&gt; tuple[object, object]:\n        '''\n        Generate a plot of the in- and out- degree distributions of the\n        network as histograms. Requires self.characterize_graph() to have\n        been run previously.\n\n        Returns\n        -------\n        fig : matplotlib.figure\n        ax : matplotlib.axes\n\n        '''\n        fig, ax = plt.subplots(1, 2, figsize=(10, 4), sharey=True)\n        ax[0].bar(self.in_bins, self.in_degree_counts)\n        ax[0].set_xlabel('Node degree')\n        ax[0].set_ylabel('Counts')\n        ax[0].set_title('In-Degree Distribution')\n        ax[1].bar(self.out_bins, self.out_degree_counts)\n        ax[1].set_xlabel('Node degree')\n        # ax[1].set_ylabel('Counts')\n        ax[1].set_title('Out-Degree Distribution')\n\n        return fig, ax\n\n    def plot_sols_array(self,\n                        solsM: ndarray,\n                        gene_inds: list|ndarray|None=None,\n                        figsave: str | None = None,\n                        cmap: str | None =None,\n                        save_format: str='png',\n                        figsize: tuple=(10,10)) -&gt; tuple[object, object]:\n        '''\n        Create and save a heatmap image representing a matrix of states for the\n        regulatory network.\n\n        Parameters\n        ----------\n        solsM : ndarray\n            The matrix of regulatory network states, with each state being a coloumn\n            of the matrix and each row representing the expression level of a node in\n            the network.\n        gene_inds : list|ndarray|None, default: None\n            A subset of the total nodes of the network that are to be displayed in the\n            visualized heatmap.\n        figsave : str|None, default: None\n            The full directory and filename to write the image file to. If None, no image\n            will be save to disk.\n        cmap : str|None, default: None\n            The matplotlib colormap to use for the image.\n        save_format : str, default: 'png'\n            The file format to save the image in ('svg' or 'png').\n        figsize : tuple, default: (10,10)\n            The size of the figure.\n\n        Returns\n        -------\n        fig : matplotlib.figure\n        ax : matplotlib.axes\n\n        '''\n\n        if cmap is None:\n            cmap = 'magma'\n\n        state_labels = [f'State {i}' for i in range(solsM.shape[1])]\n\n        if gene_inds is None:\n            gene_labels = np.asarray(self.nodes_list)\n\n        else:\n            gene_labels = np.asarray(self.nodes_list)[gene_inds]\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        if gene_inds is None:\n            im = ax.imshow(solsM, cmap=cmap)\n        else:\n            im = ax.imshow(solsM[gene_inds, :], cmap=cmap)\n\n        ax.set_xticks(np.arange(len(state_labels)), labels=state_labels)\n        ax.set_yticks(np.arange(len(gene_labels)), labels=gene_labels)\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n                 rotation_mode=\"anchor\")\n        fig.colorbar(im, label='Expression Level')\n\n        if figsave is not None:\n            plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n        return fig, ax\n\n    def plot_pixel_matrix(self,\n                          solsM: ndarray,\n                          x_labels: list | ndarray|None,\n                          y_labels: list|ndarray|None,\n                          figsave: str | None = None,\n                          cmap: str | None = None,\n                          cbar_label: str = '',\n                          figsize: tuple = (10, 10),\n                          fontsize: int=16) -&gt; tuple[object, object]:\n        '''\n        Plot a matrix of values as a heatmap.\n\n        Parameters\n        ----------\n        solsM : ndarray\n            The matrix of values to plot as a heatmap.\n        x_labels : list|ndarray|None\n            Labels to apply to each column of the solsM matrix, along the horizontal axis.\n        y_labels : list|ndarray|None\n            Labels to apply to each row of the solsM matrix, along the vertical axis.\n        figsave : str|None, default: None\n            The full directory and filename to write the image file to. If None, no image\n            will be save to disk. Only 'png' images can be exported.\n        cmap : str|None, default: None\n            The matplotlib colormap to use for the image.\n        cbar_label : str, default: ''\n            The text label to write along the image colorbar.\n        figsize : tuple, default: (10,10)\n            The size of the figure.\n\n        Returns\n        -------\n        fig : matplotlib.figure\n        ax : matplotlib.axes\n\n        '''\n\n        if cmap is None:\n            cmap = 'magma'\n\n        fig, ax = plt.subplots(figsize=figsize)\n        im = ax.imshow(solsM, cmap=cmap)\n        ax.set_xticks(np.arange(solsM.shape[1]), labels=x_labels, font='DejaVu Serif', fontsize=fontsize)\n        ax.set_yticks(np.arange(solsM.shape[0]), labels=y_labels, fontsize=fontsize)\n        plt.setp(ax.get_xticklabels(), rotation=0, ha=\"right\",\n                 rotation_mode=\"anchor\")\n        fig.colorbar(im, label=cbar_label)\n\n        if figsave is not None:\n            plt.savefig(figsave, dpi=300, transparent=True, format='png')\n\n        return fig, ax\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the class to begin building and characterizing a regulatory network graph.</p> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def __init__(self) -&gt; None:\n    '''\n    Initialize the class to begin building and characterizing a regulatory network graph.\n    '''\n    pass\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.build_network_from_edges","title":"<code>build_network_from_edges(edges)</code>","text":"<p>Use a list of tuples defining directed edges between nodes to build a regulatory network.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>list[tuple]</code> <p>List with tuples defining each directed edge in the regulatory network as passing from the first to second node in the tuple.</p> required Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def build_network_from_edges(self, edges: list[tuple]):\n    '''\n    Use a list of tuples defining directed edges between nodes to\n    build a regulatory network.\n\n    Parameters\n    ----------\n    edges : list[tuple]\n        List with tuples defining each directed edge in the regulatory\n        network as passing from the first to second node in the tuple.\n\n    '''\n    self._graph_type = GraphType.user\n    self.edges_list = edges\n    self.GG = nx.DiGraph(self.edges_list)\n    self.N_edges = len(self.edges_list)\n    self.nodes_list = sorted(self.GG.nodes())\n    self.N_nodes = len(self.nodes_list)  # re-assign the node number in case specification was wrong\n\n    self._make_node_edge_indices()\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.characterize_graph","title":"<code>characterize_graph(count_cycles=True, cycle_length_bound=None)</code>","text":"<p>Perform a number of graph-theory style characterizations on the network to determine cycle number, analyze in- and out- degree distribution, and analyze hierarchy. Hierarchical structure analysis was from the work of Moutsinas, G. et al. Scientific Reports 11 (2021).</p> <p>Parameters:</p> Name Type Description Default <code>count_cycles</code> <code>bool</code> <p>Do you wish to perform a cycle count of the network (True)? Some regulatory networks have very high numbers of cycles and in this case the cycle count can consume all the memory and should therefore be disabled.</p> <code>True</code> <code>cycle_length_bound</code> <code>int | None</code> <p>Specify an upper bound for the length of a cycle in a network in terms of node number (e.g. 12). For networks with large cycle numbers, specifying an upper bound can prevent the extreme counts that would otherwise be produced.</p> <code>None</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def characterize_graph(self, count_cycles: bool=True, cycle_length_bound: int|None=None):\n    '''\n    Perform a number of graph-theory style characterizations on the network to determine\n    cycle number, analyze in- and out- degree distribution, and analyze hierarchy. Hierarchical\n    structure analysis was from the work of Moutsinas, G. et al. Scientific Reports 11 (2021).\n\n    Parameters\n    ----------\n    count_cycles : bool, default: True\n        Do you wish to perform a cycle count of the network (True)? Some regulatory networks have\n        very high numbers of cycles and in this case the cycle count can consume all the memory and\n        should therefore be disabled.\n    cycle_length_bound : int|None, default: None\n        Specify an upper bound for the length of a cycle in a network in terms of node number (e.g. 12).\n        For networks with large cycle numbers, specifying an upper bound can prevent the extreme counts\n        that would otherwise be produced.\n\n    '''\n\n    # print('Degree sequences...')\n    # Indices of edges with selfloops:\n    self.selfloop_edge_inds = [self.edges_list.index(ei)\n                               for ei in list(nx.selfloop_edges(self.GG))]\n\n    # Degree analysis:\n    self.in_degree_sequence = [deg_i for nde_i, deg_i in\n                               self.GG.in_degree(self.nodes_list)] # aligns with node order\n\n    self.in_dmax = np.max(self.in_degree_sequence)\n\n\n    self.out_degree_sequence = [deg_i for nde_i, deg_i in\n                                self.GG.out_degree(self.nodes_list)]  # aligns with node order\n\n    # The outward flow of interaction at each node of the graph:\n    self.node_divergence = np.asarray(self.out_degree_sequence) - np.asarray(self.in_degree_sequence)\n\n    self.out_dmax = np.max(self.out_degree_sequence)\n    self.in_dmax = np.max(self.in_degree_sequence)\n\n    self.in_bins, self.in_degree_counts = np.unique(self.in_degree_sequence,\n                                                    return_counts=True)\n    self.out_bins, self.out_degree_counts = np.unique(self.out_degree_sequence,\n                                                      return_counts=True)\n\n    # Nodes sorted by number of out-degree edges:\n    self.nodes_by_out_degree = np.flip(np.argsort(self.out_degree_sequence))\n\n    self.nodes_by_in_degree = np.flip(np.argsort(self.in_degree_sequence))\n\n    self.root_hub = self.nodes_by_out_degree[0]\n    self.leaf_hub = self.nodes_by_out_degree[-1]\n\n    if count_cycles:\n        # print('Cycle Number...')\n        # Number of cycles:\n        self.graph_cycles = sorted(nx.simple_cycles(self.GG, length_bound=cycle_length_bound))\n        self.N_cycles = len(self.graph_cycles)\n\n        # Determine the nodes in the cycles:\n        nodes_in_cycles = set()\n        for nde_lst in self.graph_cycles:\n            for nde_ni in nde_lst:\n                nde_i = self.nodes_list.index(nde_ni)\n                nodes_in_cycles.add(nde_i)\n\n        self.nodes_in_cycles = list(nodes_in_cycles)\n        self.nodes_acyclic = np.setdiff1d(self.nodes_index, nodes_in_cycles)\n\n    # print('Graph hierarchical structure...')\n    # Graph structure characterization (from the amazing paper of Moutsinas, G. et al. Scientific Reports 11 (2021))\n    a_out = list(self.GG.adjacency())\n\n    # Adjacency matrix (outward connection directed)\n    self.A_out = np.zeros((self.N_nodes, self.N_nodes))\n    for nde_ni, nde_j_dict in a_out:\n        nde_i = self.nodes_list.index(nde_ni) # get the index in case nodes are names\n        for nde_nj, _ in nde_j_dict.items():\n            nde_j = self.nodes_list.index(nde_nj) # get the index in case nodes are names\n            self.A_out[nde_i, nde_j] += 1\n\n    # Diagonalized in and out degree sequences for the nodes:\n    D_in = np.diag(self.in_degree_sequence)\n    D_out = np.diag(self.out_degree_sequence)\n\n    if D_out.shape == self.A_out.shape:\n        # Graph Laplacians for out and in distributions:\n        L_out = D_out - self.A_out\n        L_in = D_in - self.A_out\n\n        # Moore-Penrose inverse of Graph Laplacians:\n        L_in_inv = np.linalg.pinv(L_in.T)\n        L_out_inv = np.linalg.pinv(L_out)\n\n        # Grading of hierarchical level of nodes:\n        # fwd hierachical levels grade vertices based on distance from source subgraphs\n        self.fwd_hier_node_level = L_in_inv.dot(self.in_degree_sequence)\n        # rev hierarchical levels grade vertices based on distance from sink subgraphs\n        self.rev_hier_node_level = L_out_inv.dot(self.out_degree_sequence)\n        # overall hierarchical levels of the graph (this is akin to a y-coordinate for each node of the network):\n        self.hier_node_level = (1 / 2) * (self.fwd_hier_node_level - self.rev_hier_node_level)\n\n        # Next, define a difference matrix for the network -- this calculates the difference between node i and j\n        # as an edge parameter when it is dotted with a parameter defined on nodes:\n        self.D_diff = np.zeros((self.N_edges, self.N_nodes))\n        for ei, (nde_i, nde_j) in enumerate(self.edges_index):\n            self.D_diff[ei, nde_i] = 1\n            self.D_diff[ei, nde_j] = -1\n\n        #Next calculate the forward and backward hierarchical differences:\n        self.fwd_hier_diff = self.D_diff.dot(self.fwd_hier_node_level)\n        self.rev_hier_diff = self.D_diff.dot(self.rev_hier_node_level)\n\n        #The democracy coefficient parameter (measures how much the influencers of a graph are influenced\n        #themselves):\n        self.dem_coeff = 1 - np.mean(self.fwd_hier_diff)\n        self.dem_coeff_rev = 1 - np.mean(self.rev_hier_diff)\n\n        # I don't think this is calculated correctly...\n        self.influence_centrality = (1 -\n                                     self.D_diff.T.dot(self.fwd_hier_diff)/(1 +\n                                                      np.asarray(self.in_degree_sequence))\n                                     )\n\n        # And the hierarchical incoherence parameter (measures how much feedback there is):\n        self.hier_incoherence = np.var(self.fwd_hier_diff)\n        self.hier_incoherence_rev = np.var(self.rev_hier_diff)\n\n        # A graph with high democracy coefficient and high incoherence has all verts with approximately the same\n        # hierarchical level. The graph is influenced by a high percentage of vertices. In a graph with low democracy\n        # coefficient and low incoherence, the graph is controlled by small percentage of vertices (maximally\n        # hierarchical at zero demo coeff and zero incoherence).\n\n    else:\n        self.hier_node_level = np.zeros(self.N_nodes)\n        self.hier_incoherence = 0.0\n        self.dem_coeff = 0.0\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.edges_from_path","title":"<code>edges_from_path(path_nodes)</code>","text":"<p>If specifying a path in terms of a set of nodes, this method returns the set of edges corresponding to the path.</p> <p>Parameters:</p> Name Type Description Default <code>path_nodes</code> <code>list</code> <p>A list of nodes in the network over which the path is specified.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of edges corresponding to the path.</p> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def edges_from_path(self, path_nodes: list|ndarray) -&gt; list:\n    '''\n    If specifying a path in terms of a set of nodes, this method\n    returns the set of edges corresponding to the path.\n\n    Parameters\n    ----------\n    path_nodes : list\n        A list of nodes in the network over which the path is specified.\n\n    Returns\n    -------\n    list\n        The list of edges corresponding to the path.\n\n    '''\n    path_edges = []\n    for i in range(len(path_nodes)):\n        if i != len(path_nodes) - 1:\n            ei = (path_nodes[i], path_nodes[i + 1])\n            path_edges.append(ei)\n\n    return path_edges\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.get_edge_types","title":"<code>get_edge_types(p_acti=0.5, set_selfloops_acti=True)</code>","text":"<p>Automatically generate a list of EdgeType for use in model building. The edge type specifies whether the edge is an activating or inhibiting relationship between the nodes. This routine randomly chooses a set of activating and inhibiting edge types for a model.</p> <p>Parameters:</p> Name Type Description Default <code>p_acti</code> <code>float</code> <p>The probability of an edge type being an activator. Note that this value must be less than 1.0, and that the probability of an edge being an inhibitor becomes 1.0 - p_acti.</p> <code>0.5</code> <code>set_selfloops_acti</code> <code>bool</code> <p>Work shows that, in general, self-inhibition does not generate models with multistable states. Therefore, this edge-type assignment routine allows one to automatically set all self-loops to be activation interactions.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list containing an EdgeType enum for every edge in the network.</p> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def get_edge_types(self, p_acti: float=0.5, set_selfloops_acti: bool=True) -&gt; list:\n    '''\n    Automatically generate a list of EdgeType for use in model building.\n    The edge type specifies whether the edge is an activating or inhibiting\n    relationship between the nodes. This routine randomly chooses a set of\n    activating and inhibiting edge types for a model.\n\n    Parameters\n    ----------\n    p_acti : float, default: 0.5\n        The probability of an edge type being an activator. Note that this value\n        must be less than 1.0, and that the probability of an edge being an\n        inhibitor becomes 1.0 - p_acti.\n\n    set_selfloops_acti : bool, default: True\n        Work shows that, in general, self-inhibition does not generate models with\n        multistable states. Therefore, this edge-type assignment routine allows one to\n        automatically set all self-loops to be activation interactions.\n\n    Returns\n    -------\n    list\n        A list containing an EdgeType enum for every edge in the network.\n\n    '''\n\n    p_inhi = 1.0 - p_acti\n\n    edge_types_o = [EdgeType.A, EdgeType.I]\n    edge_prob = [p_acti, p_inhi]\n    edge_types = np.random.choice(edge_types_o, self.N_edges, p=edge_prob)\n\n    if set_selfloops_acti: # if self-loops of the network are forced to be activators:\n        edge_types[self.selfloop_edge_inds] = EdgeType.A\n\n    return edge_types.tolist()\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.get_paths_matrix","title":"<code>get_paths_matrix()</code>","text":"<p>Compute a matrix showing the number of paths from starting node to end node. Note that this matrix can be extraordinarily large in a complicated graph such as most binomial networks.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The paths matrix, which specifies the number of paths between one node index as row index and another node index as the column index.</p> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def get_paths_matrix(self) -&gt; ndarray:\n    '''\n    Compute a matrix showing the number of paths from starting node to end node. Note that this\n    matrix can be extraordinarily large in a complicated graph such as most binomial networks.\n\n    Returns\n    -------\n    ndarray\n        The paths matrix, which specifies the number of paths between one node index as row index and another\n        node index as the column index.\n\n    '''\n\n\n    # What we want to show is that the nodes with the highest degree have the most connectivity to nodes in the network:\n    # mn_i = 10 # index of the master node, organized according to nodes_by_out_degree\n    paths_matrix = []\n    for mn_i in range(len(self.nodes_index)):\n        number_paths_to_i = []\n        for i in range(len(self.nodes_index)):\n            # print(f'paths between {mn_i} and {i}')\n            try:\n                paths_i = sorted(nx.shortest_simple_paths(self.GG,\n                                                          self.nodes_by_out_degree[mn_i],\n                                                          self.nodes_by_out_degree[i]),\n                                 reverse=True)\n            except:\n                paths_i = []\n\n            num_paths_i = len(paths_i)\n            number_paths_to_i.append(num_paths_i)\n\n        paths_matrix.append(number_paths_to_i)\n\n    self.paths_matrix = np.asarray(paths_matrix)\n\n    return self.paths_matrix\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.plot_degree_distributions","title":"<code>plot_degree_distributions()</code>","text":"<p>Generate a plot of the in- and out- degree distributions of the network as histograms. Requires self.characterize_graph() to have been run previously.</p> <p>Returns:</p> Name Type Description <code>fig</code> <code>figure</code> <code>ax</code> <code>axes</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def plot_degree_distributions(self) -&gt; tuple[object, object]:\n    '''\n    Generate a plot of the in- and out- degree distributions of the\n    network as histograms. Requires self.characterize_graph() to have\n    been run previously.\n\n    Returns\n    -------\n    fig : matplotlib.figure\n    ax : matplotlib.axes\n\n    '''\n    fig, ax = plt.subplots(1, 2, figsize=(10, 4), sharey=True)\n    ax[0].bar(self.in_bins, self.in_degree_counts)\n    ax[0].set_xlabel('Node degree')\n    ax[0].set_ylabel('Counts')\n    ax[0].set_title('In-Degree Distribution')\n    ax[1].bar(self.out_bins, self.out_degree_counts)\n    ax[1].set_xlabel('Node degree')\n    # ax[1].set_ylabel('Counts')\n    ax[1].set_title('Out-Degree Distribution')\n\n    return fig, ax\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.plot_pixel_matrix","title":"<code>plot_pixel_matrix(solsM, x_labels, y_labels, figsave=None, cmap=None, cbar_label='', figsize=(10, 10), fontsize=16)</code>","text":"<p>Plot a matrix of values as a heatmap.</p> <p>Parameters:</p> Name Type Description Default <code>solsM</code> <code>ndarray</code> <p>The matrix of values to plot as a heatmap.</p> required <code>x_labels</code> <code>list | ndarray | None</code> <p>Labels to apply to each column of the solsM matrix, along the horizontal axis.</p> required <code>y_labels</code> <code>list | ndarray | None</code> <p>Labels to apply to each row of the solsM matrix, along the vertical axis.</p> required <code>figsave</code> <code>str | None</code> <p>The full directory and filename to write the image file to. If None, no image will be save to disk. Only 'png' images can be exported.</p> <code>None</code> <code>cmap</code> <code>str | None</code> <p>The matplotlib colormap to use for the image.</p> <code>None</code> <code>cbar_label</code> <code>str</code> <p>The text label to write along the image colorbar.</p> <code>''</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure.</p> <code>(10,10)</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>figure</code> <code>ax</code> <code>axes</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def plot_pixel_matrix(self,\n                      solsM: ndarray,\n                      x_labels: list | ndarray|None,\n                      y_labels: list|ndarray|None,\n                      figsave: str | None = None,\n                      cmap: str | None = None,\n                      cbar_label: str = '',\n                      figsize: tuple = (10, 10),\n                      fontsize: int=16) -&gt; tuple[object, object]:\n    '''\n    Plot a matrix of values as a heatmap.\n\n    Parameters\n    ----------\n    solsM : ndarray\n        The matrix of values to plot as a heatmap.\n    x_labels : list|ndarray|None\n        Labels to apply to each column of the solsM matrix, along the horizontal axis.\n    y_labels : list|ndarray|None\n        Labels to apply to each row of the solsM matrix, along the vertical axis.\n    figsave : str|None, default: None\n        The full directory and filename to write the image file to. If None, no image\n        will be save to disk. Only 'png' images can be exported.\n    cmap : str|None, default: None\n        The matplotlib colormap to use for the image.\n    cbar_label : str, default: ''\n        The text label to write along the image colorbar.\n    figsize : tuple, default: (10,10)\n        The size of the figure.\n\n    Returns\n    -------\n    fig : matplotlib.figure\n    ax : matplotlib.axes\n\n    '''\n\n    if cmap is None:\n        cmap = 'magma'\n\n    fig, ax = plt.subplots(figsize=figsize)\n    im = ax.imshow(solsM, cmap=cmap)\n    ax.set_xticks(np.arange(solsM.shape[1]), labels=x_labels, font='DejaVu Serif', fontsize=fontsize)\n    ax.set_yticks(np.arange(solsM.shape[0]), labels=y_labels, fontsize=fontsize)\n    plt.setp(ax.get_xticklabels(), rotation=0, ha=\"right\",\n             rotation_mode=\"anchor\")\n    fig.colorbar(im, label=cbar_label)\n\n    if figsave is not None:\n        plt.savefig(figsave, dpi=300, transparent=True, format='png')\n\n    return fig, ax\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.plot_sols_array","title":"<code>plot_sols_array(solsM, gene_inds=None, figsave=None, cmap=None, save_format='png', figsize=(10, 10))</code>","text":"<p>Create and save a heatmap image representing a matrix of states for the regulatory network.</p> <p>Parameters:</p> Name Type Description Default <code>solsM</code> <code>ndarray</code> <p>The matrix of regulatory network states, with each state being a coloumn of the matrix and each row representing the expression level of a node in the network.</p> required <code>gene_inds</code> <code>list | ndarray | None</code> <p>A subset of the total nodes of the network that are to be displayed in the visualized heatmap.</p> <code>None</code> <code>figsave</code> <code>str | None</code> <p>The full directory and filename to write the image file to. If None, no image will be save to disk.</p> <code>None</code> <code>cmap</code> <code>str | None</code> <p>The matplotlib colormap to use for the image.</p> <code>None</code> <code>save_format</code> <code>str</code> <p>The file format to save the image in ('svg' or 'png').</p> <code>'png'</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure.</p> <code>(10,10)</code> <p>Returns:</p> Name Type Description <code>fig</code> <code>figure</code> <code>ax</code> <code>axes</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def plot_sols_array(self,\n                    solsM: ndarray,\n                    gene_inds: list|ndarray|None=None,\n                    figsave: str | None = None,\n                    cmap: str | None =None,\n                    save_format: str='png',\n                    figsize: tuple=(10,10)) -&gt; tuple[object, object]:\n    '''\n    Create and save a heatmap image representing a matrix of states for the\n    regulatory network.\n\n    Parameters\n    ----------\n    solsM : ndarray\n        The matrix of regulatory network states, with each state being a coloumn\n        of the matrix and each row representing the expression level of a node in\n        the network.\n    gene_inds : list|ndarray|None, default: None\n        A subset of the total nodes of the network that are to be displayed in the\n        visualized heatmap.\n    figsave : str|None, default: None\n        The full directory and filename to write the image file to. If None, no image\n        will be save to disk.\n    cmap : str|None, default: None\n        The matplotlib colormap to use for the image.\n    save_format : str, default: 'png'\n        The file format to save the image in ('svg' or 'png').\n    figsize : tuple, default: (10,10)\n        The size of the figure.\n\n    Returns\n    -------\n    fig : matplotlib.figure\n    ax : matplotlib.axes\n\n    '''\n\n    if cmap is None:\n        cmap = 'magma'\n\n    state_labels = [f'State {i}' for i in range(solsM.shape[1])]\n\n    if gene_inds is None:\n        gene_labels = np.asarray(self.nodes_list)\n\n    else:\n        gene_labels = np.asarray(self.nodes_list)[gene_inds]\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    if gene_inds is None:\n        im = ax.imshow(solsM, cmap=cmap)\n    else:\n        im = ax.imshow(solsM[gene_inds, :], cmap=cmap)\n\n    ax.set_xticks(np.arange(len(state_labels)), labels=state_labels)\n    ax.set_yticks(np.arange(len(gene_labels)), labels=gene_labels)\n    plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n             rotation_mode=\"anchor\")\n    fig.colorbar(im, label='Expression Level')\n\n    if figsave is not None:\n        plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n    return fig, ax\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.randomly_generate_special_network","title":"<code>randomly_generate_special_network(N_nodes, b_param=0.15, g_param=0.8, delta_in=0.0, delta_out=0.0, p_edge=0.5, graph_type=GraphType.scale_free)</code>","text":"<p>Procedurally generate a network with a scale-free or binomial (random) degree distribution.</p> <p>Parameters:</p> Name Type Description Default <code>N_nodes</code> <code>int</code> <p>The number of nodes to build the network (only used in randomly built networks, otherwise the number of nodes is calculated from the number of unique nodes supplied in the edges list).</p> required <code>graph_type</code> <code>GraphType = GraphType.scale_free</code> <p>The type of graph to generate in randomly-constructed networks.</p> <code>scale_free</code> <code>b_param</code> <code>float = 0.20</code> <p>For scale-free randomly-constructed networks, this determines the amount of interconnectivity between the in and out degree distributions, and in practical terms, increases the number of cycles in the graph. Note that 1 - beta - gamma must be greater than 0.0.</p> <code>0.15</code> <code>g_param</code> <code>float=0.75</code> <p>For scale-free randomly-constructed networks, this determines the emphasis on the network's out degree distribution, and in practical terms, increases the scale-free character of the out-distribution of the graph. Note that 1 - beta - gamma must be greater than 0.0.</p> <code>0.8</code> <code>delta_in</code> <code>float=0.0</code> <p>A parameter that increases the complexity of the network core, leading to more nodes being involved in cycles.</p> <code>0.0</code> <code>delta_out</code> <code>float = 0.0</code> <p>A parameter that increases the complexity of the network core, leading to more nodes being involved in cycles.</p> <code>0.0</code> <code>p_edge</code> <code>float=0.2</code> <p>For randomly constructed binomial-type networks, this parameter determines the probability of forming an edge. As p_edge increases, the number of network edges increases dramatically.</p> <code>0.5</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def randomly_generate_special_network(self,\n                                      N_nodes: int,\n                                      b_param: float=0.15,\n                                      g_param: float=0.8,\n                                      delta_in: float=0.0,\n                                      delta_out: float=0.0,\n                                      p_edge: float=0.5,\n                                      graph_type: GraphType = GraphType.scale_free\n                                      ):\n    '''\n    Procedurally generate a network with a scale-free or binomial (random) degree distribution.\n\n    Parameters\n    ----------\n    N_nodes : int\n        The number of nodes to build the network (only used in randomly built networks, otherwise the number of\n        nodes is calculated from the number of unique nodes supplied in the edges list).\n    graph_type : GraphType = GraphType.scale_free\n        The type of graph to generate in randomly-constructed networks.\n    b_param : float = 0.20\n        For scale-free randomly-constructed networks, this determines the amount of interconnectivity between\n        the in and out degree distributions, and in practical terms, increases the number of cycles in the graph.\n        Note that 1 - beta - gamma must be greater than 0.0.\n    g_param : float=0.75\n        For scale-free randomly-constructed networks, this determines the emphasis on the network's\n        out degree distribution, and in practical terms, increases the scale-free character of the out-distribution\n        of the graph. Note that 1 - beta - gamma must be greater than 0.0.\n    delta_in : float=0.0\n        A parameter that increases the complexity of the network core, leading to more nodes being involved in\n        cycles.\n    delta_out : float = 0.0\n        A parameter that increases the complexity of the network core, leading to more nodes being involved in\n        cycles.\n    p_edge : float=0.2\n        For randomly constructed binomial-type networks, this parameter determines the probability of forming\n        an edge. As p_edge increases, the number of network edges increases dramatically.\n\n    '''\n    # Save all the construction parameters to file:\n    self.N_nodes = N_nodes\n    self._beta = b_param\n    self._gamma = g_param\n    self._delta_in = delta_in\n    self._delta_out = delta_out\n    self._p_edge = p_edge\n    self._graph_type = graph_type\n\n    if graph_type is GraphType.scale_free:\n        # generate a scale-free network with the supplied parameters...\n        # The input scale-free probability is given as 1.0 minus beta and gamma, as all\n        # three parameters must be constrained to add to 1.0:\n        alpha = 1.0 - b_param - g_param\n\n        # Generate a scale free graph with the settings:\n        GGo = nx.scale_free_graph(self.N_nodes,\n                                  alpha=alpha,\n                                  beta=b_param,\n                                  gamma=g_param,\n                                  delta_in=delta_in,\n                                  delta_out=delta_out,\n                                  seed=None,\n                                  initial_graph=None)\n\n    elif graph_type is GraphType.random:\n        # generate a random Erdos-Renyi network\n        GGo = nx.erdos_renyi_graph(self.N_nodes,\n                                   p_edge,\n                                   seed=None,\n                                   directed=True)\n\n    else:\n        raise Exception(\"Only scale-free and random (binomial) networks supported.\")\n\n    # obtain the unique edges only:\n    self.edges_list = list(set(GGo.edges()))\n    self.N_edges = len(self.edges_list)\n\n    # As the scale_free_graph function can return duplicate edges, get rid of these\n    # by re-defining the graph with the unique edges only:\n    GG = nx.DiGraph(self.edges_list)\n\n    self.nodes_list = np.arange(self.N_nodes).tolist()\n    self.GG = GG\n    self.edges_index = self.edges_list\n    self.nodes_index = self.nodes_list\n\n    self._make_node_edge_indices()\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.save_network","title":"<code>save_network(filename)</code>","text":"<p>Write a network, including edge types, to a saved file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The full directory and filename to write the graph file to as a gml format graph.</p> required Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def save_network(self, filename: str):\n    '''\n    Write a network, including edge types, to a saved file.\n\n    Parameters\n    ----------\n    filename : str\n        The full directory and filename to write the graph file to\n        as a gml format graph.\n    '''\n    nx.write_gml(self.GG, filename)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.save_network_image","title":"<code>save_network_image(save_filename, use_dot_layout=False)</code>","text":"<p>Uses pygraphviz to create a basic plot of the network model.</p> <p>Parameters:</p> Name Type Description Default <code>save_filename</code> <code>str</code> <p>The full directory and filename to write the graph image file to. If the filename ends with '.png' the image will be a raster image, if it ends with '.svg' it will be a vector graphics file.</p> required <code>use_dot_layout</code> <code>bool</code> <p>Use the 'dot' layout to build the graph.</p> <code>false</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def save_network_image(self, save_filename: str, use_dot_layout: bool=False):\n    '''\n    Uses pygraphviz to create a basic plot of the network model.\n\n    Parameters\n    ----------\n    save_filename : str\n        The full directory and filename to write the graph image file to.\n        If the filename ends with '.png' the image will be a raster image, if it ends\n        with '.svg' it will be a vector graphics file.\n    use_dot_layout : bool, default: false\n        Use the 'dot' layout to build the graph.\n\n    '''\n    G_plt = pgv.AGraph(strict=False,\n                       splines=True,\n                       directed=True,\n                       randkdir='TB',\n                       nodesep=0.1,\n                       ranksep=0.3,\n                       dpi=300)\n\n    for nde_i in self.nodes_list:\n        G_plt.add_node(nde_i,\n                       style='filled',\n                       fillcolor='LightCyan',\n                       color='Black',\n                       shape='ellipse',\n                       fontcolor='Black',\n                       # fontname=net_font_name,\n                       fontsize=12)\n\n    for (ei, ej), etype in zip(self.edges_list, self.edge_types):\n        if etype is EdgeType.A:\n            G_plt.add_edge(ei, ej, arrowhead='dot', color='blue', penwidth=2.0)\n        elif etype is EdgeType.I:\n            G_plt.add_edge(ei, ej, arrowhead='tee', color='red', penwidth=2.0)\n        else:\n            G_plt.add_edge(ei, ej, arrowhead='normal', color='black', penwidth=2.0)\n\n    if use_dot_layout:\n        G_plt.layout(prog=\"dot\")\n    else:\n        G_plt.layout()\n\n    G_plt.draw(save_filename)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.set_edge_types","title":"<code>set_edge_types(edge_types)</code>","text":"<p>Assign a list EdgeType to edges of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>edge_types</code> <code>list | ndarray</code> <p>A list of edge type enumerations; one for each edge of the network.</p> required Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def set_edge_types(self, edge_types: list|ndarray):\n    '''\n    Assign a list EdgeType to edges of the graph.\n\n    Parameters\n    ----------\n    edge_types : list|ndarray\n        A list of edge type enumerations; one for each edge of the network.\n    '''\n    self.edge_types = edge_types\n\n    # assign the edge types to the graph in case we decide to save the network:\n    edge_attr_dict = {}\n    for ei, et in zip(self.edges_list, edge_types):\n        edge_attr_dict[ei] = {\"edge_type\": et.name}\n\n    nx.set_edge_attributes(self.GG, edge_attr_dict)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC.set_node_types","title":"<code>set_node_types(node_type_dict=None, pure_gene_edges_only=False)</code>","text":"<p>Assign a dictionary of NodeType to nodes of the graph.</p> <p>Parameters:</p> Name Type Description Default <code>node_type_dict</code> <code>dict | None</code> <p>A list of node type enumerations for each node of the network.</p> <code>None</code> <code>pure_gene_edges_only</code> <code>bool</code> <p>Classify multiple non-process NodeType as \"genes\" (True) or only NodeType.gene (False).</p> <code>False</code> Source code in <code>cellnition/science/network_models/network_abc.py</code> <pre><code>def set_node_types(self, node_type_dict: dict|None = None, pure_gene_edges_only: bool = False):\n    '''\n    Assign a dictionary of NodeType to nodes of the graph.\n\n    Parameters\n    ----------\n    node_type_dict : dict|None, default: None\n        A list of node type enumerations for each node of the network.\n    pure_gene_edges_only : bool, default: False\n        Classify multiple non-process NodeType as \"genes\" (True) or only NodeType.gene (False).\n    '''\n\n    # Now that indices are set, give nodes a type attribute and classify node inds.\n    # First, initialize a dictionary to collect all node indices by their node type:\n    self.node_type_inds = {}\n    for nt in NodeType:\n        self.node_type_inds[nt.name] = []\n\n    # Next, set all nodes to the gene type by default:\n    node_types = [NodeType.gene for i in self.nodes_index]\n\n    # If there is a supplied node dictionary, go through it and\n    # override the default gene type with the user-specified type:\n    if node_type_dict is not None:\n        for ntag, ntype in node_type_dict.items():\n            for nde_i, nde_n in enumerate(self.nodes_list):\n                if type(nde_n) is str:\n                    if nde_n.startswith(ntag):\n                        node_types[nde_i] = ntype\n                else:\n                    if nde_n == ntag:\n                        node_types[nde_i] = ntype\n\n    # Set node types to the graph:\n    self.node_types = node_types\n    # Set node type as graph node attribute:\n    node_attr_dict = {}\n    for nde_i, nde_t in zip(self.nodes_list, node_types):\n        node_attr_dict[nde_i] = {\"node_type\": nde_t.name}\n\n    nx.set_node_attributes(self.GG, node_attr_dict)\n\n    # Collect node indices by their type:\n    for nde_i, nde_t in enumerate(self.node_types):\n        self.node_type_inds[nde_t.name].append(nde_i)\n\n    # Next, we need to distinguish edges based on their node type\n    # to separate out some node type interactions from the regular\n    # GRN-type interactions:\n    if pure_gene_edges_only:  # if the user wants to consider only gene type nodes\n        type_tags = [NodeType.gene.name]\n    else:  # Otherwise include all nodes that can form regular interaction edges:\n        type_tags = [NodeType.gene.name,\n                     NodeType.signal.name,\n                     NodeType.sensor.name,\n                     NodeType.effector.name]\n\n    self.regular_node_inds = []\n    for tt in type_tags:\n        self.regular_node_inds.extend(self.node_type_inds[tt])\n\n    # aliases for convenience:\n    # combine signals with factors as they have a similar 'setability' condition\n    # from the outside\n    # self.input_node_inds = self.node_type_inds[NodeType.signal.name] + self.node_type_inds[NodeType.factor.name]\n    self.input_node_inds = ((np.asarray(self.in_degree_sequence) == 0).nonzero()[0]).tolist()\n\n    self.output_node_inds = ((np.asarray(self.out_degree_sequence) == 0).nonzero()[0]).tolist()\n    self.sensor_node_inds = self.node_type_inds[NodeType.sensor.name]\n    self.process_node_inds = self.node_type_inds[NodeType.process.name]\n\n    if len(self.node_type_inds[NodeType.effector.name]) == 0:\n        self.effector_node_inds = ((np.asarray(self.out_degree_sequence) == 0).nonzero()[0]).tolist()\n    else:\n        self.effector_node_inds = self.node_type_inds[NodeType.effector.name]\n\n    self.noninput_node_inds = np.setdiff1d(self.nodes_index, self.input_node_inds).tolist()\n\n    self.factor_node_inds = self.node_type_inds[NodeType.factor.name]\n\n    # also determine the \"main nodes\", which are nodes that are not input and also are not effectors:\n    self.main_nodes = np.setdiff1d(self.noninput_node_inds, self.effector_node_inds).tolist()\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/","title":"Model Enumerations","text":"<p>This module defines enumerations throughout Cellnition, primarily in the construction of regulatory network models.</p>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.CouplingType","title":"<code>CouplingType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>In both continuous (<code>ProbabilityNet</code>) and Boolean (<code>BooleanNet</code>) regulatory network models, the CouplingType supplies a heuristic for the case where multiple nodes regulate the activity of a single downstream node. The different coupling types are:</p> <ul> <li><code>additive</code>: when multiple nodes act on a downstream node, their influences combine additively (\"OR\" function), regardless of whether they are activators or inhibitors.</li> <li><code>multiplicative</code>: when multiple nodes act on a downstream node, their influences combine multiplicatively (\"AND\" function), regardless of whether they are activators or inhibitors.</li> <li><code>mix1</code>: when multiple nodes act on a downstream node, activators combine additively (\"OR\" function), while  inhibitors combine multiplicatively (\"AND\" function).</li> <li><code>mix2</code>: when multiple nodes act on a downstream node, inhibitors combine additively (\"OR\" function), while  activators combine multiplicatively (\"AND\" function).</li> </ul> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class CouplingType(Enum):\n    '''\n    In both continuous ([`ProbabilityNet`][cellnition.science.network_models.probability_networks.ProbabilityNet])\n    and Boolean ([`BooleanNet`][cellnition.science.network_models.boolean_networks.BooleanNet]) regulatory\n    network models, the CouplingType supplies a heuristic for the case where multiple nodes regulate the activity\n    of a single downstream node. The different coupling types are:\n\n    - `additive`: when multiple nodes act on a downstream node, their influences combine additively (\"OR\" function),\n    regardless of whether they are activators or inhibitors.\n    - `multiplicative`: when multiple nodes act on a downstream node, their influences combine multiplicatively (\"AND\" function),\n    regardless of whether they are activators or inhibitors.\n    - `mix1`: when multiple nodes act on a downstream node, activators combine additively (\"OR\" function), while\n     inhibitors combine multiplicatively (\"AND\" function).\n    - `mix2`: when multiple nodes act on a downstream node, inhibitors combine additively (\"OR\" function), while\n     activators combine multiplicatively (\"AND\" function).\n\n    '''\n    additive = 'additive'\n    multiplicative = 'multiplicative'\n    mix1 = 'mix1' # activators \"OR\", inhibitors \"AND\"\n    specified = 'specified'\n    mix2 = 'mix2' # Activators \"AND\", inhibitors \"OR\"\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.EdgeType","title":"<code>EdgeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specify whether the directed edge of the regulatory network has an activating effect on the level of the target node (<code>EdgeType.A</code>), an inhibiting effect on the level of the target node (<code>EdgeType.I</code>). In non-regulatory network models, an additional neutral directed edge <code>EdgeType.N</code> can be specified.</p> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class EdgeType(Enum):\n    '''\n    Specify whether the directed edge of the regulatory network\n    has an activating effect on the level of the target node (`EdgeType.A`),\n    an inhibiting effect on the level of the target node (`EdgeType.I`). In\n    non-regulatory network models, an additional neutral directed\n    edge `EdgeType.N` can be specified.\n\n    '''\n    A = 'Activator'\n    I = 'Inhibitor'\n    N = 'Neutral'\n    As = 'Multiplicative Activation'\n    Is = 'Multiplicative Inhibition'\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.EquilibriumType","title":"<code>EquilibriumType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>When treating the regulatory network as a dynamic system, the identified equilibrium states have a particular dynamic character, which Cellnition marks using EquilibriumType:</p> <ul> <li><code>attractor</code>: an asymptotically-stable point attractor that moves monotonically to the attractor.</li> <li><code>attractor_limit_cycle</code>: an asymptotically-stable attractor that moves with diminishing-amplitude oscillations to the attractor.</li> <li><code>limit_cycle</code>: an attractor that perpetually repeats cyclic oscillations about a central point.</li> <li><code>saddle</code>: a metastable saddle-type attractor that leaves the attractor with small perturbations.</li> <li><code>undetermined</code>: an equilibrium with undetermined characteristics.</li> <li><code>hidden</code>: an attractor that was only found in time-series or pseudo-time series investigations.</li> </ul> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class EquilibriumType(Enum):\n    '''\n    When treating the regulatory network as a dynamic system, the\n    identified equilibrium states have a particular dynamic character,\n    which Cellnition marks using EquilibriumType:\n\n    - `attractor`: an asymptotically-stable point attractor that moves monotonically to the attractor.\n    - `attractor_limit_cycle`: an asymptotically-stable attractor that moves with diminishing-amplitude oscillations to the attractor.\n    - `limit_cycle`: an attractor that perpetually repeats cyclic oscillations about a central point.\n    - `saddle`: a metastable saddle-type attractor that leaves the attractor with small perturbations.\n    - `undetermined`: an equilibrium with undetermined characteristics.\n    - `hidden`: an attractor that was only found in time-series or pseudo-time series investigations.\n\n    '''\n    attractor = 0\n    attractor_limit_cycle = 1\n    limit_cycle = 2\n    saddle = 3\n    repellor = 4\n    repellor_limit_cycle = 5\n    undetermined = 6\n    hidden = 7 # corresponds to a hidden attractor\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.GraphType","title":"<code>GraphType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>When creating procedural graphs, the <code>GraphType.scale_free</code> tag can be used to generate graphs with scale-free degree distributions, whereas the <code>GraphType.random</code> can be used to generate random networks with binomial degree distributions.</p> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class GraphType(Enum):\n    '''\n    When creating procedural graphs, the `GraphType.scale_free`\n    tag can be used to generate graphs with scale-free degree\n    distributions, whereas the `GraphType.random` can be used to\n    generate random networks with binomial degree distributions.\n\n    '''\n    scale_free = 'Scale Free'\n    random = 'Random'\n    user = 'User Defined'\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.InterFuncType","title":"<code>InterFuncType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>In continuous models (see <code>ProbabilityNet</code>), this enumeration specifies the type of interaction function used when the level of one node acts to regulate the level of another node. InterFuncType.logistic specifies logistic function interactions (see <code>f_acti_logi_s</code> and <code>f_inhi_logi_s</code>), whereas InterFuncType.hill specifies hill function interactions (see <code>f_acti_hill_s</code> and <code>f_inhi_hill_s</code>).</p> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class InterFuncType(Enum):\n    '''\n    In continuous models (see\n    [`ProbabilityNet`][cellnition.science.network_models.probability_networks.ProbabilityNet]),\n    this enumeration specifies the type of interaction function used when the level of one node\n    acts to regulate the level of another node.\n    InterFuncType.logistic specifies logistic function interactions\n    (see [`f_acti_logi_s`][cellnition.science.network_models.interaction_functions.f_acti_logi_s] and\n    [`f_inhi_logi_s`][cellnition.science.network_models.interaction_functions.f_inhi_logi_s]), whereas\n    InterFuncType.hill specifies hill function interactions (see\n    [`f_acti_hill_s`][cellnition.science.network_models.interaction_functions.f_acti_hill_s] and\n    [`f_inhi_hill_s`][cellnition.science.network_models.interaction_functions.f_inhi_hill_s]).\n\n    '''\n    logistic = 'Logistic'\n    hill = 'Hill'\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_network_enums/#cellnition.science.network_models.network_enums.NodeType","title":"<code>NodeType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Specify the node type of the model. Typically, nodes are <code>NodeType.gene</code> by default. Other node types are ascribed for tagging nodes in networks (e.g. <code>NodeType.Cycle</code> could be used to color nodes present in network cycles), but generally NodeTypes other than <code>NodeType.gene</code> are not presently utilized in Cellnition and are planned for future work.</p> Source code in <code>cellnition/science/network_models/network_enums.py</code> <pre><code>class NodeType(Enum):\n    '''\n    Specify the node type of the model. Typically, nodes are\n    `NodeType.gene` by default. Other node types are ascribed for\n    tagging nodes in networks (e.g. `NodeType.Cycle` could be\n    used to color nodes present in network cycles), but generally\n    NodeTypes other than `NodeType.gene` are not presently utilized\n    in Cellnition and are planned for future work.\n\n    '''\n    gene = 'Gene'\n    signal = 'Signal'\n    process = 'Process'\n    sensor = 'Sensor'\n    effector = 'Effector'\n    core = 'Hub Core'\n    factor = 'Factor'\n    cycle = 'Cycle'\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/","title":"Continuous Network Model","text":"<p>               Bases: <code>NetworkABC</code></p> <p>This class builds a fully-continuous, differential-equation based model of a regulatory network from a directed graph. The class can produce and characterize the directed graph upon which the continuous model is based by importing from the Cellnition <code>network_library</code>, from user-defined edges, or by using procedurally generated graphs. Once the directed graph representing the regulatory network is formed, <code>ProbabilityNet</code> generates a continuous, differential-equation based analytic model of the regulatory network, along with numerical counterparts for general simulation in time or in equilibrium state search. The simulation object produced by this class can be used to build Network Finite State Machines (NFSMs) using the <code>StateMachine</code> class.</p> <p>This class is called a \"probability network\", as the differential equations specifying change in regulatory network node expression level produce output that is always limited to the range of 0.0 and 1.0, thereby effectively computing the probability of seeing a gene product (node expression level) rather than an absolute protein concentration (i.e. a node level = 0.21 represents a 21% probability of node expression).</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>class ProbabilityNet(NetworkABC):\n    '''\n    This class builds a fully-continuous, differential-equation based model of a regulatory network\n    from a directed graph. The class can produce and characterize the directed graph upon which the continuous model\n    is based by importing from the Cellnition [`network_library`][cellnition.science.network_models.network_library],\n    from user-defined edges, or by using procedurally generated\n    graphs. Once the directed graph representing the regulatory network is formed, `ProbabilityNet` generates\n    a continuous, differential-equation based analytic model of the regulatory network,\n    along with numerical counterparts for general simulation in time or in equilibrium state search.\n    The simulation object produced by this class can be used to build Network Finite State Machines (NFSMs) using the\n    [`StateMachine`][cellnition.science.networks_toolbox.state_machine.StateMachine] class.\n\n    This class is called a \"probability network\", as the differential equations specifying change in regulatory\n    network node expression level produce output that is always limited to the range of 0.0 and 1.0, thereby\n    effectively computing the probability of seeing a gene product (node expression level) rather than an absolute\n    protein concentration (i.e. a node level = 0.21 represents a 21% probability of node expression).\n    '''\n    def __init__(self,\n                 N_nodes: int,\n                 interaction_function_type: InterFuncType = InterFuncType.logistic,\n                 node_expression_levels: float=5.0):\n        '''\n        Initialize the ProbabilityNet class.\n\n        '''\n\n        self.N_nodes = N_nodes\n        self._nodes_index = [i for i in range(self.N_nodes)]\n        self.regular_node_inds = self._nodes_index\n        self.nodes_list = [f'G{i}' for i in range(self.N_nodes)]\n\n        # Initialize some object state variables:\n        self._reduced_dims = False # Indicate that model is full dimensions\n        self._solved_analytically = False # Indicate that the model does not have an analytical solution\n        self._dcdt_vect_reduced_s = None # Initialize this to None\n        self.process_params_s = []  # initialize this to be an empty list\n        self.edge_types = None\n        self.edges_index = None\n\n        self.p_min = 1.0e-6 # small nonzero element for working with Hill versions\n        self._push_away_from_zero = self.p_min # smallish constant to push initial guess of fsolve away from zero\n\n        super().__init__()  # Initialize the base class\n\n        self._inter_fun_type = interaction_function_type\n\n        if node_expression_levels &lt;= 1:\n            raise Exception(\"Node expression levels must be greater than 1!\")\n        self._node_expression_levels = node_expression_levels\n\n        # Matrix Equations:\n        # Matrix symbols to construct matrix equation bases:\n        self._M_n_so = sp.MatrixSymbol('M_n', self.N_nodes, self.N_nodes)\n        self._M_beta_so = sp.MatrixSymbol('M_beta', self.N_nodes, self.N_nodes)\n        self._M_p_so = sp.MatrixSymbol('M_p', self.N_nodes, self.N_nodes)\n\n        # Define symbolic adjacency matrices to use as masks in defining multi and add matrices:\n        self._A_add_so = sp.MatrixSymbol('A_add', N_nodes, N_nodes)\n        self._A_mul_so = sp.MatrixSymbol('A_mul', N_nodes, N_nodes)\n\n        # Now we can define symbolic matrices that use the add and mul adjacencies to mask which\n        # n-parameters to use:\n        M_n_add_so = sp.hadamard_product(self._A_add_so, self._M_n_so)\n        M_n_mul_so = sp.hadamard_product(self._A_mul_so, self._M_n_so)\n\n        # And functions can be plugged in as matrix equations; these are the fundamental\n        # model building functions:\n        if self._inter_fun_type is InterFuncType.hill:\n            # For Hill Functions:\n            self._M_funk_add_so = sp.Matrix(N_nodes, N_nodes,\n                                      lambda i, j: 1 / (1 + (self._M_beta_so[j, i] * self._M_p_so[j, i]) ** -M_n_add_so[j, i]))\n            self._M_funk_mul_so = sp.Matrix(N_nodes, N_nodes,\n                                      lambda i, j: 1 / (1 + (self._M_beta_so[j, i] * self._M_p_so[j, i]) ** -M_n_mul_so[j, i]))\n        else:\n            # For Logistic Functions:\n            self._M_funk_add_so = sp.Matrix(N_nodes, N_nodes,\n                                      lambda i, j: 1 / (1 + sp.exp(-M_n_add_so[j, i] * (self._M_p_so[j, i] -\n                                                                                        self._M_beta_so[j, i]))))\n            self._M_funk_mul_so = sp.Matrix(N_nodes, N_nodes,\n                                      lambda i, j: 1 / (1 + sp.exp(-M_n_mul_so[j, i] * (self._M_p_so[j, i] -\n                                                                                        self._M_beta_so[j, i]))))\n\n        # Symbolic model parameters:\n        self._d_s = sp.IndexedBase('d', shape=self.N_nodes, positive=True)  # Maximum rate of decay\n        self._p_s = sp.IndexedBase('p', shape=self.N_nodes, positive=True)  # Probability of gene product\n\n        # Vectorized node-parameters and variables:\n        self._d_vect_s = [self._d_s[i] for i in range(self.N_nodes)]  # maximum rate of decay for each node\n        self._c_vect_s = sp.Matrix([self._p_s[i] for i in range(self.N_nodes)])  # gene product probability for each node\n\n        self._beta_s = sp.IndexedBase('beta', shape=(self.N_nodes, self.N_nodes), positive=True)  # Hill centre\n        self._n_s = sp.IndexedBase('n', shape=(self.N_nodes, self.N_nodes), positive=True)  # Hill coupling\n\n        # Create a matrix out of the n_s symbols:\n        self._M_n_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                                lambda i, j: self._n_s[i, j])\n\n        self._M_beta_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                                   lambda i, j: self._beta_s[i, j])\n\n        # Define vector of ones to use in matrix operations:\n        self._ones_vect = sp.ones(1, self.N_nodes)\n\n        # Create a matrix that allows us to access the concentration vectors\n        # duplicated along columns:\n        self._M_p_s = self._c_vect_s * self._ones_vect\n\n    def build_adjacency_from_edge_type_list(self,\n                        edge_types: list[EdgeType],\n                        edges_index: list[tuple[int,int]],\n                        coupling_type: CouplingType=CouplingType.specified):\n        '''\n\n        '''\n        A_full_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        A_add_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        A_mul_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n        # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n        # and multiplicative interactions:\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_full_s[nde_i, nde_j] = 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_full_s[nde_i, nde_j] = -1\n\n        for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n            if coupling_type is CouplingType.specified:\n                if etype is EdgeType.I:\n                    A_add_s[nde_i, nde_j] = -1\n                elif etype is EdgeType.A:\n                    A_add_s[nde_i, nde_j] = 1\n                elif etype is EdgeType.Is:\n                    A_mul_s[nde_i, nde_j] = -1\n                elif etype is EdgeType.As:\n                    A_mul_s[nde_i, nde_j] = 1\n\n            elif coupling_type is CouplingType.additive:\n                if etype is EdgeType.I or etype is EdgeType.Is:\n                    A_add_s[nde_i, nde_j] = -1\n                elif etype is EdgeType.A or etype is EdgeType.As:\n                    A_add_s[nde_i, nde_j] = 1\n\n            elif coupling_type is CouplingType.multiplicative:\n                if etype is EdgeType.I or etype is EdgeType.Is:\n                    A_mul_s[nde_i, nde_j] = -1\n                elif etype is EdgeType.A or etype is EdgeType.As:\n                    A_mul_s[nde_i, nde_j] = 1\n\n            elif coupling_type is CouplingType.mix1:\n                if etype is EdgeType.A or etype is EdgeType.As:\n                    A_add_s[nde_i, nde_j] = 1\n                elif etype is EdgeType.I or etype is EdgeType.Is:\n                    A_mul_s[nde_i, nde_j] = -1\n\n        A_add_s = sp.Matrix(A_add_s)\n        A_mul_s = sp.Matrix(A_mul_s)\n        A_full_s = sp.Matrix(A_full_s)\n\n        return A_add_s, A_mul_s, A_full_s\n\n    def get_adjacency_randomly(self, coupling_type: CouplingType=CouplingType.mix1, set_autoactivation: bool=True):\n        '''\n        Return a randomly-generated full adjacency matrix.\n        '''\n        A_full_s = sp.Matrix(np.random.randint(-1, 2, size=(self.N_nodes, self.N_nodes)))\n\n        if set_autoactivation:\n            # Make it so that any diagonal elements are self-activating rather than self-inhibiting\n            A_full_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                                 lambda i,j: A_full_s[i,j]*A_full_s[i,j] if i==j else A_full_s[i,j])\n\n        A_add_s, A_mul_s = self.process_full_adjacency(A_full_s, coupling_type=coupling_type)\n\n        return A_add_s, A_mul_s, A_full_s\n\n\n    def edges_from_adjacency(self, A_add_s: MutableDenseMatrix, A_mul_s: MutableDenseMatrix):\n        '''\n        Returns edge type and edge index from adjacency matrices.\n        '''\n        edges_type = []\n        edges_index = []\n\n        A_full_s = A_add_s + A_mul_s\n        for i in range(self.N_nodes):\n            for j in range(self.N_nodes):\n                afull_ij = A_full_s[i,j]\n                if afull_ij != 0:\n                    edges_index.append((i, j))\n                    if A_add_s[i,j] &lt; 0:\n                        edges_type.append(EdgeType.I)\n                    elif A_add_s[i,j] &gt; 0:\n                        edges_type.append(EdgeType.A)\n                    elif A_mul_s[i,j] &lt; 0:\n                        edges_type.append(EdgeType.Is)\n                    elif A_mul_s[i,j] &gt; 0:\n                        edges_type.append(EdgeType.As)\n                    else:\n                        edges_type.append(EdgeType.N)\n\n        return edges_index, edges_type\n\n\n    def process_full_adjacency(self, A_full_s: MutableDenseMatrix, coupling_type: CouplingType=CouplingType.mix1):\n        '''\n        Process a full adjacency matrix into additive and multiplicative components\n        based on a specified coupling type.\n\n        '''\n        A_add_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n        A_mul_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n        for i in range(self.N_nodes):\n            for j in range(self.N_nodes):\n                afull_ij = A_full_s[i,j]\n                if afull_ij == 1:\n                    if coupling_type is CouplingType.additive or coupling_type is CouplingType.mix1:\n                        A_add_s[i,j] = 1\n                    elif coupling_type is CouplingType.multiplicative:\n                        A_mul_s[i,j] = 1\n                    else:\n                        raise Exception('CouplingType.specified is not supported in this method.')\n\n                if afull_ij == -1:\n                    if coupling_type is CouplingType.additive:\n                        A_add_s[i,j] = -1\n                    elif coupling_type is CouplingType.multiplicative or coupling_type is CouplingType.mix1:\n                        A_mul_s[i,j] = -1\n                    else:\n                        raise Exception('CouplingType.specified is not supported in this method.')\n\n        A_add_s = sp.Matrix(A_add_s)\n        A_mul_s = sp.Matrix(A_mul_s)\n\n        return A_add_s, A_mul_s\n\n\n    def build_analytical_model(self,\n                 A_add_s: MutableDenseMatrix,\n                 A_mul_s: MutableDenseMatrix,\n                               ):\n        '''\n\n        '''\n\n        # Initialize a list of node indices that should be constrained (removed from solution searches)\n        # due to their lack of regulation:\n        self.input_node_inds = []\n\n        if A_add_s.shape != (self.N_nodes, self.N_nodes):\n            raise Exception(\"Shape of A_add_s is not in terms of network node number!\")\n\n        if A_mul_s.shape != (self.N_nodes, self.N_nodes):\n            raise Exception(\"Shape of A_add_s is not in terms of network node number!\")\n\n        M_funk_add_si = self._M_funk_add_so.subs(\n            [(self._M_p_so, self._M_p_s),\n             (self._M_n_so, self._M_n_s),\n             (self._M_beta_so, self._M_beta_s),\n             (self._A_add_so, A_add_s)])\n\n        M_funk_mul_si = self._M_funk_mul_so.subs(\n            [(self._M_p_so, self._M_p_s),\n             (self._M_n_so, self._M_n_s),\n             (self._M_beta_so, self._M_beta_s),\n             (self._A_mul_so, A_mul_s)])\n\n        # Filter out the 1/2 terms and set to 0 (addiditive) or 1 (multiplicative):\n        M_funk_add_s = sp.Matrix(self.N_nodes, self.N_nodes, lambda i, j: sp.Piecewise(\n            (M_funk_add_si[i, j], M_funk_add_si[i, j] != sp.Rational(1, 2)),\n            (0, True)))\n\n        M_funk_mul_s = sp.Matrix(self.N_nodes, self.N_nodes, lambda i, j: sp.Piecewise(\n            (M_funk_mul_si[i, j], M_funk_mul_si[i, j] != sp.Rational(1, 2)),\n            (1, True)))\n\n        # As A_add_s is a signed adjacency matrix, we need to get the absolute value to count edges:\n        abs_A_add_s = sp.hadamard_product(A_add_s, A_add_s)\n\n        # Count the nodes interacting (on input) with each node:\n        n_add_edges_i = abs_A_add_s.T * self._ones_vect.T\n        # Correct for any zeros in the n_add_edges and create a normalization object:\n        self._n_add_edges = sp.Matrix(self.N_nodes, 1,\n                                      lambda i, j: sp.Piecewise((sp.Rational(1, n_add_edges_i[i, j]), n_add_edges_i[i, j] != 0),\n                                                          (1, True)))\n        add_terms_i = M_funk_add_s * self._ones_vect.T\n\n        # The add_terms need to be normalized to keep concentrations between 0 and 1:\n        self._add_terms = sp.hadamard_product(self._n_add_edges, add_terms_i)\n\n        self._mul_terms = sp.Matrix(np.prod(M_funk_mul_s, axis=1))\n\n        self._dcdt_vect_s = []\n        for i in range(self.N_nodes):\n            if self._add_terms[i] == 0 and self._mul_terms[i] == 1: # if there's no add term and no mul term\n                self._dcdt_vect_s.append(0) # set the rate of change of this unregulated node to zero\n                self.input_node_inds.append(i) # append this node to the list of nodes that should be constrained\n            elif self._add_terms[i] == 0 and self._mul_terms[i] != 1: # remove the null add term to avoid nulling all growth\n                self._dcdt_vect_s.append(self._d_vect_s[i] * self._mul_terms[i] -\n                                         self._c_vect_s[i] * self._d_vect_s[i])\n            else: # the node is a mix of additive and potential multiplicative regulation:\n                self._dcdt_vect_s.append(self._d_vect_s[i] * self._mul_terms[i] * self._add_terms[i] -\n                                         self._c_vect_s[i] * self._d_vect_s[i])\n\n        # This is an \"energy\" function to be minimized at the equilibrium points:\n        self._opti_s = (sp.Matrix(self._dcdt_vect_s).T * sp.Matrix(self._dcdt_vect_s))[0, 0]\n\n        # Create linearized lists of symbolic parameters that are needed to solve the model (exclude the\n        # zero entries of the M_n and M_beta matrices:\n        # FIXME: need to rebuild the graph model if edges index changes...\n        self._beta_vect_s = [self._beta_s[nde_i, nde_j] for nde_i, nde_j in self.edges_index]\n        self._n_vect_s = [self._n_s[nde_i, nde_j] for nde_i, nde_j in self.edges_index]\n\n        self._A_add_s = A_add_s\n        self._A_mul_s = A_mul_s\n\n        # get the \"regular\" nodes:\n        self.noninput_node_inds = np.setdiff1d(self.nodes_index, self.input_node_inds)\n\n        # As we scale-down all concentrations for additive interactions so that the\n        # concentration ranges between 0.0 and 1.0, we need to scale the out edge\n        # beta parameter for these scaled-down nodes so that they signal as they would in\n        # a fully dimensionalized model:\n        subs_list = []\n        for ei, (ndei, ndej) in enumerate(self.edges_index):\n            if self._n_add_edges[ndei] != 1:\n                if self._inter_fun_type is InterFuncType.logistic:\n                    subs_list.append((self._beta_vect_s[ei],\n                                      self._beta_vect_s[ei] * self._n_add_edges[ndei]))\n                else:\n                    subs_list.append((self._beta_vect_s[ei],\n                                      self._beta_vect_s[ei]/self._n_add_edges[ndei]))\n\n        self._dcdt_vect_s = list(sp.Matrix(self._dcdt_vect_s).subs(subs_list))\n\n        self.c_vect_s_viz, self.dcdt_vect_s_viz = self.get_visual_equations()\n\n    def make_numerical_params(self,\n                       d_base: float|list[float]=1.0,\n                       n_base: float|list[float]=15.0,\n                       beta_base: float|list[float]=0.25,\n                       ) -&gt; tuple[list[float], list[float], list[float]]:\n        '''\n        Scrape the network for base parameters to initialize numerical parameters.\n\n        '''\n        # Node parameters:\n        if type(d_base) is list:\n            assert len(d_base) == self.N_nodes, \"Length of d_base not equal to node number!\"\n            d_vect = d_base\n        else:\n            d_vect = [d_base for i in range(self.N_nodes)]\n\n        # Edge parameters:\n        if type(n_base) is list:\n            assert len(n_base) == self.N_edges, \"Length of n_base not equal to edge number!\"\n            n_vect = n_base\n        else:\n            n_vect = [n_base for i in range(self.N_edges)]\n\n        if type(beta_base) is list:\n            assert len(beta_base) == self.N_edges, \"Length of n_base not equal to edge number!\"\n            beta_vect = beta_base\n        else:\n            beta_vect = [beta_base for i in range(self.N_edges)]\n\n        return d_vect, n_vect, beta_vect\n\n    def create_numerical_dcdt(self,\n                              constrained_inds: list | None = None,\n                              constrained_vals: list | None = None):\n        '''\n\n        '''\n        # First, lambdify the change vector in a way that supports any constraints:\n        if constrained_inds is None or constrained_vals is None:\n            # Compute the symbolic Jacobian:\n            dcdt_jac_s = sp.Matrix(self._dcdt_vect_s).jacobian(self._c_vect_s) # analytical Jacobian\n\n            dcdt_vect_f = sp.lambdify((list(self._c_vect_s),\n                                       self._n_vect_s,\n                                       self._beta_vect_s,\n                                       self._d_vect_s),\n                                      self._dcdt_vect_s)\n\n            dcdt_jac_f = sp.lambdify((list(self._c_vect_s),\n                                      self._n_vect_s,\n                                      self._beta_vect_s,\n                                      self._d_vect_s),\n                                     dcdt_jac_s)\n\n\n        else: # If there are constraints split the p-vals into an arguments and to-solve set:\n            c_vect_args = (np.asarray(list(self._c_vect_s))[constrained_inds]).tolist()\n            unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds).tolist()\n            c_vect_solve = (np.asarray(list(self._c_vect_s))[unconstrained_inds]).tolist()\n\n            # truncate the change vector to only be for unconstrained inds:\n            dcdt_vect_s = np.asarray(self._dcdt_vect_s)[unconstrained_inds].tolist()\n\n            # Compute the symbolic Jacobian:\n            dcdt_jac_s = sp.Matrix(dcdt_vect_s).jacobian(c_vect_solve) # analytical Jacobian\n\n            dcdt_vect_f = sp.lambdify((c_vect_solve,\n                                       c_vect_args,\n                                       self._n_vect_s,\n                                       self._beta_vect_s,\n                                       self._d_vect_s),\n                                      dcdt_vect_s)\n\n            dcdt_jac_f = sp.lambdify((c_vect_solve,\n                                      c_vect_args,\n                                      self._n_vect_s,\n                                      self._beta_vect_s,\n                                      self._d_vect_s),\n                                     dcdt_jac_s)\n\n        return dcdt_vect_f, dcdt_jac_f\n\n    def get_function_args(self,\n                          constraint_vals: list|None=None,\n                          d_base: float|list[float]=1.0,\n                          n_base: float|list[float]=3.0,\n                          beta_base: float|list[float]=2.0):\n        '''\n\n        '''\n        d_vect, n_vect, beta_vect = self.make_numerical_params(d_base, n_base, beta_base)\n\n        if constraint_vals is not None:\n            function_args = (constraint_vals, n_vect, beta_vect, d_vect)\n\n        else:\n            function_args = (n_vect, beta_vect, d_vect)\n\n        return function_args\n\n\n    def generate_state_space(self,\n                             c_inds: list,\n                             N_space: int,\n                             ) -&gt; tuple[ndarray, list, ndarray]:\n        '''\n        Generate a discrete state space over the range of probabilities of\n        each individual gene in the network.\n        '''\n        c_lins = []\n\n        for i in c_inds:\n            c_lins.append(np.linspace(self.p_min, 1.0, N_space))\n\n        cGrid = np.meshgrid(*c_lins)\n\n        N_pts = len(cGrid[0].ravel())\n\n        cM = np.zeros((N_pts, self.N_nodes))\n\n        for i, cGrid in zip(c_inds, cGrid):\n            cM[:, i] = cGrid.ravel()\n\n        return cM, c_lins, cGrid\n\n    def solve_probability_equms(self,\n                                constraint_inds: list|None = None,\n                                constraint_vals: list|None = None,\n                                signal_constr_vals: list|None = None,\n                                d_base: float|list[float] = 1.0,\n                                n_base: float|list[float] = 15.0,\n                                beta_base: float|list[float] = 0.25,\n                                N_space: int = 2,\n                                search_tol: float=1.0e-15,\n                                sol_tol: float=1.0e-1,\n                                verbose: bool=True,\n                                save_file: str|None = None,\n                                return_saddles: bool = False,\n                                search_main_nodes_only: bool=False,\n                                node_num_max: int|None = None\n                                ):\n        '''\n        Solve for the equilibrium points of gene product probabilities in\n        terms of a given set of numerical parameters.\n        '''\n\n        # For any network, there may be nodes without regulation that require constraints\n        # (these are in self._constrained_nodes). Therefore, add these to any user-supplied\n        # constraints:\n        constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                            constraint_vals,\n                                                                            signal_constr_vals=signal_constr_vals)\n\n        dcdt_vect_f, dcdt_jac_f = self.create_numerical_dcdt(constrained_inds=constrained_inds,\n                                                             constrained_vals=constrained_vals)\n\n        if node_num_max is not None:\n            sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n            self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n\n        if constrained_inds is None or constrained_vals is None:\n            unconstrained_inds = self._nodes_index\n        else:\n            unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds).tolist()\n\n        if search_main_nodes_only is False:\n            M_pstates, _, _ = self.generate_state_space(unconstrained_inds, N_space)\n\n        else:\n            if len(self.main_nodes):\n                if node_num_max is None:\n                    M_pstates, _, _ = self.generate_state_space(self.main_nodes, N_space)\n                elif len(self.main_nodes) &lt; node_num_max:\n                    M_pstates, _, _ = self.generate_state_space(self.main_nodes, N_space)\n                else:\n                    M_pstates, _, _ = self.generate_state_space(self.influence_node_inds, N_space)\n\n            else:\n                raise Exception(\"No main nodes; cannot perform state search with \"\n                                \"search_main_nodes_only=True.\")\n\n        sol_Mo = []\n\n        function_args = self.get_function_args(constraint_vals=constrained_vals,\n                                               d_base=d_base,\n                                               n_base=n_base,\n                                               beta_base=beta_base)\n\n        self._function_args = function_args\n\n        for i, cvecto in enumerate(M_pstates): # for each test vector:\n            # get values for the genes we're solving for...\n            # Note: fsolve doesn't allow us to impose constraints so we need to push this initial guess\n            # quite far away from zero with the added constant:\n            c_vect_sol = cvecto[unconstrained_inds] + self._push_away_from_zero\n            sol_roots = fsolve(dcdt_vect_f,\n                               c_vect_sol,\n                               args=function_args,\n                               xtol=search_tol,\n                               fprime=dcdt_jac_f,\n                               col_deriv=False,\n                               )\n\n            # Find any roots below zero and constrain them to 0.0:\n            sol_roots[(sol_roots &lt;= 0.0).nonzero()] = self.p_min\n\n            c_eqms = np.zeros(self.N_nodes)\n            c_eqms[unconstrained_inds] = sol_roots\n\n            if constrained_inds is not None and constrained_vals is not None:\n                c_eqms[constrained_inds] = constrained_vals\n\n            # c_eqms = self.multiround(c_eqms)\n\n            sol_Mo.append(c_eqms)\n\n        # _, unique_inds = np.unique(np.round(sol_Mo, 2), axis=0, return_index=True)\n        _, unique_inds = np.unique(self.multiround(np.asarray(sol_Mo)), axis=0, return_index=True)\n\n        sol_M = np.asarray(sol_Mo)[unique_inds]\n\n        stable_sol_M, sol_M_char = self.find_attractor_sols(sol_M,\n                                                             dcdt_vect_f,\n                                                             dcdt_jac_f,\n                                                             function_args,\n                                                             constrained_inds=constrained_inds,\n                                                             tol= sol_tol,\n                                                             verbose = verbose,\n                                                             save_file = save_file,\n                                                             return_saddles=return_saddles)\n\n        return stable_sol_M, sol_M_char, sol_M\n    def find_attractor_sols(self,\n                             sols_0: ndarray,\n                             dcdt_vect_f: Callable,\n                             jac_f: Callable,\n                             func_args: tuple|list,\n                             constrained_inds: list | None = None,\n                             tol: float=1.0e-1,\n                             verbose: bool=True,\n                             save_file: str|None = None,\n                             return_saddles: bool = False\n                             ):\n        '''\n\n        '''\n\n        eps = 1.0e-20 # Small value to avoid divide-by-zero in the jacobian\n\n        sol_dicts_list = []\n\n        if constrained_inds is None:\n            unconstrained_inds = self._nodes_index\n\n        else:\n            unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds)\n\n        for pminso in sols_0:\n\n            solution_dict = {}\n\n            solution_dict['Minima Values'] = pminso\n\n            pmins = pminso + eps # add the small amount here, before calculating the jacobian\n\n            solution_dict['Change at Minima'] = dcdt_vect_f(pmins[unconstrained_inds], *func_args)\n\n            jac = jac_f(pmins[unconstrained_inds], *func_args)\n            # get the eigenvalues of the jacobian at this equillibrium point:\n            eig_valso, eig_vects = np.linalg.eig(jac)\n\n            # round the eigenvalues so we don't have issue with small imaginary components\n            eig_vals = np.round(np.real(eig_valso), 1) + np.round(np.imag(eig_valso), 1) * 1j\n\n            solution_dict['Jacobian Eigenvalues'] = eig_vals\n            # print(eig_vals)\n\n            # get the indices of eigenvalues that have only real components:\n            real_eig_inds = (np.imag(eig_vals) == 0.0).nonzero()[0]\n\n            # If all eigenvalues are real and they're all negative then its an attractor:\n            if len(real_eig_inds) == len(eig_vals) and np.all(np.real(eig_vals) &lt;= 0.0):\n                char_tag = EquilibriumType.attractor.name\n\n            # If all eigenvalues are real and they're all positive then its a repellor:\n            elif len(real_eig_inds) == len(eig_vals) and np.all(np.real(eig_vals) &gt; 0.0):\n                char_tag = EquilibriumType.repellor.name\n\n            # If all eigenvalues are real and they're a mix of positive and negative, then it's a saddle:\n            elif len(real_eig_inds) == len(eig_vals) and np.any(np.real(eig_vals[real_eig_inds] &gt; 0.0)):\n                char_tag = EquilibriumType.saddle.name\n\n            # If there are imaginary eigenvalue components and all real components are less than zero we\n            # have a stable limit cycle:\n            elif np.any(np.imag(eig_vals) != 0.0) and np.all(np.real(eig_vals) &lt;= 0.0):\n                char_tag = EquilibriumType.attractor_limit_cycle.name\n\n            # If there are imaginary eigenvalue components and all real components are less than zero we\n            # have a stable limit cycle:\n            elif np.any(np.imag(eig_vals) != 0.0) and np.all(np.real(eig_vals) &gt; 0.0):\n                char_tag = EquilibriumType.repellor_limit_cycle.name\n\n            # If there are imaginary eigenvalues and a mix of real component signs, we only know its a limit cycle but can't say\n            # anything certain about stability:\n            elif np.any(np.imag(eig_vals) != 0.0) and np.any(np.real(eig_vals) &gt; 0.0):\n                char_tag = EquilibriumType.limit_cycle.name\n\n            else:\n                char_tag = EquilibriumType.undetermined.name\n\n            solution_dict['Stability Characteristic'] = char_tag\n\n            sol_dicts_list.append(solution_dict)\n\n        solsM = []\n        sol_char_list = []\n        sol_char_error = []\n        i = 0\n        for sol_dic in sol_dicts_list:\n            # print(\"Computing the reporting stuff\")\n            error = np.sum(np.asarray(sol_dic['Change at Minima'])**2)\n            char = sol_dic['Stability Characteristic']\n            sols = sol_dic['Minima Values']\n\n            if return_saddles is False:\n                if char is not EquilibriumType.saddle.name and error &lt;= tol:\n                    i += 1\n                    if verbose:\n                        print(f'Soln {i}, {char}, {np.round(sols, 2)}, {np.round(error, 4)}')\n                    solsM.append(sols)\n                    sol_char_list.append(char)\n                    sol_char_error.append(error)\n            else:\n                if error &lt;= tol:\n                    i += 1\n                    if verbose:\n                        print(f'Soln {i}, {char}, {np.round(sols, 2)}, {np.round(error, 4)}')\n                    solsM.append(sols)\n                    sol_char_list.append(char)\n                    sol_char_error.append(error)\n\n        solsM_return = np.asarray(solsM).T\n        sol_char_list_return = np.asarray(sol_char_list).T\n\n        if save_file is not None:\n            solsMi = np.asarray(solsM)\n            header = [f'State {i}' for i in range(solsMi.shape[0])]\n            with open(save_file, 'w', newline=\"\") as file:\n                csvwriter = csv.writer(file)  # create a csvwriter object\n                csvwriter.writerow(header)  # write the header\n                csvwriter.writerow(sol_char_error)  # write the root error at steady-state\n                csvwriter.writerow(sol_char_list)  # write the attractor characterization\n                for si in solsMi.T:\n                    csvwriter.writerow(si)  # write the soln data rows for each gene\n\n        return solsM_return, sol_char_list_return\n\n    def _handle_constrained_nodes(self,\n                                  constr_inds: list | None,\n                                  constr_vals: list[float] | None,\n                                  signal_constr_vals: list[float] | None = None\n                                  ) -&gt; tuple[list, list]:\n        '''\n        Networks will often have nodes without regulation that need to\n        be constrained during optimization. This helper-method augments\n        these naturally-occuring nodes with any additional constraints\n        supplied by the user.\n        '''\n        len_constr = len(self.input_node_inds)\n\n        if signal_constr_vals is None: # default to zero\n            sig_vals = (self.p_min*np.ones(len_constr)).tolist()\n        else:\n            sig_vals = signal_constr_vals\n\n        if len_constr != 0:\n            if constr_inds is None or constr_vals is None:\n                constrained_inds = self.input_node_inds.copy()\n                constrained_vals = sig_vals\n            else:\n                constrained_inds = constr_inds + self.input_node_inds.copy()\n                constrained_vals = constr_vals + sig_vals\n        else:\n            if constr_inds is None or constr_vals is None:\n                constrained_inds = []\n                constrained_vals = []\n\n            else:\n                constrained_inds = constr_inds*1\n                constrained_vals = constr_vals*1\n\n        return constrained_inds, constrained_vals\n\n\n    def run_time_sim(self,\n                     tvect: ndarray|list,\n                     tvectr: ndarray|list,\n                     cvecti: ndarray|list,\n                     sig_inds: ndarray|list|None = None,\n                     sig_vals: list | ndarray | lil_array| None = None,\n                     constrained_inds: list | None = None,\n                     constrained_vals: list | None = None,\n                     d_base: float|list[float] = 1.0,\n                     n_base: float|list[float] = 15.0,\n                     beta_base: float|list[float] = 0.25\n                     ):\n        '''\n\n        '''\n\n        dt = tvect[1] - tvect[0]\n\n        if sig_inds is None or sig_vals is None:\n            sig_inds = []\n            sig_vals = []\n\n        concs_time = []\n\n        dcdt_vect_f, dcdt_jac_f = self.create_numerical_dcdt(constrained_inds=constrained_inds,\n                                                             constrained_vals=constrained_vals)\n\n        function_args = self.get_function_args(constraint_vals=constrained_vals,\n                                               d_base=d_base,\n                                               n_base=n_base,\n                                               beta_base=beta_base)\n\n        for ti, tt in enumerate(tvect):\n            dcdt = np.asarray(dcdt_vect_f(cvecti, *function_args))\n            cvecti += dt * dcdt\n\n            # manually set the signal node values:\n            if type(sig_vals) is lil_array:\n                cvecti[sig_inds] = sig_vals[ti, sig_inds].toarray()\n            else:\n                cvecti[sig_inds] = sig_vals[ti, sig_inds]\n\n            if tt in tvectr:\n                concs_time.append(cvecti * 1)\n\n        concs_time = np.asarray(concs_time)\n\n        return concs_time\n\n    def get_visual_equations(self):\n        '''\n\n        '''\n        c_vect_viz = []\n        subs_list = []\n        self._subs_syms_list = []\n        for pi, nde_lab in zip(self._c_vect_s, self.nodes_list):\n            nde_sym = sp.symbols(str(nde_lab))\n            c_vect_viz.append(nde_sym)\n            subs_list.append((pi, nde_sym))\n            self._subs_syms_list.append(nde_sym)\n\n        for ei, (nij, bij) in enumerate(zip(self._n_vect_s, self._beta_vect_s)):\n            b_sym = sp.symbols(f'beta_{ei}')\n            n_sym = sp.symbols(f'n_{ei}')\n            subs_list.append((bij, b_sym))\n            subs_list.append((nij, n_sym))\n            self._subs_syms_list.append(b_sym)\n            self._subs_syms_list.append(n_sym)\n\n        for ndei, di in enumerate(self._d_vect_s):\n            d_sym = sp.symbols(f'd_{ndei}')\n            subs_list.append((di, d_sym))\n            self._subs_syms_list.append(d_sym)\n\n        dcdt_vect_s_viz = sp.Matrix(self._dcdt_vect_s).subs(subs_list)\n\n        return c_vect_viz, dcdt_vect_s_viz\n\n\n    def save_model_equations(self,\n                             save_eqn_image: str,\n                             save_reduced_eqn_image: str|None = None,\n                             save_eqn_csv: str|None = None,\n                             substitute_node_labels: bool = True\n                             ):\n        '''\n        Save images of the model equations, as well as a csv file that has\n        model equations written in LaTeX format.\n\n        Parameters\n        -----------\n        save_eqn_image : str\n            The path and filename to save the main model equations as an image.\n\n        save_reduced_eqn_image : str|None = None\n            The path and filename to save the reduced main model equations as an image (if model is reduced).\n\n        save_eqn_csv : str|None = None\n            The path and filename to save the main and reduced model equations as LaTex in a csv file.\n\n        '''\n\n        if substitute_node_labels:\n            subs_list = []\n            for pi, nde_lab in zip(self._c_vect_s, self.nodes_list):\n                nde_sym = sp.symbols(nde_lab)\n                subs_list.append((pi, nde_sym))\n\n            for ei, (nij, bij) in enumerate(zip(self._n_vect_s, self._beta_vect_s)):\n                b_sym = sp.symbols(f'beta_{ei}')\n                n_sym = sp.symbols(f'n_{ei}')\n                subs_list.append((bij, b_sym))\n                subs_list.append((nij, n_sym))\n\n            for ndei, di in enumerate(self._d_vect_s):\n                d_sym = sp.symbols(f'd_{ndei}')\n                subs_list.append((di, d_sym))\n\n            _dcdt_vect_s = list(sp.Matrix(self._dcdt_vect_s).subs(subs_list))\n            _c_vect_s = list(sp.Matrix(self._c_vect_s).subs(subs_list))\n\n            if self._dcdt_vect_reduced_s is not None:\n                _dcdt_vect_reduced_s = list(sp.Matrix(self._dcdt_vect_reduced_s).subs(subs_list))\n                _c_vect_reduced_s = list(sp.Matrix(self._c_vect_reduced_s).subs(subs_list))\n\n        else:\n            _dcdt_vect_s = self._dcdt_vect_s\n            _c_vect_s = self._c_vect_s\n\n            if self._dcdt_vect_reduced_s is not None:\n                _dcdt_vect_reduced_s = self._dcdt_vect_reduced_s\n                _c_vect_reduced_s = self._c_vect_reduced_s\n\n\n        t_s = sp.symbols('t')\n        c_change = sp.Matrix([sp.Derivative(ci, t_s) for ci in _c_vect_s])\n        eqn_net = sp.Eq(c_change, sp.Matrix(_dcdt_vect_s))\n\n        sp.preview(eqn_net,\n                   viewer='file',\n                   filename=save_eqn_image,\n                   euler=False,\n                   dvioptions=[\"-T\", \"tight\", \"-z\", \"0\", \"--truecolor\", \"-D 600\", \"-bg\", \"Transparent\"])\n\n        # Save the equations for the graph to a file:\n        header = ['Concentrations', 'Change Vector']\n        eqns_to_write = [[sp.latex(_c_vect_s), sp.latex(_dcdt_vect_s)]]\n\n        if self._dcdt_vect_reduced_s is not None and save_reduced_eqn_image is not None:\n            c_change_reduced = sp.Matrix([sp.Derivative(ci, t_s) for ci in _c_vect_reduced_s])\n            eqn_net_reduced = sp.Eq(c_change_reduced, _dcdt_vect_reduced_s)\n\n            sp.preview(eqn_net_reduced,\n                       viewer='file',\n                       filename=save_reduced_eqn_image,\n                       euler=False,\n                       dvioptions=[\"-T\", \"tight\", \"-z\", \"0\", \"--truecolor\", \"-D 600\", \"-bg\", \"Transparent\"])\n\n            eqns_to_write.append(sp.latex(_c_vect_reduced_s))\n            eqns_to_write.append(sp.latex(_dcdt_vect_reduced_s))\n            header.extend(['Reduced Concentations', 'Reduced Change Vector'])\n\n        if save_eqn_csv is not None:\n            with open(save_eqn_csv, 'w', newline=\"\") as file:\n                csvwriter = csv.writer(file)  # 2. create a csvwriter object\n                csvwriter.writerow(header)  # 4. write the header\n                csvwriter.writerows(eqns_to_write)  # 5. write the rest of the data\n\n    # ----Methods for Analytical Models--------\n    def reduce_model_dimensions(self, use_nonlinsolve: bool = False):\n        '''\n        Using analytical methods, attempt to reduce the multidimensional\n        network equations to as few equations as possible.\n\n        '''\n\n        # Solve the nonlinear system as well as is possible:\n        nosol = False\n\n        # We want to restrict this model reduction to homogeneous networks that\n        # only contain genes and signals.\n        if len(self.process_node_inds) or self._inter_fun_type is InterFuncType.logistic:\n            print(\"System unsolvable due to use of logistic interaction function. Try Hill-type equations.\")\n            nosol = True  # Immediately flag the sysem as unsolvable\n\n        else:\n\n            try:\n                if use_nonlinsolve:\n                    sol_csetoo = sp.nonlinsolve(self._dcdt_vect_s,\n                                                self._c_vect_s[self.noninput_node_inds.tolist(), :])\n\n                else:\n                    sol_csetoo = sp.solve(self._dcdt_vect_s,\n                                          self._c_vect_s[self.noninput_node_inds.tolist(), :])\n                # Clean up the sympy container for the solutions:\n                sol_cseto = list(list(sol_csetoo)[0])\n\n                if len(sol_cseto):\n\n                    c_master_i = []  # the indices of concentrations involved in the master equations (the reduced dims)\n                    sol_cset = {}  # A dictionary of auxillary solutions (plug and play)\n                    for i, c_eq in enumerate(sol_cseto):\n                        if c_eq in self._c_vect_s:  # If it's a non-solution for the term, append it as a non-reduced conc.\n                            c_master_i.append(self._c_vect_s.index(c_eq))\n                        else:  # Otherwise append the plug-and-play solution set:\n                            sol_cset[self._c_vect_s[self.noninput_node_inds.tolist(), :][i]] = c_eq\n\n                    master_eq_list = []  # master equations to be numerically optimized (reduced dimension network equations)\n                    c_vect_reduced = []  # concentrations involved in the master equations\n\n                    if len(c_master_i):\n                        for ii in c_master_i:\n                            # substitute in the expressions in terms of master concentrations to form the master equations:\n                            ci_solve_eq = self._dcdt_vect_s[ii].subs([(k, v) for k, v in sol_cset.items()])\n                            master_eq_list.append(ci_solve_eq)\n                            c_vect_reduced.append(self._c_vect_s[ii])\n\n                    else:  # if there's nothing in c_master_i but there are solutions in sol_cseto, then it's been fully solved:\n                        print(\"The system has been fully solved by analytical methods!\")\n                        self._solved_analytically = True\n\n                else:\n                    print(\"No solutions found for the system.\")\n                    nosol = True\n\n            except:\n                print(\"Exception called in Sympy.\")\n                nosol = True\n\n        # Results:\n        if nosol is True:\n            self._reduced_dims = False\n            print(\"Unable to reduce equations!\")\n            # Set all reduced system attributes to None:\n            self._dcdt_vect_reduced_s = None\n            self._c_vect_reduced_s = None\n            self.c_master_i = None\n            self.c_remainder_i = None\n            self.c_vect_remainder_s = None\n            # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n            # such that when the master equation set is solved, the results are plugged into the equations in this\n            # dictionary to obtain solutions for the whole network\n            self.sol_cset_s = None\n\n            self.signal_reduced_inds = None\n            self.nonsignal_reduced_inds = None\n\n        else:  # If we have solutions, proceed:\n            self._reduced_dims = True\n\n            if self._solved_analytically is False:\n                # New equation list to be numerically optimized (should be significantly reduced dimensions):\n                # Note: this vector is no longer the change rate vector; its now solving for concentrations\n                # where the original rate change vector is zero:\n                self._dcdt_vect_reduced_s = sp.Matrix(master_eq_list)\n                # This is the concentration vector that contains the reduced equation concentration variables:\n                self._c_vect_reduced_s = c_vect_reduced\n                self.c_master_i = c_master_i  # indices of concentrations that are being numerically optimized\n                self.c_remainder_i = np.setdiff1d(self.nodes_index, self.c_master_i)  # remaining conc indices\n                self.c_vect_remainder_s = np.asarray(self._c_vect_s)[self.c_remainder_i].tolist()  # remaining concs\n\n                # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n                # such that when the master equation set is solved, the results are plugged into the equations in this\n                # dictionary to obtain solutions for the whole network:\n                self.sol_cset_s = sol_cset\n\n                # Create a set of signal node indices to the reduced c_vect array:\n                self.signal_reduced_inds = []\n                for si in self.input_node_inds:\n                    if si in self.c_master_i:\n                        self.signal_reduced_inds.append(self.c_master_i.index(si))\n\n                self.nonsignal_reduced_inds = np.setdiff1d(np.arange(len(self.c_master_i)),\n                                                           self.signal_reduced_inds)\n\n            else:\n                # Set most reduced system attributes to None:\n                self._dcdt_vect_reduced_s = None\n                self._c_vect_reduced_s = None\n                self.c_master_i = None\n                self.c_remainder_i = None\n                self.c_vect_remainder_s = None\n                self.signal_reduced_inds = None\n                self.nonsignal_reduced_inds = None\n\n                # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n                # such that when the master equation set is solved, the results are plugged into the equations in this\n                # dictionary to obtain solutions for the whole network:\n                self.sol_cset_s = sol_cset\n\n                # The sol_cset exists and can be lambdified for full solutions. Here we lambdify it without the c_vect:\n                if len(self.process_node_inds):\n                    lambda_params_r = [self._d_vect_s,\n                                       self._beta_vect_s,\n                                       self._n_vect_s,\n                                       self._c_vect_s[self.input_node_inds, :],\n                                       self.extra_params_s]\n\n                else:\n                    lambda_params_r = [self._d_vect_s,\n                                       self._beta_vect_s,\n                                       self._n_vect_s,\n                                       self._c_vect_s[self.input_node_inds, :]]\n\n                self.sol_cset_f = {}\n                for ci, eqci in self.sol_cset_s.items():\n                    # self.sol_cset_f[ci.indices[0]] = sp.lambdify(lambda_params_r, eqci)\n                    self.sol_cset_f[ci] = sp.lambdify(lambda_params_r, eqci)\n\n    # ----Time Dynamics Methods----------------\n    def pulses(self,\n               tvect: list | ndarray,\n               t_on: float | int,\n               t_off: float | int,\n               c_base: float | int = 1.0,\n               c_active: float | int = 0.0,\n               ):\n        '''\n\n        '''\n        itop = (tvect &gt;= t_on).nonzero()[0]\n        ibot = (tvect &lt;= t_off).nonzero()[0]\n\n        ipulse = np.intersect1d(ibot, itop)\n\n        pulse_sig = c_active * np.ones(len(tvect))\n\n        pulse_sig[ipulse] = c_base\n\n        return pulse_sig\n\n    def get_interval_inds(self,\n                          tvect: ndarray,\n                          t_on: float,\n                          t_off: float,\n                          t_wait: float = 0.0\n                          ):\n        '''\n        Returns indices specifying an interval from the\n        supplied vector tvect spanning between vector\n        values t_on and t_off.\n\n        Parameters\n        ----------\n        t_vect : ndarray\n            The vector to pull the interval from.\n\n        t_on : float\n            The first value in the vector defining the interval start.\n\n        t_off : float\n            The value in the vector defining the interval end.\n\n        t_wait: float\n            The amount of time to push up the start of the interval from\n            t_on (which is useful if you're waiting for the system to get\n            back to steady-state).\n\n        '''\n        itop = (tvect &gt;= t_on + t_wait).nonzero()[0]\n        ibot = (tvect &lt;= t_off).nonzero()[0]\n\n        ipulse_inds = np.intersect1d(ibot, itop)\n\n        return ipulse_inds\n\n    def make_pulsed_signals_matrix(self,\n                                   tvect: list | ndarray,\n                                   sig_inds: list | ndarray,\n                                   sig_times: list | ndarray,\n                                   sig_mag: list | ndarray):\n        '''\n\n        '''\n        Nt = len(tvect)\n\n        c_signals = np.zeros((Nt, self.N_nodes))  # Initialize matrix holding the signal sequences\n\n        for si, (ts, te), (smin, smax) in zip(sig_inds, sig_times, sig_mag):\n            c_signals[:, si] += self.pulses(tvect,\n                                            ts,\n                                            te,\n                                            c_base=smax,\n                                            c_active=smin\n                                            )\n\n        return c_signals\n\n    def get_all_intervals(self,\n                          tvect: ndarray,\n                          sig_times: list | ndarray,\n                          t_wait: float = 0.0,\n                          add_end_intervals: bool = True\n                          ):\n        '''\n\n        '''\n        intervals_set = set()  # Initialize set to hold the interval indices\n\n        # sig_times = sorted(sig_times) # sort the time tuples by their start time\n        sig_times.sort(key=lambda x: x[0])  # sort the time tuples by their start time\n\n        for ts, te in sig_times:\n            inti = self.get_interval_inds(tvect,\n                                          ts,\n                                          te,\n                                          t_wait=t_wait\n                                          )\n\n            if len(inti):\n                intervals_set.add((inti[0], inti[-1]))\n\n        if add_end_intervals:\n            # Add a start interval\n            intis = self.get_interval_inds(tvect,\n                                           tvect[0],\n                                           sig_times[0][0],\n                                           t_wait=t_wait\n                                           )\n            if len(intis):\n                intervals_set.add((intis[0], intis[-1]))\n\n            # Add an end interval:\n            intie = self.get_interval_inds(tvect,\n                                           sig_times[-1][1],\n                                           tvect[-1],\n                                           t_wait=t_wait\n                                           )\n            if len(intie):\n                intervals_set.add((intie[0], intie[-1]))\n\n        intervals_list = list(intervals_set)\n        intervals_list.sort(key=lambda x: x[0])  # sort the time tuples by their start time\n\n        return intervals_list\n\n    def make_time_vects(self,\n                        tend: float,\n                        dt: float,\n                        dt_samp: float | None = None, ):\n        '''\n\n        '''\n        Nt = int(tend / dt)\n        tvect = np.linspace(0.0, tend, Nt)\n\n        # sampling compression\n        if dt_samp is not None:\n            sampr = int(dt_samp / dt)\n            tvectr = tvect[0::sampr]\n        else:\n            tvectr = tvect\n\n        # make a time-step update vector so we can update any sensors as\n        # an absolute reading (dt = 1.0) while treating the kinetics of the\n        # other node types:\n        # dtv = dt * np.ones(self._N_nodes)\n        # dtv[self.sensor_node_inds] = 1.0\n\n        return tvect, tvectr\n\n\n    def multiround(self, cc):\n        '''\n        Perform a rounding procedure to 1/(node_expression_levels - 1) level of resolution.\n        For example, if node_expression_levels = 5.0, then this will round values to 0.0, 0.25, 0.5, 0.75, and 1.0.\n        '''\n        cc = np.round(cc * (self._node_expression_levels - 1)) / (self._node_expression_levels - 1)\n\n        return cc\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.__init__","title":"<code>__init__(N_nodes, interaction_function_type=InterFuncType.logistic, node_expression_levels=5.0)</code>","text":"<p>Initialize the ProbabilityNet class.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def __init__(self,\n             N_nodes: int,\n             interaction_function_type: InterFuncType = InterFuncType.logistic,\n             node_expression_levels: float=5.0):\n    '''\n    Initialize the ProbabilityNet class.\n\n    '''\n\n    self.N_nodes = N_nodes\n    self._nodes_index = [i for i in range(self.N_nodes)]\n    self.regular_node_inds = self._nodes_index\n    self.nodes_list = [f'G{i}' for i in range(self.N_nodes)]\n\n    # Initialize some object state variables:\n    self._reduced_dims = False # Indicate that model is full dimensions\n    self._solved_analytically = False # Indicate that the model does not have an analytical solution\n    self._dcdt_vect_reduced_s = None # Initialize this to None\n    self.process_params_s = []  # initialize this to be an empty list\n    self.edge_types = None\n    self.edges_index = None\n\n    self.p_min = 1.0e-6 # small nonzero element for working with Hill versions\n    self._push_away_from_zero = self.p_min # smallish constant to push initial guess of fsolve away from zero\n\n    super().__init__()  # Initialize the base class\n\n    self._inter_fun_type = interaction_function_type\n\n    if node_expression_levels &lt;= 1:\n        raise Exception(\"Node expression levels must be greater than 1!\")\n    self._node_expression_levels = node_expression_levels\n\n    # Matrix Equations:\n    # Matrix symbols to construct matrix equation bases:\n    self._M_n_so = sp.MatrixSymbol('M_n', self.N_nodes, self.N_nodes)\n    self._M_beta_so = sp.MatrixSymbol('M_beta', self.N_nodes, self.N_nodes)\n    self._M_p_so = sp.MatrixSymbol('M_p', self.N_nodes, self.N_nodes)\n\n    # Define symbolic adjacency matrices to use as masks in defining multi and add matrices:\n    self._A_add_so = sp.MatrixSymbol('A_add', N_nodes, N_nodes)\n    self._A_mul_so = sp.MatrixSymbol('A_mul', N_nodes, N_nodes)\n\n    # Now we can define symbolic matrices that use the add and mul adjacencies to mask which\n    # n-parameters to use:\n    M_n_add_so = sp.hadamard_product(self._A_add_so, self._M_n_so)\n    M_n_mul_so = sp.hadamard_product(self._A_mul_so, self._M_n_so)\n\n    # And functions can be plugged in as matrix equations; these are the fundamental\n    # model building functions:\n    if self._inter_fun_type is InterFuncType.hill:\n        # For Hill Functions:\n        self._M_funk_add_so = sp.Matrix(N_nodes, N_nodes,\n                                  lambda i, j: 1 / (1 + (self._M_beta_so[j, i] * self._M_p_so[j, i]) ** -M_n_add_so[j, i]))\n        self._M_funk_mul_so = sp.Matrix(N_nodes, N_nodes,\n                                  lambda i, j: 1 / (1 + (self._M_beta_so[j, i] * self._M_p_so[j, i]) ** -M_n_mul_so[j, i]))\n    else:\n        # For Logistic Functions:\n        self._M_funk_add_so = sp.Matrix(N_nodes, N_nodes,\n                                  lambda i, j: 1 / (1 + sp.exp(-M_n_add_so[j, i] * (self._M_p_so[j, i] -\n                                                                                    self._M_beta_so[j, i]))))\n        self._M_funk_mul_so = sp.Matrix(N_nodes, N_nodes,\n                                  lambda i, j: 1 / (1 + sp.exp(-M_n_mul_so[j, i] * (self._M_p_so[j, i] -\n                                                                                    self._M_beta_so[j, i]))))\n\n    # Symbolic model parameters:\n    self._d_s = sp.IndexedBase('d', shape=self.N_nodes, positive=True)  # Maximum rate of decay\n    self._p_s = sp.IndexedBase('p', shape=self.N_nodes, positive=True)  # Probability of gene product\n\n    # Vectorized node-parameters and variables:\n    self._d_vect_s = [self._d_s[i] for i in range(self.N_nodes)]  # maximum rate of decay for each node\n    self._c_vect_s = sp.Matrix([self._p_s[i] for i in range(self.N_nodes)])  # gene product probability for each node\n\n    self._beta_s = sp.IndexedBase('beta', shape=(self.N_nodes, self.N_nodes), positive=True)  # Hill centre\n    self._n_s = sp.IndexedBase('n', shape=(self.N_nodes, self.N_nodes), positive=True)  # Hill coupling\n\n    # Create a matrix out of the n_s symbols:\n    self._M_n_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                            lambda i, j: self._n_s[i, j])\n\n    self._M_beta_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                               lambda i, j: self._beta_s[i, j])\n\n    # Define vector of ones to use in matrix operations:\n    self._ones_vect = sp.ones(1, self.N_nodes)\n\n    # Create a matrix that allows us to access the concentration vectors\n    # duplicated along columns:\n    self._M_p_s = self._c_vect_s * self._ones_vect\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.build_adjacency_from_edge_type_list","title":"<code>build_adjacency_from_edge_type_list(edge_types, edges_index, coupling_type=CouplingType.specified)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def build_adjacency_from_edge_type_list(self,\n                    edge_types: list[EdgeType],\n                    edges_index: list[tuple[int,int]],\n                    coupling_type: CouplingType=CouplingType.specified):\n    '''\n\n    '''\n    A_full_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n    A_add_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n    A_mul_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n    # Build A_full_s, an adjacency matrix that doesn't distinguish between additive\n    # and multiplicative interactions:\n    for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n        if etype is EdgeType.A or etype is EdgeType.As:\n            A_full_s[nde_i, nde_j] = 1\n        elif etype is EdgeType.I or etype is EdgeType.Is:\n            A_full_s[nde_i, nde_j] = -1\n\n    for ei, ((nde_i, nde_j), etype) in enumerate(zip(edges_index, edge_types)):\n        if coupling_type is CouplingType.specified:\n            if etype is EdgeType.I:\n                A_add_s[nde_i, nde_j] = -1\n            elif etype is EdgeType.A:\n                A_add_s[nde_i, nde_j] = 1\n            elif etype is EdgeType.Is:\n                A_mul_s[nde_i, nde_j] = -1\n            elif etype is EdgeType.As:\n                A_mul_s[nde_i, nde_j] = 1\n\n        elif coupling_type is CouplingType.additive:\n            if etype is EdgeType.I or etype is EdgeType.Is:\n                A_add_s[nde_i, nde_j] = -1\n            elif etype is EdgeType.A or etype is EdgeType.As:\n                A_add_s[nde_i, nde_j] = 1\n\n        elif coupling_type is CouplingType.multiplicative:\n            if etype is EdgeType.I or etype is EdgeType.Is:\n                A_mul_s[nde_i, nde_j] = -1\n            elif etype is EdgeType.A or etype is EdgeType.As:\n                A_mul_s[nde_i, nde_j] = 1\n\n        elif coupling_type is CouplingType.mix1:\n            if etype is EdgeType.A or etype is EdgeType.As:\n                A_add_s[nde_i, nde_j] = 1\n            elif etype is EdgeType.I or etype is EdgeType.Is:\n                A_mul_s[nde_i, nde_j] = -1\n\n    A_add_s = sp.Matrix(A_add_s)\n    A_mul_s = sp.Matrix(A_mul_s)\n    A_full_s = sp.Matrix(A_full_s)\n\n    return A_add_s, A_mul_s, A_full_s\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.build_analytical_model","title":"<code>build_analytical_model(A_add_s, A_mul_s)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def build_analytical_model(self,\n             A_add_s: MutableDenseMatrix,\n             A_mul_s: MutableDenseMatrix,\n                           ):\n    '''\n\n    '''\n\n    # Initialize a list of node indices that should be constrained (removed from solution searches)\n    # due to their lack of regulation:\n    self.input_node_inds = []\n\n    if A_add_s.shape != (self.N_nodes, self.N_nodes):\n        raise Exception(\"Shape of A_add_s is not in terms of network node number!\")\n\n    if A_mul_s.shape != (self.N_nodes, self.N_nodes):\n        raise Exception(\"Shape of A_add_s is not in terms of network node number!\")\n\n    M_funk_add_si = self._M_funk_add_so.subs(\n        [(self._M_p_so, self._M_p_s),\n         (self._M_n_so, self._M_n_s),\n         (self._M_beta_so, self._M_beta_s),\n         (self._A_add_so, A_add_s)])\n\n    M_funk_mul_si = self._M_funk_mul_so.subs(\n        [(self._M_p_so, self._M_p_s),\n         (self._M_n_so, self._M_n_s),\n         (self._M_beta_so, self._M_beta_s),\n         (self._A_mul_so, A_mul_s)])\n\n    # Filter out the 1/2 terms and set to 0 (addiditive) or 1 (multiplicative):\n    M_funk_add_s = sp.Matrix(self.N_nodes, self.N_nodes, lambda i, j: sp.Piecewise(\n        (M_funk_add_si[i, j], M_funk_add_si[i, j] != sp.Rational(1, 2)),\n        (0, True)))\n\n    M_funk_mul_s = sp.Matrix(self.N_nodes, self.N_nodes, lambda i, j: sp.Piecewise(\n        (M_funk_mul_si[i, j], M_funk_mul_si[i, j] != sp.Rational(1, 2)),\n        (1, True)))\n\n    # As A_add_s is a signed adjacency matrix, we need to get the absolute value to count edges:\n    abs_A_add_s = sp.hadamard_product(A_add_s, A_add_s)\n\n    # Count the nodes interacting (on input) with each node:\n    n_add_edges_i = abs_A_add_s.T * self._ones_vect.T\n    # Correct for any zeros in the n_add_edges and create a normalization object:\n    self._n_add_edges = sp.Matrix(self.N_nodes, 1,\n                                  lambda i, j: sp.Piecewise((sp.Rational(1, n_add_edges_i[i, j]), n_add_edges_i[i, j] != 0),\n                                                      (1, True)))\n    add_terms_i = M_funk_add_s * self._ones_vect.T\n\n    # The add_terms need to be normalized to keep concentrations between 0 and 1:\n    self._add_terms = sp.hadamard_product(self._n_add_edges, add_terms_i)\n\n    self._mul_terms = sp.Matrix(np.prod(M_funk_mul_s, axis=1))\n\n    self._dcdt_vect_s = []\n    for i in range(self.N_nodes):\n        if self._add_terms[i] == 0 and self._mul_terms[i] == 1: # if there's no add term and no mul term\n            self._dcdt_vect_s.append(0) # set the rate of change of this unregulated node to zero\n            self.input_node_inds.append(i) # append this node to the list of nodes that should be constrained\n        elif self._add_terms[i] == 0 and self._mul_terms[i] != 1: # remove the null add term to avoid nulling all growth\n            self._dcdt_vect_s.append(self._d_vect_s[i] * self._mul_terms[i] -\n                                     self._c_vect_s[i] * self._d_vect_s[i])\n        else: # the node is a mix of additive and potential multiplicative regulation:\n            self._dcdt_vect_s.append(self._d_vect_s[i] * self._mul_terms[i] * self._add_terms[i] -\n                                     self._c_vect_s[i] * self._d_vect_s[i])\n\n    # This is an \"energy\" function to be minimized at the equilibrium points:\n    self._opti_s = (sp.Matrix(self._dcdt_vect_s).T * sp.Matrix(self._dcdt_vect_s))[0, 0]\n\n    # Create linearized lists of symbolic parameters that are needed to solve the model (exclude the\n    # zero entries of the M_n and M_beta matrices:\n    # FIXME: need to rebuild the graph model if edges index changes...\n    self._beta_vect_s = [self._beta_s[nde_i, nde_j] for nde_i, nde_j in self.edges_index]\n    self._n_vect_s = [self._n_s[nde_i, nde_j] for nde_i, nde_j in self.edges_index]\n\n    self._A_add_s = A_add_s\n    self._A_mul_s = A_mul_s\n\n    # get the \"regular\" nodes:\n    self.noninput_node_inds = np.setdiff1d(self.nodes_index, self.input_node_inds)\n\n    # As we scale-down all concentrations for additive interactions so that the\n    # concentration ranges between 0.0 and 1.0, we need to scale the out edge\n    # beta parameter for these scaled-down nodes so that they signal as they would in\n    # a fully dimensionalized model:\n    subs_list = []\n    for ei, (ndei, ndej) in enumerate(self.edges_index):\n        if self._n_add_edges[ndei] != 1:\n            if self._inter_fun_type is InterFuncType.logistic:\n                subs_list.append((self._beta_vect_s[ei],\n                                  self._beta_vect_s[ei] * self._n_add_edges[ndei]))\n            else:\n                subs_list.append((self._beta_vect_s[ei],\n                                  self._beta_vect_s[ei]/self._n_add_edges[ndei]))\n\n    self._dcdt_vect_s = list(sp.Matrix(self._dcdt_vect_s).subs(subs_list))\n\n    self.c_vect_s_viz, self.dcdt_vect_s_viz = self.get_visual_equations()\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.create_numerical_dcdt","title":"<code>create_numerical_dcdt(constrained_inds=None, constrained_vals=None)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def create_numerical_dcdt(self,\n                          constrained_inds: list | None = None,\n                          constrained_vals: list | None = None):\n    '''\n\n    '''\n    # First, lambdify the change vector in a way that supports any constraints:\n    if constrained_inds is None or constrained_vals is None:\n        # Compute the symbolic Jacobian:\n        dcdt_jac_s = sp.Matrix(self._dcdt_vect_s).jacobian(self._c_vect_s) # analytical Jacobian\n\n        dcdt_vect_f = sp.lambdify((list(self._c_vect_s),\n                                   self._n_vect_s,\n                                   self._beta_vect_s,\n                                   self._d_vect_s),\n                                  self._dcdt_vect_s)\n\n        dcdt_jac_f = sp.lambdify((list(self._c_vect_s),\n                                  self._n_vect_s,\n                                  self._beta_vect_s,\n                                  self._d_vect_s),\n                                 dcdt_jac_s)\n\n\n    else: # If there are constraints split the p-vals into an arguments and to-solve set:\n        c_vect_args = (np.asarray(list(self._c_vect_s))[constrained_inds]).tolist()\n        unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds).tolist()\n        c_vect_solve = (np.asarray(list(self._c_vect_s))[unconstrained_inds]).tolist()\n\n        # truncate the change vector to only be for unconstrained inds:\n        dcdt_vect_s = np.asarray(self._dcdt_vect_s)[unconstrained_inds].tolist()\n\n        # Compute the symbolic Jacobian:\n        dcdt_jac_s = sp.Matrix(dcdt_vect_s).jacobian(c_vect_solve) # analytical Jacobian\n\n        dcdt_vect_f = sp.lambdify((c_vect_solve,\n                                   c_vect_args,\n                                   self._n_vect_s,\n                                   self._beta_vect_s,\n                                   self._d_vect_s),\n                                  dcdt_vect_s)\n\n        dcdt_jac_f = sp.lambdify((c_vect_solve,\n                                  c_vect_args,\n                                  self._n_vect_s,\n                                  self._beta_vect_s,\n                                  self._d_vect_s),\n                                 dcdt_jac_s)\n\n    return dcdt_vect_f, dcdt_jac_f\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.edges_from_adjacency","title":"<code>edges_from_adjacency(A_add_s, A_mul_s)</code>","text":"<p>Returns edge type and edge index from adjacency matrices.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def edges_from_adjacency(self, A_add_s: MutableDenseMatrix, A_mul_s: MutableDenseMatrix):\n    '''\n    Returns edge type and edge index from adjacency matrices.\n    '''\n    edges_type = []\n    edges_index = []\n\n    A_full_s = A_add_s + A_mul_s\n    for i in range(self.N_nodes):\n        for j in range(self.N_nodes):\n            afull_ij = A_full_s[i,j]\n            if afull_ij != 0:\n                edges_index.append((i, j))\n                if A_add_s[i,j] &lt; 0:\n                    edges_type.append(EdgeType.I)\n                elif A_add_s[i,j] &gt; 0:\n                    edges_type.append(EdgeType.A)\n                elif A_mul_s[i,j] &lt; 0:\n                    edges_type.append(EdgeType.Is)\n                elif A_mul_s[i,j] &gt; 0:\n                    edges_type.append(EdgeType.As)\n                else:\n                    edges_type.append(EdgeType.N)\n\n    return edges_index, edges_type\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.find_attractor_sols","title":"<code>find_attractor_sols(sols_0, dcdt_vect_f, jac_f, func_args, constrained_inds=None, tol=0.1, verbose=True, save_file=None, return_saddles=False)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def find_attractor_sols(self,\n                         sols_0: ndarray,\n                         dcdt_vect_f: Callable,\n                         jac_f: Callable,\n                         func_args: tuple|list,\n                         constrained_inds: list | None = None,\n                         tol: float=1.0e-1,\n                         verbose: bool=True,\n                         save_file: str|None = None,\n                         return_saddles: bool = False\n                         ):\n    '''\n\n    '''\n\n    eps = 1.0e-20 # Small value to avoid divide-by-zero in the jacobian\n\n    sol_dicts_list = []\n\n    if constrained_inds is None:\n        unconstrained_inds = self._nodes_index\n\n    else:\n        unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds)\n\n    for pminso in sols_0:\n\n        solution_dict = {}\n\n        solution_dict['Minima Values'] = pminso\n\n        pmins = pminso + eps # add the small amount here, before calculating the jacobian\n\n        solution_dict['Change at Minima'] = dcdt_vect_f(pmins[unconstrained_inds], *func_args)\n\n        jac = jac_f(pmins[unconstrained_inds], *func_args)\n        # get the eigenvalues of the jacobian at this equillibrium point:\n        eig_valso, eig_vects = np.linalg.eig(jac)\n\n        # round the eigenvalues so we don't have issue with small imaginary components\n        eig_vals = np.round(np.real(eig_valso), 1) + np.round(np.imag(eig_valso), 1) * 1j\n\n        solution_dict['Jacobian Eigenvalues'] = eig_vals\n        # print(eig_vals)\n\n        # get the indices of eigenvalues that have only real components:\n        real_eig_inds = (np.imag(eig_vals) == 0.0).nonzero()[0]\n\n        # If all eigenvalues are real and they're all negative then its an attractor:\n        if len(real_eig_inds) == len(eig_vals) and np.all(np.real(eig_vals) &lt;= 0.0):\n            char_tag = EquilibriumType.attractor.name\n\n        # If all eigenvalues are real and they're all positive then its a repellor:\n        elif len(real_eig_inds) == len(eig_vals) and np.all(np.real(eig_vals) &gt; 0.0):\n            char_tag = EquilibriumType.repellor.name\n\n        # If all eigenvalues are real and they're a mix of positive and negative, then it's a saddle:\n        elif len(real_eig_inds) == len(eig_vals) and np.any(np.real(eig_vals[real_eig_inds] &gt; 0.0)):\n            char_tag = EquilibriumType.saddle.name\n\n        # If there are imaginary eigenvalue components and all real components are less than zero we\n        # have a stable limit cycle:\n        elif np.any(np.imag(eig_vals) != 0.0) and np.all(np.real(eig_vals) &lt;= 0.0):\n            char_tag = EquilibriumType.attractor_limit_cycle.name\n\n        # If there are imaginary eigenvalue components and all real components are less than zero we\n        # have a stable limit cycle:\n        elif np.any(np.imag(eig_vals) != 0.0) and np.all(np.real(eig_vals) &gt; 0.0):\n            char_tag = EquilibriumType.repellor_limit_cycle.name\n\n        # If there are imaginary eigenvalues and a mix of real component signs, we only know its a limit cycle but can't say\n        # anything certain about stability:\n        elif np.any(np.imag(eig_vals) != 0.0) and np.any(np.real(eig_vals) &gt; 0.0):\n            char_tag = EquilibriumType.limit_cycle.name\n\n        else:\n            char_tag = EquilibriumType.undetermined.name\n\n        solution_dict['Stability Characteristic'] = char_tag\n\n        sol_dicts_list.append(solution_dict)\n\n    solsM = []\n    sol_char_list = []\n    sol_char_error = []\n    i = 0\n    for sol_dic in sol_dicts_list:\n        # print(\"Computing the reporting stuff\")\n        error = np.sum(np.asarray(sol_dic['Change at Minima'])**2)\n        char = sol_dic['Stability Characteristic']\n        sols = sol_dic['Minima Values']\n\n        if return_saddles is False:\n            if char is not EquilibriumType.saddle.name and error &lt;= tol:\n                i += 1\n                if verbose:\n                    print(f'Soln {i}, {char}, {np.round(sols, 2)}, {np.round(error, 4)}')\n                solsM.append(sols)\n                sol_char_list.append(char)\n                sol_char_error.append(error)\n        else:\n            if error &lt;= tol:\n                i += 1\n                if verbose:\n                    print(f'Soln {i}, {char}, {np.round(sols, 2)}, {np.round(error, 4)}')\n                solsM.append(sols)\n                sol_char_list.append(char)\n                sol_char_error.append(error)\n\n    solsM_return = np.asarray(solsM).T\n    sol_char_list_return = np.asarray(sol_char_list).T\n\n    if save_file is not None:\n        solsMi = np.asarray(solsM)\n        header = [f'State {i}' for i in range(solsMi.shape[0])]\n        with open(save_file, 'w', newline=\"\") as file:\n            csvwriter = csv.writer(file)  # create a csvwriter object\n            csvwriter.writerow(header)  # write the header\n            csvwriter.writerow(sol_char_error)  # write the root error at steady-state\n            csvwriter.writerow(sol_char_list)  # write the attractor characterization\n            for si in solsMi.T:\n                csvwriter.writerow(si)  # write the soln data rows for each gene\n\n    return solsM_return, sol_char_list_return\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.generate_state_space","title":"<code>generate_state_space(c_inds, N_space)</code>","text":"<p>Generate a discrete state space over the range of probabilities of each individual gene in the network.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def generate_state_space(self,\n                         c_inds: list,\n                         N_space: int,\n                         ) -&gt; tuple[ndarray, list, ndarray]:\n    '''\n    Generate a discrete state space over the range of probabilities of\n    each individual gene in the network.\n    '''\n    c_lins = []\n\n    for i in c_inds:\n        c_lins.append(np.linspace(self.p_min, 1.0, N_space))\n\n    cGrid = np.meshgrid(*c_lins)\n\n    N_pts = len(cGrid[0].ravel())\n\n    cM = np.zeros((N_pts, self.N_nodes))\n\n    for i, cGrid in zip(c_inds, cGrid):\n        cM[:, i] = cGrid.ravel()\n\n    return cM, c_lins, cGrid\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.get_adjacency_randomly","title":"<code>get_adjacency_randomly(coupling_type=CouplingType.mix1, set_autoactivation=True)</code>","text":"<p>Return a randomly-generated full adjacency matrix.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def get_adjacency_randomly(self, coupling_type: CouplingType=CouplingType.mix1, set_autoactivation: bool=True):\n    '''\n    Return a randomly-generated full adjacency matrix.\n    '''\n    A_full_s = sp.Matrix(np.random.randint(-1, 2, size=(self.N_nodes, self.N_nodes)))\n\n    if set_autoactivation:\n        # Make it so that any diagonal elements are self-activating rather than self-inhibiting\n        A_full_s = sp.Matrix(self.N_nodes, self.N_nodes,\n                             lambda i,j: A_full_s[i,j]*A_full_s[i,j] if i==j else A_full_s[i,j])\n\n    A_add_s, A_mul_s = self.process_full_adjacency(A_full_s, coupling_type=coupling_type)\n\n    return A_add_s, A_mul_s, A_full_s\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.get_all_intervals","title":"<code>get_all_intervals(tvect, sig_times, t_wait=0.0, add_end_intervals=True)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def get_all_intervals(self,\n                      tvect: ndarray,\n                      sig_times: list | ndarray,\n                      t_wait: float = 0.0,\n                      add_end_intervals: bool = True\n                      ):\n    '''\n\n    '''\n    intervals_set = set()  # Initialize set to hold the interval indices\n\n    # sig_times = sorted(sig_times) # sort the time tuples by their start time\n    sig_times.sort(key=lambda x: x[0])  # sort the time tuples by their start time\n\n    for ts, te in sig_times:\n        inti = self.get_interval_inds(tvect,\n                                      ts,\n                                      te,\n                                      t_wait=t_wait\n                                      )\n\n        if len(inti):\n            intervals_set.add((inti[0], inti[-1]))\n\n    if add_end_intervals:\n        # Add a start interval\n        intis = self.get_interval_inds(tvect,\n                                       tvect[0],\n                                       sig_times[0][0],\n                                       t_wait=t_wait\n                                       )\n        if len(intis):\n            intervals_set.add((intis[0], intis[-1]))\n\n        # Add an end interval:\n        intie = self.get_interval_inds(tvect,\n                                       sig_times[-1][1],\n                                       tvect[-1],\n                                       t_wait=t_wait\n                                       )\n        if len(intie):\n            intervals_set.add((intie[0], intie[-1]))\n\n    intervals_list = list(intervals_set)\n    intervals_list.sort(key=lambda x: x[0])  # sort the time tuples by their start time\n\n    return intervals_list\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.get_function_args","title":"<code>get_function_args(constraint_vals=None, d_base=1.0, n_base=3.0, beta_base=2.0)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def get_function_args(self,\n                      constraint_vals: list|None=None,\n                      d_base: float|list[float]=1.0,\n                      n_base: float|list[float]=3.0,\n                      beta_base: float|list[float]=2.0):\n    '''\n\n    '''\n    d_vect, n_vect, beta_vect = self.make_numerical_params(d_base, n_base, beta_base)\n\n    if constraint_vals is not None:\n        function_args = (constraint_vals, n_vect, beta_vect, d_vect)\n\n    else:\n        function_args = (n_vect, beta_vect, d_vect)\n\n    return function_args\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.get_interval_inds","title":"<code>get_interval_inds(tvect, t_on, t_off, t_wait=0.0)</code>","text":"<p>Returns indices specifying an interval from the supplied vector tvect spanning between vector values t_on and t_off.</p> <p>Parameters:</p> Name Type Description Default <code>t_vect</code> <code>ndarray</code> <p>The vector to pull the interval from.</p> required <code>t_on</code> <code>float</code> <p>The first value in the vector defining the interval start.</p> required <code>t_off</code> <code>float</code> <p>The value in the vector defining the interval end.</p> required <code>t_wait</code> <code>float</code> <p>The amount of time to push up the start of the interval from t_on (which is useful if you're waiting for the system to get back to steady-state).</p> <code>0.0</code> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def get_interval_inds(self,\n                      tvect: ndarray,\n                      t_on: float,\n                      t_off: float,\n                      t_wait: float = 0.0\n                      ):\n    '''\n    Returns indices specifying an interval from the\n    supplied vector tvect spanning between vector\n    values t_on and t_off.\n\n    Parameters\n    ----------\n    t_vect : ndarray\n        The vector to pull the interval from.\n\n    t_on : float\n        The first value in the vector defining the interval start.\n\n    t_off : float\n        The value in the vector defining the interval end.\n\n    t_wait: float\n        The amount of time to push up the start of the interval from\n        t_on (which is useful if you're waiting for the system to get\n        back to steady-state).\n\n    '''\n    itop = (tvect &gt;= t_on + t_wait).nonzero()[0]\n    ibot = (tvect &lt;= t_off).nonzero()[0]\n\n    ipulse_inds = np.intersect1d(ibot, itop)\n\n    return ipulse_inds\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.get_visual_equations","title":"<code>get_visual_equations()</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def get_visual_equations(self):\n    '''\n\n    '''\n    c_vect_viz = []\n    subs_list = []\n    self._subs_syms_list = []\n    for pi, nde_lab in zip(self._c_vect_s, self.nodes_list):\n        nde_sym = sp.symbols(str(nde_lab))\n        c_vect_viz.append(nde_sym)\n        subs_list.append((pi, nde_sym))\n        self._subs_syms_list.append(nde_sym)\n\n    for ei, (nij, bij) in enumerate(zip(self._n_vect_s, self._beta_vect_s)):\n        b_sym = sp.symbols(f'beta_{ei}')\n        n_sym = sp.symbols(f'n_{ei}')\n        subs_list.append((bij, b_sym))\n        subs_list.append((nij, n_sym))\n        self._subs_syms_list.append(b_sym)\n        self._subs_syms_list.append(n_sym)\n\n    for ndei, di in enumerate(self._d_vect_s):\n        d_sym = sp.symbols(f'd_{ndei}')\n        subs_list.append((di, d_sym))\n        self._subs_syms_list.append(d_sym)\n\n    dcdt_vect_s_viz = sp.Matrix(self._dcdt_vect_s).subs(subs_list)\n\n    return c_vect_viz, dcdt_vect_s_viz\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.make_numerical_params","title":"<code>make_numerical_params(d_base=1.0, n_base=15.0, beta_base=0.25)</code>","text":"<p>Scrape the network for base parameters to initialize numerical parameters.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def make_numerical_params(self,\n                   d_base: float|list[float]=1.0,\n                   n_base: float|list[float]=15.0,\n                   beta_base: float|list[float]=0.25,\n                   ) -&gt; tuple[list[float], list[float], list[float]]:\n    '''\n    Scrape the network for base parameters to initialize numerical parameters.\n\n    '''\n    # Node parameters:\n    if type(d_base) is list:\n        assert len(d_base) == self.N_nodes, \"Length of d_base not equal to node number!\"\n        d_vect = d_base\n    else:\n        d_vect = [d_base for i in range(self.N_nodes)]\n\n    # Edge parameters:\n    if type(n_base) is list:\n        assert len(n_base) == self.N_edges, \"Length of n_base not equal to edge number!\"\n        n_vect = n_base\n    else:\n        n_vect = [n_base for i in range(self.N_edges)]\n\n    if type(beta_base) is list:\n        assert len(beta_base) == self.N_edges, \"Length of n_base not equal to edge number!\"\n        beta_vect = beta_base\n    else:\n        beta_vect = [beta_base for i in range(self.N_edges)]\n\n    return d_vect, n_vect, beta_vect\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.make_pulsed_signals_matrix","title":"<code>make_pulsed_signals_matrix(tvect, sig_inds, sig_times, sig_mag)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def make_pulsed_signals_matrix(self,\n                               tvect: list | ndarray,\n                               sig_inds: list | ndarray,\n                               sig_times: list | ndarray,\n                               sig_mag: list | ndarray):\n    '''\n\n    '''\n    Nt = len(tvect)\n\n    c_signals = np.zeros((Nt, self.N_nodes))  # Initialize matrix holding the signal sequences\n\n    for si, (ts, te), (smin, smax) in zip(sig_inds, sig_times, sig_mag):\n        c_signals[:, si] += self.pulses(tvect,\n                                        ts,\n                                        te,\n                                        c_base=smax,\n                                        c_active=smin\n                                        )\n\n    return c_signals\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.make_time_vects","title":"<code>make_time_vects(tend, dt, dt_samp=None)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def make_time_vects(self,\n                    tend: float,\n                    dt: float,\n                    dt_samp: float | None = None, ):\n    '''\n\n    '''\n    Nt = int(tend / dt)\n    tvect = np.linspace(0.0, tend, Nt)\n\n    # sampling compression\n    if dt_samp is not None:\n        sampr = int(dt_samp / dt)\n        tvectr = tvect[0::sampr]\n    else:\n        tvectr = tvect\n\n    # make a time-step update vector so we can update any sensors as\n    # an absolute reading (dt = 1.0) while treating the kinetics of the\n    # other node types:\n    # dtv = dt * np.ones(self._N_nodes)\n    # dtv[self.sensor_node_inds] = 1.0\n\n    return tvect, tvectr\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.multiround","title":"<code>multiround(cc)</code>","text":"<p>Perform a rounding procedure to 1/(node_expression_levels - 1) level of resolution. For example, if node_expression_levels = 5.0, then this will round values to 0.0, 0.25, 0.5, 0.75, and 1.0.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def multiround(self, cc):\n    '''\n    Perform a rounding procedure to 1/(node_expression_levels - 1) level of resolution.\n    For example, if node_expression_levels = 5.0, then this will round values to 0.0, 0.25, 0.5, 0.75, and 1.0.\n    '''\n    cc = np.round(cc * (self._node_expression_levels - 1)) / (self._node_expression_levels - 1)\n\n    return cc\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.process_full_adjacency","title":"<code>process_full_adjacency(A_full_s, coupling_type=CouplingType.mix1)</code>","text":"<p>Process a full adjacency matrix into additive and multiplicative components based on a specified coupling type.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def process_full_adjacency(self, A_full_s: MutableDenseMatrix, coupling_type: CouplingType=CouplingType.mix1):\n    '''\n    Process a full adjacency matrix into additive and multiplicative components\n    based on a specified coupling type.\n\n    '''\n    A_add_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n    A_mul_s = np.zeros((self.N_nodes, self.N_nodes), dtype=int)\n\n    for i in range(self.N_nodes):\n        for j in range(self.N_nodes):\n            afull_ij = A_full_s[i,j]\n            if afull_ij == 1:\n                if coupling_type is CouplingType.additive or coupling_type is CouplingType.mix1:\n                    A_add_s[i,j] = 1\n                elif coupling_type is CouplingType.multiplicative:\n                    A_mul_s[i,j] = 1\n                else:\n                    raise Exception('CouplingType.specified is not supported in this method.')\n\n            if afull_ij == -1:\n                if coupling_type is CouplingType.additive:\n                    A_add_s[i,j] = -1\n                elif coupling_type is CouplingType.multiplicative or coupling_type is CouplingType.mix1:\n                    A_mul_s[i,j] = -1\n                else:\n                    raise Exception('CouplingType.specified is not supported in this method.')\n\n    A_add_s = sp.Matrix(A_add_s)\n    A_mul_s = sp.Matrix(A_mul_s)\n\n    return A_add_s, A_mul_s\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.pulses","title":"<code>pulses(tvect, t_on, t_off, c_base=1.0, c_active=0.0)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def pulses(self,\n           tvect: list | ndarray,\n           t_on: float | int,\n           t_off: float | int,\n           c_base: float | int = 1.0,\n           c_active: float | int = 0.0,\n           ):\n    '''\n\n    '''\n    itop = (tvect &gt;= t_on).nonzero()[0]\n    ibot = (tvect &lt;= t_off).nonzero()[0]\n\n    ipulse = np.intersect1d(ibot, itop)\n\n    pulse_sig = c_active * np.ones(len(tvect))\n\n    pulse_sig[ipulse] = c_base\n\n    return pulse_sig\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.reduce_model_dimensions","title":"<code>reduce_model_dimensions(use_nonlinsolve=False)</code>","text":"<p>Using analytical methods, attempt to reduce the multidimensional network equations to as few equations as possible.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def reduce_model_dimensions(self, use_nonlinsolve: bool = False):\n    '''\n    Using analytical methods, attempt to reduce the multidimensional\n    network equations to as few equations as possible.\n\n    '''\n\n    # Solve the nonlinear system as well as is possible:\n    nosol = False\n\n    # We want to restrict this model reduction to homogeneous networks that\n    # only contain genes and signals.\n    if len(self.process_node_inds) or self._inter_fun_type is InterFuncType.logistic:\n        print(\"System unsolvable due to use of logistic interaction function. Try Hill-type equations.\")\n        nosol = True  # Immediately flag the sysem as unsolvable\n\n    else:\n\n        try:\n            if use_nonlinsolve:\n                sol_csetoo = sp.nonlinsolve(self._dcdt_vect_s,\n                                            self._c_vect_s[self.noninput_node_inds.tolist(), :])\n\n            else:\n                sol_csetoo = sp.solve(self._dcdt_vect_s,\n                                      self._c_vect_s[self.noninput_node_inds.tolist(), :])\n            # Clean up the sympy container for the solutions:\n            sol_cseto = list(list(sol_csetoo)[0])\n\n            if len(sol_cseto):\n\n                c_master_i = []  # the indices of concentrations involved in the master equations (the reduced dims)\n                sol_cset = {}  # A dictionary of auxillary solutions (plug and play)\n                for i, c_eq in enumerate(sol_cseto):\n                    if c_eq in self._c_vect_s:  # If it's a non-solution for the term, append it as a non-reduced conc.\n                        c_master_i.append(self._c_vect_s.index(c_eq))\n                    else:  # Otherwise append the plug-and-play solution set:\n                        sol_cset[self._c_vect_s[self.noninput_node_inds.tolist(), :][i]] = c_eq\n\n                master_eq_list = []  # master equations to be numerically optimized (reduced dimension network equations)\n                c_vect_reduced = []  # concentrations involved in the master equations\n\n                if len(c_master_i):\n                    for ii in c_master_i:\n                        # substitute in the expressions in terms of master concentrations to form the master equations:\n                        ci_solve_eq = self._dcdt_vect_s[ii].subs([(k, v) for k, v in sol_cset.items()])\n                        master_eq_list.append(ci_solve_eq)\n                        c_vect_reduced.append(self._c_vect_s[ii])\n\n                else:  # if there's nothing in c_master_i but there are solutions in sol_cseto, then it's been fully solved:\n                    print(\"The system has been fully solved by analytical methods!\")\n                    self._solved_analytically = True\n\n            else:\n                print(\"No solutions found for the system.\")\n                nosol = True\n\n        except:\n            print(\"Exception called in Sympy.\")\n            nosol = True\n\n    # Results:\n    if nosol is True:\n        self._reduced_dims = False\n        print(\"Unable to reduce equations!\")\n        # Set all reduced system attributes to None:\n        self._dcdt_vect_reduced_s = None\n        self._c_vect_reduced_s = None\n        self.c_master_i = None\n        self.c_remainder_i = None\n        self.c_vect_remainder_s = None\n        # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n        # such that when the master equation set is solved, the results are plugged into the equations in this\n        # dictionary to obtain solutions for the whole network\n        self.sol_cset_s = None\n\n        self.signal_reduced_inds = None\n        self.nonsignal_reduced_inds = None\n\n    else:  # If we have solutions, proceed:\n        self._reduced_dims = True\n\n        if self._solved_analytically is False:\n            # New equation list to be numerically optimized (should be significantly reduced dimensions):\n            # Note: this vector is no longer the change rate vector; its now solving for concentrations\n            # where the original rate change vector is zero:\n            self._dcdt_vect_reduced_s = sp.Matrix(master_eq_list)\n            # This is the concentration vector that contains the reduced equation concentration variables:\n            self._c_vect_reduced_s = c_vect_reduced\n            self.c_master_i = c_master_i  # indices of concentrations that are being numerically optimized\n            self.c_remainder_i = np.setdiff1d(self.nodes_index, self.c_master_i)  # remaining conc indices\n            self.c_vect_remainder_s = np.asarray(self._c_vect_s)[self.c_remainder_i].tolist()  # remaining concs\n\n            # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n            # such that when the master equation set is solved, the results are plugged into the equations in this\n            # dictionary to obtain solutions for the whole network:\n            self.sol_cset_s = sol_cset\n\n            # Create a set of signal node indices to the reduced c_vect array:\n            self.signal_reduced_inds = []\n            for si in self.input_node_inds:\n                if si in self.c_master_i:\n                    self.signal_reduced_inds.append(self.c_master_i.index(si))\n\n            self.nonsignal_reduced_inds = np.setdiff1d(np.arange(len(self.c_master_i)),\n                                                       self.signal_reduced_inds)\n\n        else:\n            # Set most reduced system attributes to None:\n            self._dcdt_vect_reduced_s = None\n            self._c_vect_reduced_s = None\n            self.c_master_i = None\n            self.c_remainder_i = None\n            self.c_vect_remainder_s = None\n            self.signal_reduced_inds = None\n            self.nonsignal_reduced_inds = None\n\n            # This is the dictionary of remaining concentrations that are in terms of the reduced concentrations,\n            # such that when the master equation set is solved, the results are plugged into the equations in this\n            # dictionary to obtain solutions for the whole network:\n            self.sol_cset_s = sol_cset\n\n            # The sol_cset exists and can be lambdified for full solutions. Here we lambdify it without the c_vect:\n            if len(self.process_node_inds):\n                lambda_params_r = [self._d_vect_s,\n                                   self._beta_vect_s,\n                                   self._n_vect_s,\n                                   self._c_vect_s[self.input_node_inds, :],\n                                   self.extra_params_s]\n\n            else:\n                lambda_params_r = [self._d_vect_s,\n                                   self._beta_vect_s,\n                                   self._n_vect_s,\n                                   self._c_vect_s[self.input_node_inds, :]]\n\n            self.sol_cset_f = {}\n            for ci, eqci in self.sol_cset_s.items():\n                # self.sol_cset_f[ci.indices[0]] = sp.lambdify(lambda_params_r, eqci)\n                self.sol_cset_f[ci] = sp.lambdify(lambda_params_r, eqci)\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.run_time_sim","title":"<code>run_time_sim(tvect, tvectr, cvecti, sig_inds=None, sig_vals=None, constrained_inds=None, constrained_vals=None, d_base=1.0, n_base=15.0, beta_base=0.25)</code>","text":"Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def run_time_sim(self,\n                 tvect: ndarray|list,\n                 tvectr: ndarray|list,\n                 cvecti: ndarray|list,\n                 sig_inds: ndarray|list|None = None,\n                 sig_vals: list | ndarray | lil_array| None = None,\n                 constrained_inds: list | None = None,\n                 constrained_vals: list | None = None,\n                 d_base: float|list[float] = 1.0,\n                 n_base: float|list[float] = 15.0,\n                 beta_base: float|list[float] = 0.25\n                 ):\n    '''\n\n    '''\n\n    dt = tvect[1] - tvect[0]\n\n    if sig_inds is None or sig_vals is None:\n        sig_inds = []\n        sig_vals = []\n\n    concs_time = []\n\n    dcdt_vect_f, dcdt_jac_f = self.create_numerical_dcdt(constrained_inds=constrained_inds,\n                                                         constrained_vals=constrained_vals)\n\n    function_args = self.get_function_args(constraint_vals=constrained_vals,\n                                           d_base=d_base,\n                                           n_base=n_base,\n                                           beta_base=beta_base)\n\n    for ti, tt in enumerate(tvect):\n        dcdt = np.asarray(dcdt_vect_f(cvecti, *function_args))\n        cvecti += dt * dcdt\n\n        # manually set the signal node values:\n        if type(sig_vals) is lil_array:\n            cvecti[sig_inds] = sig_vals[ti, sig_inds].toarray()\n        else:\n            cvecti[sig_inds] = sig_vals[ti, sig_inds]\n\n        if tt in tvectr:\n            concs_time.append(cvecti * 1)\n\n    concs_time = np.asarray(concs_time)\n\n    return concs_time\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.save_model_equations","title":"<code>save_model_equations(save_eqn_image, save_reduced_eqn_image=None, save_eqn_csv=None, substitute_node_labels=True)</code>","text":"<p>Save images of the model equations, as well as a csv file that has model equations written in LaTeX format.</p> <p>Parameters:</p> Name Type Description Default <code>save_eqn_image</code> <code>str</code> <p>The path and filename to save the main model equations as an image.</p> required <code>save_reduced_eqn_image</code> <code>str|None = None</code> <p>The path and filename to save the reduced main model equations as an image (if model is reduced).</p> <code>None</code> <code>save_eqn_csv</code> <code>str|None = None</code> <p>The path and filename to save the main and reduced model equations as LaTex in a csv file.</p> <code>None</code> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def save_model_equations(self,\n                         save_eqn_image: str,\n                         save_reduced_eqn_image: str|None = None,\n                         save_eqn_csv: str|None = None,\n                         substitute_node_labels: bool = True\n                         ):\n    '''\n    Save images of the model equations, as well as a csv file that has\n    model equations written in LaTeX format.\n\n    Parameters\n    -----------\n    save_eqn_image : str\n        The path and filename to save the main model equations as an image.\n\n    save_reduced_eqn_image : str|None = None\n        The path and filename to save the reduced main model equations as an image (if model is reduced).\n\n    save_eqn_csv : str|None = None\n        The path and filename to save the main and reduced model equations as LaTex in a csv file.\n\n    '''\n\n    if substitute_node_labels:\n        subs_list = []\n        for pi, nde_lab in zip(self._c_vect_s, self.nodes_list):\n            nde_sym = sp.symbols(nde_lab)\n            subs_list.append((pi, nde_sym))\n\n        for ei, (nij, bij) in enumerate(zip(self._n_vect_s, self._beta_vect_s)):\n            b_sym = sp.symbols(f'beta_{ei}')\n            n_sym = sp.symbols(f'n_{ei}')\n            subs_list.append((bij, b_sym))\n            subs_list.append((nij, n_sym))\n\n        for ndei, di in enumerate(self._d_vect_s):\n            d_sym = sp.symbols(f'd_{ndei}')\n            subs_list.append((di, d_sym))\n\n        _dcdt_vect_s = list(sp.Matrix(self._dcdt_vect_s).subs(subs_list))\n        _c_vect_s = list(sp.Matrix(self._c_vect_s).subs(subs_list))\n\n        if self._dcdt_vect_reduced_s is not None:\n            _dcdt_vect_reduced_s = list(sp.Matrix(self._dcdt_vect_reduced_s).subs(subs_list))\n            _c_vect_reduced_s = list(sp.Matrix(self._c_vect_reduced_s).subs(subs_list))\n\n    else:\n        _dcdt_vect_s = self._dcdt_vect_s\n        _c_vect_s = self._c_vect_s\n\n        if self._dcdt_vect_reduced_s is not None:\n            _dcdt_vect_reduced_s = self._dcdt_vect_reduced_s\n            _c_vect_reduced_s = self._c_vect_reduced_s\n\n\n    t_s = sp.symbols('t')\n    c_change = sp.Matrix([sp.Derivative(ci, t_s) for ci in _c_vect_s])\n    eqn_net = sp.Eq(c_change, sp.Matrix(_dcdt_vect_s))\n\n    sp.preview(eqn_net,\n               viewer='file',\n               filename=save_eqn_image,\n               euler=False,\n               dvioptions=[\"-T\", \"tight\", \"-z\", \"0\", \"--truecolor\", \"-D 600\", \"-bg\", \"Transparent\"])\n\n    # Save the equations for the graph to a file:\n    header = ['Concentrations', 'Change Vector']\n    eqns_to_write = [[sp.latex(_c_vect_s), sp.latex(_dcdt_vect_s)]]\n\n    if self._dcdt_vect_reduced_s is not None and save_reduced_eqn_image is not None:\n        c_change_reduced = sp.Matrix([sp.Derivative(ci, t_s) for ci in _c_vect_reduced_s])\n        eqn_net_reduced = sp.Eq(c_change_reduced, _dcdt_vect_reduced_s)\n\n        sp.preview(eqn_net_reduced,\n                   viewer='file',\n                   filename=save_reduced_eqn_image,\n                   euler=False,\n                   dvioptions=[\"-T\", \"tight\", \"-z\", \"0\", \"--truecolor\", \"-D 600\", \"-bg\", \"Transparent\"])\n\n        eqns_to_write.append(sp.latex(_c_vect_reduced_s))\n        eqns_to_write.append(sp.latex(_dcdt_vect_reduced_s))\n        header.extend(['Reduced Concentations', 'Reduced Change Vector'])\n\n    if save_eqn_csv is not None:\n        with open(save_eqn_csv, 'w', newline=\"\") as file:\n            csvwriter = csv.writer(file)  # 2. create a csvwriter object\n            csvwriter.writerow(header)  # 4. write the header\n            csvwriter.writerows(eqns_to_write)  # 5. write the rest of the data\n</code></pre>"},{"location":"1%29%20GRN%20Model%20Building/network_models_probability_networks/#cellnition.science.network_models.probability_networks.ProbabilityNet.solve_probability_equms","title":"<code>solve_probability_equms(constraint_inds=None, constraint_vals=None, signal_constr_vals=None, d_base=1.0, n_base=15.0, beta_base=0.25, N_space=2, search_tol=1e-15, sol_tol=0.1, verbose=True, save_file=None, return_saddles=False, search_main_nodes_only=False, node_num_max=None)</code>","text":"<p>Solve for the equilibrium points of gene product probabilities in terms of a given set of numerical parameters.</p> Source code in <code>cellnition/science/network_models/probability_networks.py</code> <pre><code>def solve_probability_equms(self,\n                            constraint_inds: list|None = None,\n                            constraint_vals: list|None = None,\n                            signal_constr_vals: list|None = None,\n                            d_base: float|list[float] = 1.0,\n                            n_base: float|list[float] = 15.0,\n                            beta_base: float|list[float] = 0.25,\n                            N_space: int = 2,\n                            search_tol: float=1.0e-15,\n                            sol_tol: float=1.0e-1,\n                            verbose: bool=True,\n                            save_file: str|None = None,\n                            return_saddles: bool = False,\n                            search_main_nodes_only: bool=False,\n                            node_num_max: int|None = None\n                            ):\n    '''\n    Solve for the equilibrium points of gene product probabilities in\n    terms of a given set of numerical parameters.\n    '''\n\n    # For any network, there may be nodes without regulation that require constraints\n    # (these are in self._constrained_nodes). Therefore, add these to any user-supplied\n    # constraints:\n    constrained_inds, constrained_vals = self._handle_constrained_nodes(constraint_inds,\n                                                                        constraint_vals,\n                                                                        signal_constr_vals=signal_constr_vals)\n\n    dcdt_vect_f, dcdt_jac_f = self.create_numerical_dcdt(constrained_inds=constrained_inds,\n                                                         constrained_vals=constrained_vals)\n\n    if node_num_max is not None:\n        sort_hier_inds = np.argsort(self.hier_node_level[self.noninput_node_inds])\n        self.influence_node_inds = list(np.asarray(self.noninput_node_inds)[sort_hier_inds][0:node_num_max])\n\n\n    if constrained_inds is None or constrained_vals is None:\n        unconstrained_inds = self._nodes_index\n    else:\n        unconstrained_inds = np.setdiff1d(self._nodes_index, constrained_inds).tolist()\n\n    if search_main_nodes_only is False:\n        M_pstates, _, _ = self.generate_state_space(unconstrained_inds, N_space)\n\n    else:\n        if len(self.main_nodes):\n            if node_num_max is None:\n                M_pstates, _, _ = self.generate_state_space(self.main_nodes, N_space)\n            elif len(self.main_nodes) &lt; node_num_max:\n                M_pstates, _, _ = self.generate_state_space(self.main_nodes, N_space)\n            else:\n                M_pstates, _, _ = self.generate_state_space(self.influence_node_inds, N_space)\n\n        else:\n            raise Exception(\"No main nodes; cannot perform state search with \"\n                            \"search_main_nodes_only=True.\")\n\n    sol_Mo = []\n\n    function_args = self.get_function_args(constraint_vals=constrained_vals,\n                                           d_base=d_base,\n                                           n_base=n_base,\n                                           beta_base=beta_base)\n\n    self._function_args = function_args\n\n    for i, cvecto in enumerate(M_pstates): # for each test vector:\n        # get values for the genes we're solving for...\n        # Note: fsolve doesn't allow us to impose constraints so we need to push this initial guess\n        # quite far away from zero with the added constant:\n        c_vect_sol = cvecto[unconstrained_inds] + self._push_away_from_zero\n        sol_roots = fsolve(dcdt_vect_f,\n                           c_vect_sol,\n                           args=function_args,\n                           xtol=search_tol,\n                           fprime=dcdt_jac_f,\n                           col_deriv=False,\n                           )\n\n        # Find any roots below zero and constrain them to 0.0:\n        sol_roots[(sol_roots &lt;= 0.0).nonzero()] = self.p_min\n\n        c_eqms = np.zeros(self.N_nodes)\n        c_eqms[unconstrained_inds] = sol_roots\n\n        if constrained_inds is not None and constrained_vals is not None:\n            c_eqms[constrained_inds] = constrained_vals\n\n        # c_eqms = self.multiround(c_eqms)\n\n        sol_Mo.append(c_eqms)\n\n    # _, unique_inds = np.unique(np.round(sol_Mo, 2), axis=0, return_index=True)\n    _, unique_inds = np.unique(self.multiround(np.asarray(sol_Mo)), axis=0, return_index=True)\n\n    sol_M = np.asarray(sol_Mo)[unique_inds]\n\n    stable_sol_M, sol_M_char = self.find_attractor_sols(sol_M,\n                                                         dcdt_vect_f,\n                                                         dcdt_jac_f,\n                                                         function_args,\n                                                         constrained_inds=constrained_inds,\n                                                         tol= sol_tol,\n                                                         verbose = verbose,\n                                                         save_file = save_file,\n                                                         return_saddles=return_saddles)\n\n    return stable_sol_M, sol_M_char, sol_M\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/","title":"Boolean Finite State Machine","text":"<p>               Bases: <code>object</code></p> <p>Builds and plots Network Finite State Machines (NFSMs) from a regulatory network modelled using Boolean logic functions (see <code>BooleanNet</code>). BoolStateMachine first performs a comprehensive search for stable equilibrium states of the regulatory network. It then uses pseudo-time simulation, starting the system off at every equilibrium state and every input signal, applying a new input signal, and returning the system to the original input signal. It then detects new equilibrium states occupied by the system after the application of each input signal perturbation. The input-driven transitions between states are recorded as the NFSMs of the system.</p> <p>Attributes:</p> Name Type Description <code>G_states</code> <code>MultiDiGraph</code> <p>General NFSM (G-NFSM), where each equilibrium-state of the regulatory network is a node of the G-NFSM, and labeled directed edges indicate the input state (as an edge label) inducing a transition between one equilibrium state and another. This is a networkx MultiDiGraph, which means parallel edges are allowed to exist and therefore it is possible for different signals to transition the system between the same two state. <code>G_states</code> is created using the <code>create_transition_network</code> method.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>class BoolStateMachine(object):\n    '''\n    Builds and plots Network Finite State Machines (NFSMs) from a regulatory\n    network modelled using Boolean logic functions (see\n    [`BooleanNet`][cellnition.science.network_models.boolean_networks.BooleanNet]).\n    BoolStateMachine first performs a comprehensive search for stable\n    equilibrium states of the regulatory network. It then uses pseudo-time simulation,\n    starting the system off at every equilibrium state and every input signal,\n    applying a new input signal, and returning the system to the original input signal.\n    It then detects new equilibrium states occupied by the system after the application\n    of each input signal perturbation. The input-driven transitions between states are\n    recorded as the NFSMs of the system.\n\n    Attributes\n    -----------------\n    G_states : MultiDiGraph\n        General NFSM (G-NFSM), where each equilibrium-state of the\n        regulatory network is a node of the G-NFSM, and labeled directed edges indicate the\n        input state (as an edge label) inducing a transition between one equilibrium state\n        and another. This is a networkx MultiDiGraph,\n        which means parallel edges are allowed to exist and therefore it is possible for different signals to\n        transition the system between the same two state. `G_states` is created using the\n        `create_transition_network` method.\n\n\n    '''\n\n    def __init__(self, bnet: BooleanNet):\n        '''\n        Initialize the `BoolStateMachine`.\n\n        Parameters\n        ----------\n        bnet : BooleanNet\n            An instance of [`BooleanNet`][cellnition.science.network_models.boolean_networks.BooleanNet].\n        '''\n\n        self._bnet = bnet\n        self.G_states = None # The state transition network\n\n        # Path to load image assets:\n        GLYPH_DIR = get_data_png_glyph_stability_dir()\n        attractor_fname = FileRelative(GLYPH_DIR, 'glyph_attractor.png')\n        limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_limit_cycle.png')\n        saddle_fname = FileRelative(GLYPH_DIR, 'glyph_saddle.png')\n        attractor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_attractor_limit_cycle.png')\n        repellor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_repellor_limit_cycle.png')\n        repellor_fname = FileRelative(GLYPH_DIR, 'glyph_repellor.png')\n        unknown_fname = FileRelative(GLYPH_DIR, 'glyph_unknown.png')\n        hidden_fname = FileRelative(GLYPH_DIR, 'glyph_hidden.png')\n\n        # Associate each equilibrium type with an image file\n        self._node_image_dict = {\n            EquilibriumType.attractor.name: str(attractor_fname),\n            EquilibriumType.limit_cycle.name: str(limitcycle_fname),\n            EquilibriumType.saddle.name: str(saddle_fname),\n            EquilibriumType.attractor_limit_cycle.name: str(attractor_limitcycle_fname),\n            EquilibriumType.repellor_limit_cycle.name: str(repellor_limitcycle_fname),\n            EquilibriumType.repellor.name: str(repellor_fname),\n            EquilibriumType.undetermined.name: str(unknown_fname),\n            EquilibriumType.hidden.name: str(hidden_fname)\n        }\n\n\n    def steady_state_solutions_search(self,\n                                      verbose: bool=True,\n                                      search_main_nodes_only: bool = False,\n                                      n_max_steps: int = 20,\n                                      order_by_distance: bool=False,\n                                      node_num_max: int | None = None,\n                                      output_nodes_only: bool = False\n                                      ) -&gt; tuple[ndarray, ndarray, list, OrderedDict, ndarray]:\n        '''\n        Search through all possible (binary valued) combinations of input nodes\n        (`BooleanNet.input_node_inds`) to find and dynamically characterize equilibrium\n        state of the regulatory network system.\n\n        Parameters\n        ----------\n        verbose : bool, default: True\n            Print output while solving (`True`)?\n        search_main_nodes_only : bool, default: False\n            Search only the `BooleanNet.main_nodes` (`True`) or search all noninput nodes,\n            `BooleanNet.noninput_node_inds` nodes (`False`)?\n        n_max_steps : int, default: 20\n            The maximum number of steps that the Boolean regulatory network solver should use in\n            determining each eq'm. It is recommended that `n_max_steps` be greater than twice the\n            total node number (i.e. `n_max_steps &gt;= 2*BooleanNet.N_nodes`).\n        order_by_distance : bool, default: False\n            Order states by increasing distance from the zero state (`True`)?\n        node_num_max : int|None, default: None\n            If `n_max_steps` is `True`, further limit the search space dimensions to the first node_num_max\n            nodes according to their hierarchical level (i.e. according to `BooleanNet.hier_node_level`)?\n            We have found that all equilibrium solutions can be returned by selecting the a subset of nodes\n            with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence\n            on the network.\n        output_nodes_only : bool, default: False\n            Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n            by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n        Returns\n        -------\n        solsM : ndarray\n            The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n            representing the node expression level.\n        charM_all : ndarray\n            The dynamic characterization of each equilibrium state in solsM, as a linear array of\n            [`EquilibriumType`][cellnition.science.network_models.network_enums]\n            enumerations.\n        sols_list : list\n            The list of all (non-unique) equilibrium state solutions in the order that they were found.\n        states_dict : OrderedDict\n            A dictionary with keys as tuples representing each input state, and values being the equilibrium\n            state index as the column index of `solsM`.\n        sig_test_set : ndarray\n            An array containing each of the input states (i.e. all binary-node-level combinations of\n            `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n            of the network were found.\n\n        '''\n        if self._bnet._A_bool_f is None:\n            raise Exception(\"The BooleanNetwork object needs to have an analytical model constructed using\"\n                            \"the build_boolean_model method.\")\n\n        sig_lin = [0, 1]\n\n        sig_lin_set = [sig_lin for i in self._bnet.input_node_inds]\n\n        sigGrid = np.meshgrid(*sig_lin_set)\n\n        N_vocab = len(sigGrid[0].ravel())\n\n        sig_test_set = np.zeros((N_vocab, len(self._bnet.input_node_inds)))\n\n        for i, sigM in enumerate(sigGrid):\n            sig_test_set[:, i] = sigM.ravel()\n\n        # solsM_allo = np.zeros((self._bnet.N_nodes, 1))\n        # charM_allo = [EquilibriumType.undetermined]\n        solsM_allo = None\n        charM_allo = []\n        sols_list = []\n\n        for sigis in sig_test_set:\n            if verbose:\n                print(f'Signals: {sigis}')\n            sols_M, sols_char = self._bnet.solve_system_equms(\n                                                        self._bnet._A_bool_f,\n                                                        constraint_inds=None,\n                                                        constraint_vals=None,\n                                                        signal_constr_vals=sigis.tolist(),\n                                                        search_main_nodes_only=search_main_nodes_only,\n                                                        n_max_steps=n_max_steps,\n                                                        verbose=False,\n                                                        node_num_max=node_num_max\n                                                        )\n            if solsM_allo is None:\n                solsM_allo = sols_M\n            else:\n                solsM_allo = np.hstack((solsM_allo, sols_M))  # append all unique sols\n            charM_allo.extend(sols_char.tolist())  # append the sol stability characterization tags\n            sols_list.append(sols_M)\n            if verbose:\n                print(sols_M)\n                print('----')\n\n        # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n        if output_nodes_only is True and len(self._bnet.output_node_inds):\n            state_node_inds = self._bnet.output_node_inds\n        else:\n            state_node_inds = self._bnet.noninput_node_inds\n\n        # Eliminate duplicate states, but stack on strings of the eqm char\n        # so we don't lose states with the same values but with different eq'm:\n        # chrm = [eqt.name for eqt in charM_allo]\n        # checkM = np.vstack((solsM_allo[state_node_inds, :], chrm))\n        _, inds_solsM_all_unique = np.unique(solsM_allo[state_node_inds, :], return_index=True, axis=1)\n        solsM_all = solsM_allo[:, inds_solsM_all_unique]\n        charM_all = np.asarray(charM_allo)[inds_solsM_all_unique]\n\n        if order_by_distance:\n            # Order states by distance from the zero vector\n            solsM_all, charM_all = self._order_states_by_distance(solsM_all, charM_all)\n\n        states_dict = OrderedDict()\n        for sigi in sig_test_set:\n            states_dict[tuple(sigi)] = {'States': [], 'Stability': []}\n\n        for sigi, state_subseto in zip(sig_test_set, sols_list):\n            state_subset = state_subseto[state_node_inds, :]\n            for target_state in state_subset.T.tolist():\n                state_match_index, err_match = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                      target_state)\n                if state_match_index not in states_dict[tuple(sigi)]['States']:\n                    states_dict[tuple(sigi)]['States'].append(state_match_index)\n                    states_dict[tuple(sigi)]['Stability'].append(charM_all[state_match_index])\n\n        return solsM_all, charM_all, sols_list, states_dict, sig_test_set\n\n    def create_transition_network(self,\n                                  states_dict: dict,\n                                  sig_test_set: list|ndarray,\n                                  solsM_allo: ndarray,\n                                  charM_allo: ndarray,\n                                  verbose: bool = True,\n                                  remove_inaccessible_states: bool=False,\n                                  save_graph_file: str|None = None,\n                                  n_max_steps: int=10,\n                                  output_nodes_only: bool = False\n                                  ) -&gt; tuple[set, set, MultiDiGraph]:\n        '''\n        This method builds the Network Finite State Machine by starting the system\n        in different equilibrium states, applying different input signals, and seeing\n        which equilibrium state the system ends up in after\n        a time simulation.\n\n        Parameters\n        ----------\n        states_dict : dict\n            A dictionary with keys as tuples representing each input state, and values being the equilibrium\n            state index as the column index of `solsM`. This is returned by `steady_state_solutions_search'.\n        sig_test_set : list|ndarray\n            An array containing each of the input states (i.e. all binary-node-level combinations of\n            `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n            of the network were found. This is returned by `steady_state_solutions_search'.\n        solsM_allo : ndarray\n            The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n            representing the node expression level. This is returned by `steady_state_solutions_search'.\n        charM_allo : ndarray\n            The dynamic characterization of each equilibrium state in solsM, as a linear array of\n            [`EquilibriumType`][cellnition.science.network_models.network_enums.EquilibriumType]\n            enumerations. This is returned by `steady_state_solutions_search'.\n        verbose : bool, default: True\n            Print output while solving (`True`)?\n        remove_inaccessible_states : bool, default: False\n            If there are states in the NFSM that aren't reachable by any other state, remove them? (Don't think\n            this variable currently works).\n        save_graph_file: str|None, default: None\n            Full directory and filename to save a gml format graph of the resulting G-NFSM.\n        n_max_steps: int, default: 10\n            The maximum number of steps that the Boolean regulatory network solver should use in\n            determining each eq'm. It is recommended that `n_max_steps` be greater than twice the\n            total node number (i.e. `n_max_steps &gt;= 2*BooleanNet.N_nodes`).\n        output_nodes_only: bool, default: False\n            Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n            by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n        Returns\n        -------\n        transition_edges_set : set\n            Set containing tuples defining all edges representing transitions of the general-NFSM (G-NFSM).\n            Each tuple marks the transition from eq'm state i to j under the action of input state k, so (i, j, k).\n            Eq'm state indices are to the columns of `solsM_allo`, and input state indices are to `sig_test_set`.\n            Note, as new eq'm states\n            may be detected during the run of this method, `self._solsM_all` and `self._charM_all` should be used to\n            reference eq'm states and their characterization instead of the original `solsM_allo` and `charM_allo`.\n        perturbation_edges_set : set\n            Set containing tuples defining all edges representing transitions of the event-driven NFSM (E-NFSM).\n            Each tuple marks the transition from eq'm state i to j under the action of transiently held input state k,\n            where the system is returned to the base input state l, so (i, j, k, l).\n            Eq'm state indices are to the columns of `solsM_allo`, and input state indices are to `sig_test_set`.\n            Note, as new eq'm states may be detected during the run of this method,\n            `self._solsM_all` and `self._charM_all` should be used to\n            reference eq'm states and their characterization instead of the original `solsM_allo` and `charM_allo`.\n        GG : MultiDiGraph\n            The networkx MultiDiGraph object representing the G-NFSM.\n\n        '''\n\n        # make a copy of solsM_all:\n        solsM_all = solsM_allo.copy()\n        charM_all = charM_allo.copy()\n\n        # make a copy of the states dict that's only used for modifications:\n        states_dict_2 = copy.deepcopy(states_dict)\n\n        # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n        if output_nodes_only is True and len(self._bnet.output_node_inds):\n            state_node_inds = self._bnet.output_node_inds\n        else:\n            state_node_inds = self._bnet.noninput_node_inds\n\n        # States for perturbation of the zero state inputs\n        # Let's start the system off in the zero vector, then\n        # temporarily perturb the system with each signal set and see what the final state is after\n        # the perturbation.\n\n        sig_inds = self._bnet.input_node_inds\n\n        transition_edges_set = set()\n        perturbation_edges_set = set()\n\n        num_step = 0\n\n        # We want to step through all 'held' signals and potentially multistable states:\n        # The \"base\" refers to the base context of the system:\n        for base_input_label, (sig_base_set, sc_dict) in enumerate(states_dict.items()):\n\n            states_set = sc_dict['States']\n\n            # Get an integer label for the 'bitstring' of signal node inds defining the base:\n            # base_input_label = self._get_integer_label(sig_base_set)\n            # We want to use each state in states_set as the initial condition:\n            for si in states_set:\n            # for si, cvect_co in enumerate(solsM_all.T): # step through all stable states\n\n                if verbose:\n                    print(f\"Testing State {si} in held context I{base_input_label}...\")\n\n                cvect_co = solsM_all[:, si]\n\n                # Initial state vector, which will be held at the base_input context\n                cvect_co[sig_inds] = sig_base_set\n                # ensure that this initial state is indeed stable in the context:\n                cvect_c, char_c = self._bnet.net_state_compute(cvect_co,\n                                                               self._bnet._A_bool_f,\n                                                               n_max_steps=n_max_steps,\n                                                               verbose=False,\n                                                               constraint_inds=self._bnet.input_node_inds,\n                                                               constraint_vals=list(sig_base_set),\n                                                               )\n\n                initial_state, match_error_initial = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                      cvect_c[state_node_inds])\n\n                if match_error_initial &gt; 0.01:  # if held state is unmatched, send warning...\n                    solsM_all = np.column_stack((solsM_all, cvect_c))\n                    charM_all = np.hstack((charM_all, char_c))\n                    initial_state = solsM_all.shape[1] - 1\n\n                    # Update the states listing for this input state set\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(initial_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    if verbose:\n                        print(f'WARNING: Initial state not found (error {match_error_initial});'\n                              f' adding new state {initial_state} to the solution set...')\n\n                # Add this transition to the state transition diagram:\n                transition_edges_set.add((si, initial_state, base_input_label))\n\n                # We then step through all possible perturbation signals that act on the state in the set:\n                cvect_ho = cvect_c.copy()\n                for pert_input_label, (sig_pert_set, _) in enumerate(states_dict.items()):\n                    if verbose:\n                        print(f\"--- Step: {num_step} ---\")\n                        print(f'...State {si} to {initial_state} via I{base_input_label}...')\n\n\n                    cvect_ho[sig_inds] = sig_pert_set # apply the perturbation to the state\n                    cvect_h, char_h = self._bnet.net_state_compute(cvect_ho,\n                                                               self._bnet._A_bool_f,\n                                                               n_max_steps=n_max_steps,\n                                                               verbose=False,\n                                                               constraint_inds=self._bnet.input_node_inds,\n                                                               constraint_vals=list(sig_pert_set),\n                                                               )\n\n                    # FIXME: the find_state_match method should use the equm' char as well as the state values!\n                    # match the network state to one that only involves the hub nodes:\n                    held_state, match_error_held = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                                cvect_h[state_node_inds])\n\n                    if match_error_held &gt; 0.01: # if held state is unmatched, flag it with a nan\n                        solsM_all = np.column_stack((solsM_all, cvect_h))\n                        charM_all = np.hstack((charM_all, char_h))\n                        held_state = solsM_all.shape[1] - 1\n\n                        sc_dict2 = states_dict_2[sig_base_set]['States']\n                        sc_dict2.append(held_state)\n                        states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                        if verbose:\n                            print(f'WARNING: Held state not found (error {match_error_held}); '\n                                  f'adding new state {held_state} to the solution set...')\n\n                    transition_edges_set.add((initial_state, held_state, pert_input_label))\n                    if verbose:\n                        print(f'...State {initial_state} to {held_state} via I{pert_input_label}...')\n\n                    # Next, re-apply the initial context input state to the held state and see what final state results:\n                    cvect_h[sig_inds] = sig_base_set\n\n                    # find the stable state that results from re-applying the context input state to the held state:\n                    cvect_f, char_f = self._bnet.net_state_compute(cvect_h,\n                                                               self._bnet._A_bool_f,\n                                                               n_max_steps=n_max_steps,\n                                                               verbose=False,\n                                                               constraint_inds=self._bnet.input_node_inds,\n                                                               constraint_vals=list(sig_base_set),\n                                                               )\n\n                    final_state, match_error_final = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                          cvect_f[state_node_inds])\n                    # held_state, match_error_held = self._find_state_match(solsM_all, c_held)\n\n                    if match_error_final &gt; 0.01: # if state is unmatched, flag it\n                        solsM_all = np.column_stack((solsM_all, cvect_f))\n                        charM_all = np.hstack((charM_all, char_f))\n                        final_state = solsM_all.shape[1] -1\n\n                        sc_dict2 = states_dict_2[sig_base_set]['States']\n                        sc_dict2.append(final_state)\n                        states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                        if verbose:\n                            print(f'WARNING: Final state not found (error {match_error_final}); '\n                                  f'adding new state {final_state} to the solution set...')\n\n                    transition_edges_set.add((held_state, final_state, base_input_label))\n                    if verbose:\n                        print(f'...State {held_state} to {final_state} via I{base_input_label}')\n\n                    # Look for change in the system from initial to final state:\n\n                    if initial_state != final_state:  # add this to the perturbed transitions:\n                        perturbation_edges_set.add((initial_state, final_state, pert_input_label, base_input_label))\n\n                        if verbose:\n                            print(f'Event-driven transition identified from State {initial_state} to {final_state} via '\n                                  f'event I{pert_input_label} under context I{base_input_label}')\n\n                    num_step += 1\n\n                    # if verbose:\n                    #     # print(f'Match errors {match_error_initial, match_error_held, match_error_final}')\n                    #     print('------')\n\n        # The first thing we do after the construction of the\n        # transition edges set is make a multidigraph and\n        # use networkx to pre-process &amp; simplify it, removing inaccessible states\n        # (states with no non-self input degree)\n\n        self._solsM_all = solsM_all\n        self._states_dict = states_dict_2\n        self._sig_test_set = sig_test_set\n        self._charM_all = charM_all\n        # self._charM_all = np.hstack((self._charM_all, charM_ext))\n\n        # Create the multidigraph:\n        GG = nx.MultiDiGraph()\n\n        for ndei, ndej, trans_label_ij in list(transition_edges_set):\n            # Annoyingly, nodes must be strings in order to save properly...\n            GG.add_edge(str(ndei), str(ndej), key=f'I{trans_label_ij}')\n\n        if remove_inaccessible_states:\n            # Remove nodes that have no input degree other than their own self-loop:\n            nodes_with_selfloops = list(nx.nodes_with_selfloops(GG))\n            for node_lab, node_in_deg in list(GG.in_degree()):\n                if (node_in_deg == 1 and node_lab in nodes_with_selfloops) or node_in_deg == 0:\n                    GG.remove_node(node_lab)\n\n        if save_graph_file:\n            nx.write_gml(GG, save_graph_file)\n\n        self.G_states = GG\n\n        return transition_edges_set, perturbation_edges_set, GG\n\n    def plot_state_transition_network(self,\n                                      nodes_listo: list,\n                                      edges_list: list,\n                                      charM_all: list|ndarray,\n                                      save_file: str|None = None,\n                                      graph_layout: str='dot',\n                                      mono_edge: bool = False,\n                                      rank: str='same',\n                                      constraint: bool = False,\n                                      concentrate: bool = True,\n                                      fontsize: float = 18.0,\n                                      node_colors: list|None = None,\n                                      cmap_str: str = 'rainbow_r',\n                                      transp_str: str = '80',\n                                      ) -&gt; AGraph:\n        '''\n        This method creates a plot of a general network finite state machine (G-NFSM), which has nodes representing\n        equilibrium states of a regulatory network, edges as the transition between two equilibrium states, and\n        the label on each edge representing the input state index applied and held to transition the network\n        between the two equilibrium states. The result is saved to an image file on disk.\n\n        Parameters\n        ----------\n        nodes_listo : list\n            List of nodes forming the G-NFSM.\n        edges_list : list\n            List of edges forming the G-NFSM.\n        charM_all : list|ndarray\n            The dynamic characteristic of all unique equilbrium states.\n        save_file : str|None, default: None\n            The complete directory and filename to save an image of the G-NFSM graph (as 'png' or 'svg').\n        graph_layout : str, default:'dot'\n            Graphviz layout for the graph.\n        mono_edge : bool, default: False\n            Merge close edges into a single path (`True`)?\n        rank : str, default:'same'\n            Graphviz rank key.\n        constraint : bool, default: False\n            Graphviz constraint key.\n        concentrate : bool, default: True\n            Graphviz concentrate key.\n        fontsize : float, default: 18.0\n            Font size to use on node labels.\n        node_colors : list|None, default: None\n            Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).\n        cmap_str : str, default: 'rainbow_r'\n            Colormap to use to color the nodes.\n        transp_str : str, default: '80'\n            Transparancy (as a hex value) to lighten the node coloring.\n\n        Returns\n        -------\n        AGraph\n            The pygraphviz object representing the G-NFSM.\n\n        '''\n        # Convert nodes from string to int\n        self._charM_all = charM_all\n        nodes_list = [int(ni) for ni in nodes_listo]\n        img_pos = 'bc'  # position of the glyph in the node\n        subcluster_font = 'DejaVu Sans Bold'\n        node_shape = 'ellipse'\n        clr_map = cmap_str\n        nde_font_color = 'Black'\n        hex_transparency = transp_str\n\n        # Try to make a nested graph:\n        G = pgv.AGraph(strict=mono_edge,\n                       fontname=subcluster_font,\n                       splines=True,\n                       directed=True,\n                       concentrate=concentrate,\n                       constraint=constraint,\n                       rank=rank,\n                       dpi=300)\n\n        cmap = colormaps[clr_map]\n\n        if node_colors is None:\n            norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n        else:\n            norm = colors.Normalize(vmin=np.min(node_colors),\n                                    vmax=np.max(node_colors))\n\n        # Add all the nodes:\n        for nde_i in nodes_list:\n            nde_lab = nde_i\n            nde_index = nodes_list.index(nde_i)\n\n            if node_colors is None:\n                nde_color = colors.rgb2hex(cmap(norm(nde_lab)))\n            else:\n                nde_color = colors.rgb2hex(cmap(norm(node_colors[nde_lab])))\n\n            nde_color += hex_transparency  # add some transparancy to the node\n\n            char_i = charM_all[nde_i].name # Get the stability characterization for this state\n\n            G.add_node(nde_i,\n                           label=f'State {nde_lab}',\n                           labelloc='t',\n                           image=self._node_image_dict[char_i],\n                           imagepos=img_pos,\n                           shape=node_shape,\n                           fontcolor=nde_font_color,\n                           style='filled',\n                           fillcolor=nde_color)\n\n\n        # Add all the edges:\n        for nde_i, nde_j, trans_ij in edges_list:\n            G.add_edge(nde_i, nde_j, label=trans_ij, fontsize=fontsize)\n\n        if save_file is not None:\n            G.layout(prog=graph_layout)\n            G.draw(save_file)\n\n        return G\n\n    def plot_state_perturbation_network(self,\n                                       pert_edges_set: set,\n                                       charM_all: list | ndarray,\n                                       nodes_listo: list|ndarray,\n                                       save_file: str|None = None,\n                                       graph_layout: str = 'dot',\n                                       mono_edge: bool=False,\n                                       rank: str = 'same',\n                                       constraint: bool=False,\n                                       concentrate: bool=True,\n                                       fontsize: float = 18.0,\n                                       node_colors: list | None = None,\n                                        cmap_str: str = 'rainbow_r',\n                                        transp_str: str='80',\n                                        ):\n        '''\n        This method creates a plot of an event-driven network finite state machine (E-NFSM), which has nodes representing\n        equilibrium states of a regulatory network, edges as the transition between two equilibrium states occuring under\n        the application of a transiently applied input signal, and a more 'permanent' input signal to which the\n        system returns after the transient perturbation.\n\n        An input state can be associated with several possible equilibrium\n        states if the network has multistability. If this is the case, then the\n        equilibrium state that the system transitions to depends not only on the applied input\n        state, but also the equilibrium state that the system is in to begin with.\n\n        To capture this path dependency, here we create a graph with subgraphs, where each subgraph\n        represents the possible states for a\n        held input state (the 'held context' case is represented by the subgraph).\n        In the case of multistability, temporary\n        perturbations to the held input state can result in transitions between\n        the multistable states. The\n        sub-graph indicates which temporarily-applied input signal leads to which state\n        transition via the edge label. Input signal states are represented as\n        integers, where the integer codes for a binary bit string of signal state values; equilibrium states\n        are indexed according to their column index in solsM_all.\n\n        The result is saved to an image file on disk.\n\n        Parameters\n        ----------\n        nodes_listo : list\n            List of nodes forming the E-NFSM.\n        pert_edges_set : set\n            List of edges forming the E-NFSM.\n        charM_all : list|ndarray\n            The dynamic characteristic of all unique equilbrium states.\n        save_file : str|None, default: None\n            The complete directory and filename to save an image of the E-NFSM graph (as 'png' or 'svg').\n        graph_layout : str, default:'dot'\n            Graphviz layout for the graph.\n        mono_edge : bool, default: False\n            Merge close edges into a single path (`True`)?\n        rank : str, default:'same'\n            Graphviz rank key.\n        constraint : bool, default: False\n            Graphviz constraint key.\n        concentrate : bool, default: True\n            Graphviz concentrate key.\n        fontsize : float, default: 18.0\n            Font size to use on node labels.\n        node_colors : list|None, default: None\n            Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).\n        cmap_str : str, default: 'rainbow_r'\n            Colormap to use to color the nodes.\n        transp_str : str, default: '80'\n            Transparancy (as a hex value) to lighten the node coloring.\n\n        Returns\n        -------\n        AGraph\n            The pygraphviz object representing the E-NFSM.\n        '''\n\n\n        nodes_list = [int(ni) for ni in nodes_listo] # convert nodes from string to int\n\n        img_pos = 'bc'  # position of the glyph in the node\n        subcluster_font = 'DejaVu Sans Bold'\n        node_shape = 'ellipse'\n        clr_map = cmap_str\n        nde_font_color = 'Black'\n        hex_transparency = transp_str\n\n        # Make a nested graph with compound=True keyword:\n        G = pgv.AGraph(strict=mono_edge,\n                       fontname=subcluster_font,\n                       splines=True,\n                       directed=True,\n                       concentrate=concentrate,\n                       constraint=constraint,\n                       compound=True,\n                       rank=rank,\n                       dpi=300)\n\n        cmap = colormaps[clr_map]\n\n        if node_colors is None:\n            norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n        else:\n            norm = colors.Normalize(vmin=np.min(node_colors), vmax=np.max(node_colors))\n\n        for st_i, st_f, i_pert, i_base in pert_edges_set:\n            # Add in a subgraph box for the \"held\" input node state:\n            Gsub = G.add_subgraph(name=f'cluster_{i_base}', label=f'Held at I{i_base}')\n\n            # next add-in nodes for the initial state:\n            nde_i_name = f'{st_i}.{i_base}' # node name is in terms of the subgraph box index\n            nde_i_lab = f'State {st_i}'\n\n            if node_colors is None:\n                nde_i_color = colors.rgb2hex(cmap(norm(st_i)))\n                nde_f_color = colors.rgb2hex(cmap(norm(st_f)))\n            else:\n                nde_i_color = colors.rgb2hex(cmap(norm(node_colors[st_i])))\n                nde_f_color = colors.rgb2hex(cmap(norm(node_colors[st_f])))\n\n            nde_i_color += hex_transparency  # add some transparency to the node\n            nde_f_color += hex_transparency  # add some transparency to the node\n\n            chr_i = charM_all[st_i].name\n\n            Gsub.add_node(nde_i_name,\n                          label=nde_i_lab,\n                          labelloc='t',\n                          image=self._node_image_dict[chr_i],\n                          imagepos=img_pos,\n                          shape=node_shape,\n                          fontcolor=nde_font_color,\n                          style='filled',\n                          fillcolor=nde_i_color\n                          )\n\n            # ...and for the final state:\n            nde_f_name = f'{st_f}.{i_base}' # node name is in terms of the subgraph box index\n            nde_f_lab = f'State {st_f}'\n\n\n            chr_f = charM_all[st_f].name\n\n            Gsub.add_node(nde_f_name,\n                          label=nde_f_lab,\n                          labelloc='t',\n                          image=self._node_image_dict[chr_f],\n                          imagepos=img_pos,\n                          shape=node_shape,\n                          fontcolor=nde_font_color,\n                          style='filled',\n                          fillcolor=nde_f_color\n                          )\n\n            Gsub.add_edge(nde_i_name, nde_f_name, label=f'I{i_pert}', fontsize=fontsize)\n\n        if save_file is not None:\n            G.layout(prog=graph_layout)\n            G.draw(save_file)\n\n        return G\n\n    def sim_sequence_trajectory(self,\n                                starting_state: int,\n                                solsM_all: ndarray,\n                                inputs_list: list[str],\n                                sig_test_set: ndarray,\n                                n_seq_steps: int = 20,\n                                verbose: bool=True,\n                                match_tol: float=0.1\n                                ):\n        '''\n\n        '''\n        cc_o = solsM_all[:, starting_state] # obtain the starting state of the system\n\n        sigs_vect_list = []\n        for sig_nme in inputs_list:\n            sig_i = int(sig_nme[1:]) # get the integer representing the input state\n            sigs_vect_list.append(sig_test_set[sig_i].tolist()) # append the complete input signal to the list\n\n        seq_tvect, seq_res, sol_res, sol_char_res, phase_inds = self._bnet.net_multisequence_compute(cc_o,\n                                                                              sigs_vect_list,\n                                                                              self._bnet._A_bool_f,\n                                                                              n_max_steps=n_seq_steps,\n                                                                              constraint_inds=self._bnet.input_node_inds,\n                                                                              verbose=False)\n\n        matched_states = []\n        matched_char = []\n\n        for cc_new, char_new in zip(sol_res, sol_char_res):\n            new_state, match_error = self._find_state_match(solsM_all[self._bnet.noninput_node_inds, :],\n                                                           cc_new[self._bnet.noninput_node_inds])\n            matched_states.append(new_state)\n            matched_char.append(char_new)\n\n            if verbose:\n                if match_error &lt; match_tol:\n                    print(f'Detected State {new_state}, with error {match_error}')\n                else:\n                    print(f'WARNING! Best match State {new_state} exceeds match_error with error {match_error}!')\n\n        return seq_tvect, seq_res, matched_states, matched_char, phase_inds\n\n    def plot_sequence_trajectory(self,\n                             c_time: ndarray,\n                             tvectr: ndarray|list,\n                             phase_inds: ndarray|list,\n                             matched_states: ndarray|list,\n                             char_states: ndarray|list,\n                             gene_plot_inds: list|None=None,\n                             figsize: tuple = (10, 4),\n                             state_label_offset: float = 0.02,\n                             glyph_zoom: float=0.15,\n                             glyph_alignment: tuple[float, float]=(-0.0, -0.15),\n                             fontsize: str='medium',\n                             save_file: str|None = None,\n                             legend: bool=True,\n                             ):\n        '''\n\n        '''\n\n        if gene_plot_inds is None:\n            main_c = c_time[:, self._bnet.noninput_node_inds]\n        else:\n            main_c = c_time[:, gene_plot_inds]\n\n        N_plot_genes = main_c.shape[1]\n\n        # Resize the figure to fit the panel of plotted genes:\n        fig_width = figsize[0]\n        fig_height = figsize[1]\n        figsize = (fig_width, fig_height*N_plot_genes)\n\n        cmap = plt.get_cmap(\"tab10\")\n\n        fig, axes = plt.subplots(N_plot_genes, 1, figsize=figsize, sharex=True, sharey=True)\n        for ii, cc in enumerate(main_c.T):\n            # gene_lab = f'Gene {ii}'\n            gene_lab = np.asarray(self._bnet.nodes_list)[gene_plot_inds[ii]]\n            lineplt = axes[ii].plot(tvectr, cc, linewidth=2.0, label=gene_lab, color=cmap(ii))  # plot the time series\n            # annotate the plot with the matched state:\n            for (pi, pj), stateio, chario in zip(phase_inds, matched_states, char_states):\n                statei = stateio\n\n                char_i = chario.name\n                char_i_fname = self._node_image_dict[char_i]\n                logo = image.imread(char_i_fname)\n                imagebox = OffsetImage(logo, zoom=glyph_zoom)\n                pmid = int((pi + pj)/2)\n                tmid = tvectr[pmid]\n                cc_max = np.max(cc[pi:pj])\n                cmid = cc_max + state_label_offset\n\n                axes[ii].text(tmid, cmid, f'State {statei}', fontsize=fontsize)\n\n                ab = AnnotationBbox(imagebox,\n                                    (tmid, cmid),\n                                    frameon=False,\n                                    box_alignment=glyph_alignment)\n                axes[ii].add_artist(ab)\n\n                axes[ii].spines['top'].set_visible(False)\n                axes[ii].spines['right'].set_visible(False)\n\n                axes[ii].set_ylabel('Expression Probability')\n\n                if legend:\n                    axes[ii].legend(frameon=False)\n\n        axes[-1].set_xlabel('Time')\n\n        if save_file is not None:\n            plt.savefig(save_file, dpi=300, transparent=True, format='png')\n\n        return fig, axes\n\n    def get_state_distance_matrix(self, solsM_all):\n        '''\n        Returns a matrix representing the L2 norm 'distance'\n        between each state in the array of all possible states.\n\n        '''\n        num_sols = solsM_all.shape[1]\n        state_distance_M = np.zeros((num_sols, num_sols))\n        for i in range(num_sols):\n            for j in range(num_sols):\n                # d_states = np.sqrt(np.sum((solsM_all[:,i] - solsM_all[:, j])**2))\n                d_states = np.sqrt(\n                    np.sum((solsM_all[self._bnet.noninput_node_inds, i] -\n                            solsM_all[self._bnet.noninput_node_inds, j]) ** 2))\n                state_distance_M[i, j] = d_states\n\n        return state_distance_M\n\n    def _get_input_signals_from_label_dict(self, sig_test_set: ndarray | list):\n        '''\n\n        '''\n        # Would be very useful to have a lookup dictionary between the integer input\n        # state label and the original signals tuple:\n        input_int_to_signals = {}\n\n        for int_label, input_sigs in enumerate(sig_test_set):\n            # int_label = self._get_integer_label(input_sigs)\n            input_int_to_signals[f'I{int_label}'] = tuple(input_sigs)\n\n        return input_int_to_signals\n\n    def _order_states_by_distance(self, solsM_all, charM_all):\n        '''\n        Re-arrange the supplied solution matrix so that the states are\n        progressively closer to one another, in order to see a more\n        logical transition through the network with perturbation.\n        '''\n        zer_sol = np.zeros(solsM_all[:, 0].shape)\n        dist_list = []\n\n        for soli in solsM_all.T:\n            # calculate the \"distance\" between the two solutions\n            # and append to the distance list:\n            dist_list.append(np.sqrt(np.sum((zer_sol[self._bnet.noninput_node_inds] -\n                                             soli[self._bnet.noninput_node_inds]) ** 2)))\n\n        inds_sort = np.argsort(dist_list)\n\n        solsM_all = solsM_all[:, inds_sort]\n        charM_all = charM_all[inds_sort]\n\n        return solsM_all, charM_all\n\n    def _get_index_from_val(self, val_vect: ndarray, val: float, val_overlap: float):\n        '''\n        Given a value in an array, this method returns the index\n        of the closest value in the array.\n\n        Parameters\n        -----------\n        val_vect : ndarray\n            The vector of values to which the closest index to val is sought.\n\n        val: float\n            A value for which the closest matched index in val_vect is to be\n            returned.\n\n        val_overlap: float\n            An amount of overlap to include in search windows to ensure the\n            search will return at least one index.\n        '''\n        inds_l = (val_vect &lt;= val + val_overlap).nonzero()[0]\n        inds_h = (val_vect &gt;= val - val_overlap).nonzero()[0]\n        indo = np.intersect1d(inds_l, inds_h)\n        if len(indo):\n            ind = indo[0]\n        else:\n            raise Exception(\"No matching index was found.\")\n\n        return ind\n\n    def _find_state_match(self,\n                         solsM: ndarray,\n                         cvecti: list | ndarray) -&gt; tuple:\n        '''\n        Given a matrix of possible states and a concentration vector,\n        return the state that best-matches the concentration vector,\n        along with an error for the comparison.\n\n        Parameters\n        ----------\n        solsM : ndarray\n            A matrix with a set of steady-state solutions arranged in\n            columns.\n\n        cvecti : list\n            A list of concentrations with which to compare with each\n            steady-state in solsM, in order to select a best-match state\n            from solsM to cvecti.\n\n        Returns\n        -------\n        state_best_match\n            The index of the best-match state in solsM\n        err\n            The error to the match\n        '''\n\n        # now what we need is a pattern match from concentrations to the stable states:\n        errM = []\n        for soli in solsM.T:\n            sdiff = soli - cvecti\n            errM.append(np.sqrt(np.sum(sdiff ** 2)))\n        errM = np.asarray(errM)\n        state_best_match = (errM == errM.min()).nonzero()[0][0]\n\n        return state_best_match, errM[state_best_match]\n\n    def plot_input_words_array(self,\n                        sig_test_set: ndarray,\n                        gene_list: list|ndarray,\n                        figsave: str | None = None,\n                        cmap: str | None =None,\n                        save_format: str='png',\n                        figsize: tuple=(10,10)):\n        '''\n\n        '''\n\n        if cmap is None:\n            cmap = 'magma'\n\n        state_labels = [f'I{i}' for i in range(sig_test_set.shape[0])]\n\n        gene_labels = np.asarray(gene_list)\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        im = ax.imshow(sig_test_set, cmap=cmap)\n\n        ax.set_xticks(np.arange(len(gene_labels)), labels=gene_labels)\n        ax.set_yticks(np.arange(len(state_labels)), labels=state_labels)\n\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n                 rotation_mode=\"anchor\")\n        fig.colorbar(im, label='Expression Level')\n\n        if figsave is not None:\n            plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n        return fig, ax\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.__init__","title":"<code>__init__(bnet)</code>","text":"<p>Initialize the <code>BoolStateMachine</code>.</p> <p>Parameters:</p> Name Type Description Default <code>bnet</code> <code>BooleanNet</code> <p>An instance of <code>BooleanNet</code>.</p> required Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def __init__(self, bnet: BooleanNet):\n    '''\n    Initialize the `BoolStateMachine`.\n\n    Parameters\n    ----------\n    bnet : BooleanNet\n        An instance of [`BooleanNet`][cellnition.science.network_models.boolean_networks.BooleanNet].\n    '''\n\n    self._bnet = bnet\n    self.G_states = None # The state transition network\n\n    # Path to load image assets:\n    GLYPH_DIR = get_data_png_glyph_stability_dir()\n    attractor_fname = FileRelative(GLYPH_DIR, 'glyph_attractor.png')\n    limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_limit_cycle.png')\n    saddle_fname = FileRelative(GLYPH_DIR, 'glyph_saddle.png')\n    attractor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_attractor_limit_cycle.png')\n    repellor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_repellor_limit_cycle.png')\n    repellor_fname = FileRelative(GLYPH_DIR, 'glyph_repellor.png')\n    unknown_fname = FileRelative(GLYPH_DIR, 'glyph_unknown.png')\n    hidden_fname = FileRelative(GLYPH_DIR, 'glyph_hidden.png')\n\n    # Associate each equilibrium type with an image file\n    self._node_image_dict = {\n        EquilibriumType.attractor.name: str(attractor_fname),\n        EquilibriumType.limit_cycle.name: str(limitcycle_fname),\n        EquilibriumType.saddle.name: str(saddle_fname),\n        EquilibriumType.attractor_limit_cycle.name: str(attractor_limitcycle_fname),\n        EquilibriumType.repellor_limit_cycle.name: str(repellor_limitcycle_fname),\n        EquilibriumType.repellor.name: str(repellor_fname),\n        EquilibriumType.undetermined.name: str(unknown_fname),\n        EquilibriumType.hidden.name: str(hidden_fname)\n    }\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.create_transition_network","title":"<code>create_transition_network(states_dict, sig_test_set, solsM_allo, charM_allo, verbose=True, remove_inaccessible_states=False, save_graph_file=None, n_max_steps=10, output_nodes_only=False)</code>","text":"<p>This method builds the Network Finite State Machine by starting the system in different equilibrium states, applying different input signals, and seeing which equilibrium state the system ends up in after a time simulation.</p> <p>Parameters:</p> Name Type Description Default <code>states_dict</code> <code>dict</code> <p>A dictionary with keys as tuples representing each input state, and values being the equilibrium state index as the column index of <code>solsM</code>. This is returned by `steady_state_solutions_search'.</p> required <code>sig_test_set</code> <code>list | ndarray</code> <p>An array containing each of the input states (i.e. all binary-node-level combinations of <code>BooleanNet.input_node_inds</code>) which were applied to the network, for which equilibrium states of the network were found. This is returned by `steady_state_solutions_search'.</p> required <code>solsM_allo</code> <code>ndarray</code> <p>The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row representing the node expression level. This is returned by `steady_state_solutions_search'.</p> required <code>charM_allo</code> <code>ndarray</code> <p>The dynamic characterization of each equilibrium state in solsM, as a linear array of <code>EquilibriumType</code> enumerations. This is returned by `steady_state_solutions_search'.</p> required <code>verbose</code> <code>bool</code> <p>Print output while solving (<code>True</code>)?</p> <code>True</code> <code>remove_inaccessible_states</code> <code>bool</code> <p>If there are states in the NFSM that aren't reachable by any other state, remove them? (Don't think this variable currently works).</p> <code>False</code> <code>save_graph_file</code> <code>str | None</code> <p>Full directory and filename to save a gml format graph of the resulting G-NFSM.</p> <code>None</code> <code>n_max_steps</code> <code>int</code> <p>The maximum number of steps that the Boolean regulatory network solver should use in determining each eq'm. It is recommended that <code>n_max_steps</code> be greater than twice the total node number (i.e. <code>n_max_steps &gt;= 2*BooleanNet.N_nodes</code>).</p> <code>10</code> <code>output_nodes_only</code> <code>bool</code> <p>Define the uniqueness of equilibrium states using only the <code>BooleanNet.output_node_inds</code> (<code>True</code>) or by using all non-input node inds using <code>BooleanNet.noninput_node_inds</code> (<code>False</code>)?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>transition_edges_set</code> <code>set</code> <p>Set containing tuples defining all edges representing transitions of the general-NFSM (G-NFSM). Each tuple marks the transition from eq'm state i to j under the action of input state k, so (i, j, k). Eq'm state indices are to the columns of <code>solsM_allo</code>, and input state indices are to <code>sig_test_set</code>. Note, as new eq'm states may be detected during the run of this method, <code>self._solsM_all</code> and <code>self._charM_all</code> should be used to reference eq'm states and their characterization instead of the original <code>solsM_allo</code> and <code>charM_allo</code>.</p> <code>perturbation_edges_set</code> <code>set</code> <p>Set containing tuples defining all edges representing transitions of the event-driven NFSM (E-NFSM). Each tuple marks the transition from eq'm state i to j under the action of transiently held input state k, where the system is returned to the base input state l, so (i, j, k, l). Eq'm state indices are to the columns of <code>solsM_allo</code>, and input state indices are to <code>sig_test_set</code>. Note, as new eq'm states may be detected during the run of this method, <code>self._solsM_all</code> and <code>self._charM_all</code> should be used to reference eq'm states and their characterization instead of the original <code>solsM_allo</code> and <code>charM_allo</code>.</p> <code>GG</code> <code>MultiDiGraph</code> <p>The networkx MultiDiGraph object representing the G-NFSM.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def create_transition_network(self,\n                              states_dict: dict,\n                              sig_test_set: list|ndarray,\n                              solsM_allo: ndarray,\n                              charM_allo: ndarray,\n                              verbose: bool = True,\n                              remove_inaccessible_states: bool=False,\n                              save_graph_file: str|None = None,\n                              n_max_steps: int=10,\n                              output_nodes_only: bool = False\n                              ) -&gt; tuple[set, set, MultiDiGraph]:\n    '''\n    This method builds the Network Finite State Machine by starting the system\n    in different equilibrium states, applying different input signals, and seeing\n    which equilibrium state the system ends up in after\n    a time simulation.\n\n    Parameters\n    ----------\n    states_dict : dict\n        A dictionary with keys as tuples representing each input state, and values being the equilibrium\n        state index as the column index of `solsM`. This is returned by `steady_state_solutions_search'.\n    sig_test_set : list|ndarray\n        An array containing each of the input states (i.e. all binary-node-level combinations of\n        `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n        of the network were found. This is returned by `steady_state_solutions_search'.\n    solsM_allo : ndarray\n        The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n        representing the node expression level. This is returned by `steady_state_solutions_search'.\n    charM_allo : ndarray\n        The dynamic characterization of each equilibrium state in solsM, as a linear array of\n        [`EquilibriumType`][cellnition.science.network_models.network_enums.EquilibriumType]\n        enumerations. This is returned by `steady_state_solutions_search'.\n    verbose : bool, default: True\n        Print output while solving (`True`)?\n    remove_inaccessible_states : bool, default: False\n        If there are states in the NFSM that aren't reachable by any other state, remove them? (Don't think\n        this variable currently works).\n    save_graph_file: str|None, default: None\n        Full directory and filename to save a gml format graph of the resulting G-NFSM.\n    n_max_steps: int, default: 10\n        The maximum number of steps that the Boolean regulatory network solver should use in\n        determining each eq'm. It is recommended that `n_max_steps` be greater than twice the\n        total node number (i.e. `n_max_steps &gt;= 2*BooleanNet.N_nodes`).\n    output_nodes_only: bool, default: False\n        Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n        by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n    Returns\n    -------\n    transition_edges_set : set\n        Set containing tuples defining all edges representing transitions of the general-NFSM (G-NFSM).\n        Each tuple marks the transition from eq'm state i to j under the action of input state k, so (i, j, k).\n        Eq'm state indices are to the columns of `solsM_allo`, and input state indices are to `sig_test_set`.\n        Note, as new eq'm states\n        may be detected during the run of this method, `self._solsM_all` and `self._charM_all` should be used to\n        reference eq'm states and their characterization instead of the original `solsM_allo` and `charM_allo`.\n    perturbation_edges_set : set\n        Set containing tuples defining all edges representing transitions of the event-driven NFSM (E-NFSM).\n        Each tuple marks the transition from eq'm state i to j under the action of transiently held input state k,\n        where the system is returned to the base input state l, so (i, j, k, l).\n        Eq'm state indices are to the columns of `solsM_allo`, and input state indices are to `sig_test_set`.\n        Note, as new eq'm states may be detected during the run of this method,\n        `self._solsM_all` and `self._charM_all` should be used to\n        reference eq'm states and their characterization instead of the original `solsM_allo` and `charM_allo`.\n    GG : MultiDiGraph\n        The networkx MultiDiGraph object representing the G-NFSM.\n\n    '''\n\n    # make a copy of solsM_all:\n    solsM_all = solsM_allo.copy()\n    charM_all = charM_allo.copy()\n\n    # make a copy of the states dict that's only used for modifications:\n    states_dict_2 = copy.deepcopy(states_dict)\n\n    # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n    if output_nodes_only is True and len(self._bnet.output_node_inds):\n        state_node_inds = self._bnet.output_node_inds\n    else:\n        state_node_inds = self._bnet.noninput_node_inds\n\n    # States for perturbation of the zero state inputs\n    # Let's start the system off in the zero vector, then\n    # temporarily perturb the system with each signal set and see what the final state is after\n    # the perturbation.\n\n    sig_inds = self._bnet.input_node_inds\n\n    transition_edges_set = set()\n    perturbation_edges_set = set()\n\n    num_step = 0\n\n    # We want to step through all 'held' signals and potentially multistable states:\n    # The \"base\" refers to the base context of the system:\n    for base_input_label, (sig_base_set, sc_dict) in enumerate(states_dict.items()):\n\n        states_set = sc_dict['States']\n\n        # Get an integer label for the 'bitstring' of signal node inds defining the base:\n        # base_input_label = self._get_integer_label(sig_base_set)\n        # We want to use each state in states_set as the initial condition:\n        for si in states_set:\n        # for si, cvect_co in enumerate(solsM_all.T): # step through all stable states\n\n            if verbose:\n                print(f\"Testing State {si} in held context I{base_input_label}...\")\n\n            cvect_co = solsM_all[:, si]\n\n            # Initial state vector, which will be held at the base_input context\n            cvect_co[sig_inds] = sig_base_set\n            # ensure that this initial state is indeed stable in the context:\n            cvect_c, char_c = self._bnet.net_state_compute(cvect_co,\n                                                           self._bnet._A_bool_f,\n                                                           n_max_steps=n_max_steps,\n                                                           verbose=False,\n                                                           constraint_inds=self._bnet.input_node_inds,\n                                                           constraint_vals=list(sig_base_set),\n                                                           )\n\n            initial_state, match_error_initial = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                  cvect_c[state_node_inds])\n\n            if match_error_initial &gt; 0.01:  # if held state is unmatched, send warning...\n                solsM_all = np.column_stack((solsM_all, cvect_c))\n                charM_all = np.hstack((charM_all, char_c))\n                initial_state = solsM_all.shape[1] - 1\n\n                # Update the states listing for this input state set\n                sc_dict2 = states_dict_2[sig_base_set]['States']\n                sc_dict2.append(initial_state)\n                states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                if verbose:\n                    print(f'WARNING: Initial state not found (error {match_error_initial});'\n                          f' adding new state {initial_state} to the solution set...')\n\n            # Add this transition to the state transition diagram:\n            transition_edges_set.add((si, initial_state, base_input_label))\n\n            # We then step through all possible perturbation signals that act on the state in the set:\n            cvect_ho = cvect_c.copy()\n            for pert_input_label, (sig_pert_set, _) in enumerate(states_dict.items()):\n                if verbose:\n                    print(f\"--- Step: {num_step} ---\")\n                    print(f'...State {si} to {initial_state} via I{base_input_label}...')\n\n\n                cvect_ho[sig_inds] = sig_pert_set # apply the perturbation to the state\n                cvect_h, char_h = self._bnet.net_state_compute(cvect_ho,\n                                                           self._bnet._A_bool_f,\n                                                           n_max_steps=n_max_steps,\n                                                           verbose=False,\n                                                           constraint_inds=self._bnet.input_node_inds,\n                                                           constraint_vals=list(sig_pert_set),\n                                                           )\n\n                # FIXME: the find_state_match method should use the equm' char as well as the state values!\n                # match the network state to one that only involves the hub nodes:\n                held_state, match_error_held = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                            cvect_h[state_node_inds])\n\n                if match_error_held &gt; 0.01: # if held state is unmatched, flag it with a nan\n                    solsM_all = np.column_stack((solsM_all, cvect_h))\n                    charM_all = np.hstack((charM_all, char_h))\n                    held_state = solsM_all.shape[1] - 1\n\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(held_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    if verbose:\n                        print(f'WARNING: Held state not found (error {match_error_held}); '\n                              f'adding new state {held_state} to the solution set...')\n\n                transition_edges_set.add((initial_state, held_state, pert_input_label))\n                if verbose:\n                    print(f'...State {initial_state} to {held_state} via I{pert_input_label}...')\n\n                # Next, re-apply the initial context input state to the held state and see what final state results:\n                cvect_h[sig_inds] = sig_base_set\n\n                # find the stable state that results from re-applying the context input state to the held state:\n                cvect_f, char_f = self._bnet.net_state_compute(cvect_h,\n                                                           self._bnet._A_bool_f,\n                                                           n_max_steps=n_max_steps,\n                                                           verbose=False,\n                                                           constraint_inds=self._bnet.input_node_inds,\n                                                           constraint_vals=list(sig_base_set),\n                                                           )\n\n                final_state, match_error_final = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                      cvect_f[state_node_inds])\n                # held_state, match_error_held = self._find_state_match(solsM_all, c_held)\n\n                if match_error_final &gt; 0.01: # if state is unmatched, flag it\n                    solsM_all = np.column_stack((solsM_all, cvect_f))\n                    charM_all = np.hstack((charM_all, char_f))\n                    final_state = solsM_all.shape[1] -1\n\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(final_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    if verbose:\n                        print(f'WARNING: Final state not found (error {match_error_final}); '\n                              f'adding new state {final_state} to the solution set...')\n\n                transition_edges_set.add((held_state, final_state, base_input_label))\n                if verbose:\n                    print(f'...State {held_state} to {final_state} via I{base_input_label}')\n\n                # Look for change in the system from initial to final state:\n\n                if initial_state != final_state:  # add this to the perturbed transitions:\n                    perturbation_edges_set.add((initial_state, final_state, pert_input_label, base_input_label))\n\n                    if verbose:\n                        print(f'Event-driven transition identified from State {initial_state} to {final_state} via '\n                              f'event I{pert_input_label} under context I{base_input_label}')\n\n                num_step += 1\n\n                # if verbose:\n                #     # print(f'Match errors {match_error_initial, match_error_held, match_error_final}')\n                #     print('------')\n\n    # The first thing we do after the construction of the\n    # transition edges set is make a multidigraph and\n    # use networkx to pre-process &amp; simplify it, removing inaccessible states\n    # (states with no non-self input degree)\n\n    self._solsM_all = solsM_all\n    self._states_dict = states_dict_2\n    self._sig_test_set = sig_test_set\n    self._charM_all = charM_all\n    # self._charM_all = np.hstack((self._charM_all, charM_ext))\n\n    # Create the multidigraph:\n    GG = nx.MultiDiGraph()\n\n    for ndei, ndej, trans_label_ij in list(transition_edges_set):\n        # Annoyingly, nodes must be strings in order to save properly...\n        GG.add_edge(str(ndei), str(ndej), key=f'I{trans_label_ij}')\n\n    if remove_inaccessible_states:\n        # Remove nodes that have no input degree other than their own self-loop:\n        nodes_with_selfloops = list(nx.nodes_with_selfloops(GG))\n        for node_lab, node_in_deg in list(GG.in_degree()):\n            if (node_in_deg == 1 and node_lab in nodes_with_selfloops) or node_in_deg == 0:\n                GG.remove_node(node_lab)\n\n    if save_graph_file:\n        nx.write_gml(GG, save_graph_file)\n\n    self.G_states = GG\n\n    return transition_edges_set, perturbation_edges_set, GG\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.get_state_distance_matrix","title":"<code>get_state_distance_matrix(solsM_all)</code>","text":"<p>Returns a matrix representing the L2 norm 'distance' between each state in the array of all possible states.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def get_state_distance_matrix(self, solsM_all):\n    '''\n    Returns a matrix representing the L2 norm 'distance'\n    between each state in the array of all possible states.\n\n    '''\n    num_sols = solsM_all.shape[1]\n    state_distance_M = np.zeros((num_sols, num_sols))\n    for i in range(num_sols):\n        for j in range(num_sols):\n            # d_states = np.sqrt(np.sum((solsM_all[:,i] - solsM_all[:, j])**2))\n            d_states = np.sqrt(\n                np.sum((solsM_all[self._bnet.noninput_node_inds, i] -\n                        solsM_all[self._bnet.noninput_node_inds, j]) ** 2))\n            state_distance_M[i, j] = d_states\n\n    return state_distance_M\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.plot_input_words_array","title":"<code>plot_input_words_array(sig_test_set, gene_list, figsave=None, cmap=None, save_format='png', figsize=(10, 10))</code>","text":"Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def plot_input_words_array(self,\n                    sig_test_set: ndarray,\n                    gene_list: list|ndarray,\n                    figsave: str | None = None,\n                    cmap: str | None =None,\n                    save_format: str='png',\n                    figsize: tuple=(10,10)):\n    '''\n\n    '''\n\n    if cmap is None:\n        cmap = 'magma'\n\n    state_labels = [f'I{i}' for i in range(sig_test_set.shape[0])]\n\n    gene_labels = np.asarray(gene_list)\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    im = ax.imshow(sig_test_set, cmap=cmap)\n\n    ax.set_xticks(np.arange(len(gene_labels)), labels=gene_labels)\n    ax.set_yticks(np.arange(len(state_labels)), labels=state_labels)\n\n    plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n             rotation_mode=\"anchor\")\n    fig.colorbar(im, label='Expression Level')\n\n    if figsave is not None:\n        plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n    return fig, ax\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.plot_sequence_trajectory","title":"<code>plot_sequence_trajectory(c_time, tvectr, phase_inds, matched_states, char_states, gene_plot_inds=None, figsize=(10, 4), state_label_offset=0.02, glyph_zoom=0.15, glyph_alignment=(-0.0, -0.15), fontsize='medium', save_file=None, legend=True)</code>","text":"Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def plot_sequence_trajectory(self,\n                         c_time: ndarray,\n                         tvectr: ndarray|list,\n                         phase_inds: ndarray|list,\n                         matched_states: ndarray|list,\n                         char_states: ndarray|list,\n                         gene_plot_inds: list|None=None,\n                         figsize: tuple = (10, 4),\n                         state_label_offset: float = 0.02,\n                         glyph_zoom: float=0.15,\n                         glyph_alignment: tuple[float, float]=(-0.0, -0.15),\n                         fontsize: str='medium',\n                         save_file: str|None = None,\n                         legend: bool=True,\n                         ):\n    '''\n\n    '''\n\n    if gene_plot_inds is None:\n        main_c = c_time[:, self._bnet.noninput_node_inds]\n    else:\n        main_c = c_time[:, gene_plot_inds]\n\n    N_plot_genes = main_c.shape[1]\n\n    # Resize the figure to fit the panel of plotted genes:\n    fig_width = figsize[0]\n    fig_height = figsize[1]\n    figsize = (fig_width, fig_height*N_plot_genes)\n\n    cmap = plt.get_cmap(\"tab10\")\n\n    fig, axes = plt.subplots(N_plot_genes, 1, figsize=figsize, sharex=True, sharey=True)\n    for ii, cc in enumerate(main_c.T):\n        # gene_lab = f'Gene {ii}'\n        gene_lab = np.asarray(self._bnet.nodes_list)[gene_plot_inds[ii]]\n        lineplt = axes[ii].plot(tvectr, cc, linewidth=2.0, label=gene_lab, color=cmap(ii))  # plot the time series\n        # annotate the plot with the matched state:\n        for (pi, pj), stateio, chario in zip(phase_inds, matched_states, char_states):\n            statei = stateio\n\n            char_i = chario.name\n            char_i_fname = self._node_image_dict[char_i]\n            logo = image.imread(char_i_fname)\n            imagebox = OffsetImage(logo, zoom=glyph_zoom)\n            pmid = int((pi + pj)/2)\n            tmid = tvectr[pmid]\n            cc_max = np.max(cc[pi:pj])\n            cmid = cc_max + state_label_offset\n\n            axes[ii].text(tmid, cmid, f'State {statei}', fontsize=fontsize)\n\n            ab = AnnotationBbox(imagebox,\n                                (tmid, cmid),\n                                frameon=False,\n                                box_alignment=glyph_alignment)\n            axes[ii].add_artist(ab)\n\n            axes[ii].spines['top'].set_visible(False)\n            axes[ii].spines['right'].set_visible(False)\n\n            axes[ii].set_ylabel('Expression Probability')\n\n            if legend:\n                axes[ii].legend(frameon=False)\n\n    axes[-1].set_xlabel('Time')\n\n    if save_file is not None:\n        plt.savefig(save_file, dpi=300, transparent=True, format='png')\n\n    return fig, axes\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.plot_state_perturbation_network","title":"<code>plot_state_perturbation_network(pert_edges_set, charM_all, nodes_listo, save_file=None, graph_layout='dot', mono_edge=False, rank='same', constraint=False, concentrate=True, fontsize=18.0, node_colors=None, cmap_str='rainbow_r', transp_str='80')</code>","text":"<p>This method creates a plot of an event-driven network finite state machine (E-NFSM), which has nodes representing equilibrium states of a regulatory network, edges as the transition between two equilibrium states occuring under the application of a transiently applied input signal, and a more 'permanent' input signal to which the system returns after the transient perturbation.</p> <p>An input state can be associated with several possible equilibrium states if the network has multistability. If this is the case, then the equilibrium state that the system transitions to depends not only on the applied input state, but also the equilibrium state that the system is in to begin with.</p> <p>To capture this path dependency, here we create a graph with subgraphs, where each subgraph represents the possible states for a held input state (the 'held context' case is represented by the subgraph). In the case of multistability, temporary perturbations to the held input state can result in transitions between the multistable states. The sub-graph indicates which temporarily-applied input signal leads to which state transition via the edge label. Input signal states are represented as integers, where the integer codes for a binary bit string of signal state values; equilibrium states are indexed according to their column index in solsM_all.</p> <p>The result is saved to an image file on disk.</p> <p>Parameters:</p> Name Type Description Default <code>nodes_listo</code> <code>list</code> <p>List of nodes forming the E-NFSM.</p> required <code>pert_edges_set</code> <code>set</code> <p>List of edges forming the E-NFSM.</p> required <code>charM_all</code> <code>list | ndarray</code> <p>The dynamic characteristic of all unique equilbrium states.</p> required <code>save_file</code> <code>str | None</code> <p>The complete directory and filename to save an image of the E-NFSM graph (as 'png' or 'svg').</p> <code>None</code> <code>graph_layout</code> <code>str, default:'dot'</code> <p>Graphviz layout for the graph.</p> <code>'dot'</code> <code>mono_edge</code> <code>bool</code> <p>Merge close edges into a single path (<code>True</code>)?</p> <code>False</code> <code>rank</code> <code>str, default:'same'</code> <p>Graphviz rank key.</p> <code>'same'</code> <code>constraint</code> <code>bool</code> <p>Graphviz constraint key.</p> <code>False</code> <code>concentrate</code> <code>bool</code> <p>Graphviz concentrate key.</p> <code>True</code> <code>fontsize</code> <code>float</code> <p>Font size to use on node labels.</p> <code>18.0</code> <code>node_colors</code> <code>list | None</code> <p>Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).</p> <code>None</code> <code>cmap_str</code> <code>str</code> <p>Colormap to use to color the nodes.</p> <code>'rainbow_r'</code> <code>transp_str</code> <code>str</code> <p>Transparancy (as a hex value) to lighten the node coloring.</p> <code>'80'</code> <p>Returns:</p> Type Description <code>AGraph</code> <p>The pygraphviz object representing the E-NFSM.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def plot_state_perturbation_network(self,\n                                   pert_edges_set: set,\n                                   charM_all: list | ndarray,\n                                   nodes_listo: list|ndarray,\n                                   save_file: str|None = None,\n                                   graph_layout: str = 'dot',\n                                   mono_edge: bool=False,\n                                   rank: str = 'same',\n                                   constraint: bool=False,\n                                   concentrate: bool=True,\n                                   fontsize: float = 18.0,\n                                   node_colors: list | None = None,\n                                    cmap_str: str = 'rainbow_r',\n                                    transp_str: str='80',\n                                    ):\n    '''\n    This method creates a plot of an event-driven network finite state machine (E-NFSM), which has nodes representing\n    equilibrium states of a regulatory network, edges as the transition between two equilibrium states occuring under\n    the application of a transiently applied input signal, and a more 'permanent' input signal to which the\n    system returns after the transient perturbation.\n\n    An input state can be associated with several possible equilibrium\n    states if the network has multistability. If this is the case, then the\n    equilibrium state that the system transitions to depends not only on the applied input\n    state, but also the equilibrium state that the system is in to begin with.\n\n    To capture this path dependency, here we create a graph with subgraphs, where each subgraph\n    represents the possible states for a\n    held input state (the 'held context' case is represented by the subgraph).\n    In the case of multistability, temporary\n    perturbations to the held input state can result in transitions between\n    the multistable states. The\n    sub-graph indicates which temporarily-applied input signal leads to which state\n    transition via the edge label. Input signal states are represented as\n    integers, where the integer codes for a binary bit string of signal state values; equilibrium states\n    are indexed according to their column index in solsM_all.\n\n    The result is saved to an image file on disk.\n\n    Parameters\n    ----------\n    nodes_listo : list\n        List of nodes forming the E-NFSM.\n    pert_edges_set : set\n        List of edges forming the E-NFSM.\n    charM_all : list|ndarray\n        The dynamic characteristic of all unique equilbrium states.\n    save_file : str|None, default: None\n        The complete directory and filename to save an image of the E-NFSM graph (as 'png' or 'svg').\n    graph_layout : str, default:'dot'\n        Graphviz layout for the graph.\n    mono_edge : bool, default: False\n        Merge close edges into a single path (`True`)?\n    rank : str, default:'same'\n        Graphviz rank key.\n    constraint : bool, default: False\n        Graphviz constraint key.\n    concentrate : bool, default: True\n        Graphviz concentrate key.\n    fontsize : float, default: 18.0\n        Font size to use on node labels.\n    node_colors : list|None, default: None\n        Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).\n    cmap_str : str, default: 'rainbow_r'\n        Colormap to use to color the nodes.\n    transp_str : str, default: '80'\n        Transparancy (as a hex value) to lighten the node coloring.\n\n    Returns\n    -------\n    AGraph\n        The pygraphviz object representing the E-NFSM.\n    '''\n\n\n    nodes_list = [int(ni) for ni in nodes_listo] # convert nodes from string to int\n\n    img_pos = 'bc'  # position of the glyph in the node\n    subcluster_font = 'DejaVu Sans Bold'\n    node_shape = 'ellipse'\n    clr_map = cmap_str\n    nde_font_color = 'Black'\n    hex_transparency = transp_str\n\n    # Make a nested graph with compound=True keyword:\n    G = pgv.AGraph(strict=mono_edge,\n                   fontname=subcluster_font,\n                   splines=True,\n                   directed=True,\n                   concentrate=concentrate,\n                   constraint=constraint,\n                   compound=True,\n                   rank=rank,\n                   dpi=300)\n\n    cmap = colormaps[clr_map]\n\n    if node_colors is None:\n        norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n    else:\n        norm = colors.Normalize(vmin=np.min(node_colors), vmax=np.max(node_colors))\n\n    for st_i, st_f, i_pert, i_base in pert_edges_set:\n        # Add in a subgraph box for the \"held\" input node state:\n        Gsub = G.add_subgraph(name=f'cluster_{i_base}', label=f'Held at I{i_base}')\n\n        # next add-in nodes for the initial state:\n        nde_i_name = f'{st_i}.{i_base}' # node name is in terms of the subgraph box index\n        nde_i_lab = f'State {st_i}'\n\n        if node_colors is None:\n            nde_i_color = colors.rgb2hex(cmap(norm(st_i)))\n            nde_f_color = colors.rgb2hex(cmap(norm(st_f)))\n        else:\n            nde_i_color = colors.rgb2hex(cmap(norm(node_colors[st_i])))\n            nde_f_color = colors.rgb2hex(cmap(norm(node_colors[st_f])))\n\n        nde_i_color += hex_transparency  # add some transparency to the node\n        nde_f_color += hex_transparency  # add some transparency to the node\n\n        chr_i = charM_all[st_i].name\n\n        Gsub.add_node(nde_i_name,\n                      label=nde_i_lab,\n                      labelloc='t',\n                      image=self._node_image_dict[chr_i],\n                      imagepos=img_pos,\n                      shape=node_shape,\n                      fontcolor=nde_font_color,\n                      style='filled',\n                      fillcolor=nde_i_color\n                      )\n\n        # ...and for the final state:\n        nde_f_name = f'{st_f}.{i_base}' # node name is in terms of the subgraph box index\n        nde_f_lab = f'State {st_f}'\n\n\n        chr_f = charM_all[st_f].name\n\n        Gsub.add_node(nde_f_name,\n                      label=nde_f_lab,\n                      labelloc='t',\n                      image=self._node_image_dict[chr_f],\n                      imagepos=img_pos,\n                      shape=node_shape,\n                      fontcolor=nde_font_color,\n                      style='filled',\n                      fillcolor=nde_f_color\n                      )\n\n        Gsub.add_edge(nde_i_name, nde_f_name, label=f'I{i_pert}', fontsize=fontsize)\n\n    if save_file is not None:\n        G.layout(prog=graph_layout)\n        G.draw(save_file)\n\n    return G\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.plot_state_transition_network","title":"<code>plot_state_transition_network(nodes_listo, edges_list, charM_all, save_file=None, graph_layout='dot', mono_edge=False, rank='same', constraint=False, concentrate=True, fontsize=18.0, node_colors=None, cmap_str='rainbow_r', transp_str='80')</code>","text":"<p>This method creates a plot of a general network finite state machine (G-NFSM), which has nodes representing equilibrium states of a regulatory network, edges as the transition between two equilibrium states, and the label on each edge representing the input state index applied and held to transition the network between the two equilibrium states. The result is saved to an image file on disk.</p> <p>Parameters:</p> Name Type Description Default <code>nodes_listo</code> <code>list</code> <p>List of nodes forming the G-NFSM.</p> required <code>edges_list</code> <code>list</code> <p>List of edges forming the G-NFSM.</p> required <code>charM_all</code> <code>list | ndarray</code> <p>The dynamic characteristic of all unique equilbrium states.</p> required <code>save_file</code> <code>str | None</code> <p>The complete directory and filename to save an image of the G-NFSM graph (as 'png' or 'svg').</p> <code>None</code> <code>graph_layout</code> <code>str, default:'dot'</code> <p>Graphviz layout for the graph.</p> <code>'dot'</code> <code>mono_edge</code> <code>bool</code> <p>Merge close edges into a single path (<code>True</code>)?</p> <code>False</code> <code>rank</code> <code>str, default:'same'</code> <p>Graphviz rank key.</p> <code>'same'</code> <code>constraint</code> <code>bool</code> <p>Graphviz constraint key.</p> <code>False</code> <code>concentrate</code> <code>bool</code> <p>Graphviz concentrate key.</p> <code>True</code> <code>fontsize</code> <code>float</code> <p>Font size to use on node labels.</p> <code>18.0</code> <code>node_colors</code> <code>list | None</code> <p>Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).</p> <code>None</code> <code>cmap_str</code> <code>str</code> <p>Colormap to use to color the nodes.</p> <code>'rainbow_r'</code> <code>transp_str</code> <code>str</code> <p>Transparancy (as a hex value) to lighten the node coloring.</p> <code>'80'</code> <p>Returns:</p> Type Description <code>AGraph</code> <p>The pygraphviz object representing the G-NFSM.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def plot_state_transition_network(self,\n                                  nodes_listo: list,\n                                  edges_list: list,\n                                  charM_all: list|ndarray,\n                                  save_file: str|None = None,\n                                  graph_layout: str='dot',\n                                  mono_edge: bool = False,\n                                  rank: str='same',\n                                  constraint: bool = False,\n                                  concentrate: bool = True,\n                                  fontsize: float = 18.0,\n                                  node_colors: list|None = None,\n                                  cmap_str: str = 'rainbow_r',\n                                  transp_str: str = '80',\n                                  ) -&gt; AGraph:\n    '''\n    This method creates a plot of a general network finite state machine (G-NFSM), which has nodes representing\n    equilibrium states of a regulatory network, edges as the transition between two equilibrium states, and\n    the label on each edge representing the input state index applied and held to transition the network\n    between the two equilibrium states. The result is saved to an image file on disk.\n\n    Parameters\n    ----------\n    nodes_listo : list\n        List of nodes forming the G-NFSM.\n    edges_list : list\n        List of edges forming the G-NFSM.\n    charM_all : list|ndarray\n        The dynamic characteristic of all unique equilbrium states.\n    save_file : str|None, default: None\n        The complete directory and filename to save an image of the G-NFSM graph (as 'png' or 'svg').\n    graph_layout : str, default:'dot'\n        Graphviz layout for the graph.\n    mono_edge : bool, default: False\n        Merge close edges into a single path (`True`)?\n    rank : str, default:'same'\n        Graphviz rank key.\n    constraint : bool, default: False\n        Graphviz constraint key.\n    concentrate : bool, default: True\n        Graphviz concentrate key.\n    fontsize : float, default: 18.0\n        Font size to use on node labels.\n    node_colors : list|None, default: None\n        Values that should be mapped to nodes (e.g. these may be distance from a 'cancer' state).\n    cmap_str : str, default: 'rainbow_r'\n        Colormap to use to color the nodes.\n    transp_str : str, default: '80'\n        Transparancy (as a hex value) to lighten the node coloring.\n\n    Returns\n    -------\n    AGraph\n        The pygraphviz object representing the G-NFSM.\n\n    '''\n    # Convert nodes from string to int\n    self._charM_all = charM_all\n    nodes_list = [int(ni) for ni in nodes_listo]\n    img_pos = 'bc'  # position of the glyph in the node\n    subcluster_font = 'DejaVu Sans Bold'\n    node_shape = 'ellipse'\n    clr_map = cmap_str\n    nde_font_color = 'Black'\n    hex_transparency = transp_str\n\n    # Try to make a nested graph:\n    G = pgv.AGraph(strict=mono_edge,\n                   fontname=subcluster_font,\n                   splines=True,\n                   directed=True,\n                   concentrate=concentrate,\n                   constraint=constraint,\n                   rank=rank,\n                   dpi=300)\n\n    cmap = colormaps[clr_map]\n\n    if node_colors is None:\n        norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n    else:\n        norm = colors.Normalize(vmin=np.min(node_colors),\n                                vmax=np.max(node_colors))\n\n    # Add all the nodes:\n    for nde_i in nodes_list:\n        nde_lab = nde_i\n        nde_index = nodes_list.index(nde_i)\n\n        if node_colors is None:\n            nde_color = colors.rgb2hex(cmap(norm(nde_lab)))\n        else:\n            nde_color = colors.rgb2hex(cmap(norm(node_colors[nde_lab])))\n\n        nde_color += hex_transparency  # add some transparancy to the node\n\n        char_i = charM_all[nde_i].name # Get the stability characterization for this state\n\n        G.add_node(nde_i,\n                       label=f'State {nde_lab}',\n                       labelloc='t',\n                       image=self._node_image_dict[char_i],\n                       imagepos=img_pos,\n                       shape=node_shape,\n                       fontcolor=nde_font_color,\n                       style='filled',\n                       fillcolor=nde_color)\n\n\n    # Add all the edges:\n    for nde_i, nde_j, trans_ij in edges_list:\n        G.add_edge(nde_i, nde_j, label=trans_ij, fontsize=fontsize)\n\n    if save_file is not None:\n        G.layout(prog=graph_layout)\n        G.draw(save_file)\n\n    return G\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.sim_sequence_trajectory","title":"<code>sim_sequence_trajectory(starting_state, solsM_all, inputs_list, sig_test_set, n_seq_steps=20, verbose=True, match_tol=0.1)</code>","text":"Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def sim_sequence_trajectory(self,\n                            starting_state: int,\n                            solsM_all: ndarray,\n                            inputs_list: list[str],\n                            sig_test_set: ndarray,\n                            n_seq_steps: int = 20,\n                            verbose: bool=True,\n                            match_tol: float=0.1\n                            ):\n    '''\n\n    '''\n    cc_o = solsM_all[:, starting_state] # obtain the starting state of the system\n\n    sigs_vect_list = []\n    for sig_nme in inputs_list:\n        sig_i = int(sig_nme[1:]) # get the integer representing the input state\n        sigs_vect_list.append(sig_test_set[sig_i].tolist()) # append the complete input signal to the list\n\n    seq_tvect, seq_res, sol_res, sol_char_res, phase_inds = self._bnet.net_multisequence_compute(cc_o,\n                                                                          sigs_vect_list,\n                                                                          self._bnet._A_bool_f,\n                                                                          n_max_steps=n_seq_steps,\n                                                                          constraint_inds=self._bnet.input_node_inds,\n                                                                          verbose=False)\n\n    matched_states = []\n    matched_char = []\n\n    for cc_new, char_new in zip(sol_res, sol_char_res):\n        new_state, match_error = self._find_state_match(solsM_all[self._bnet.noninput_node_inds, :],\n                                                       cc_new[self._bnet.noninput_node_inds])\n        matched_states.append(new_state)\n        matched_char.append(char_new)\n\n        if verbose:\n            if match_error &lt; match_tol:\n                print(f'Detected State {new_state}, with error {match_error}')\n            else:\n                print(f'WARNING! Best match State {new_state} exceeds match_error with error {match_error}!')\n\n    return seq_tvect, seq_res, matched_states, matched_char, phase_inds\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine.steady_state_solutions_search","title":"<code>steady_state_solutions_search(verbose=True, search_main_nodes_only=False, n_max_steps=20, order_by_distance=False, node_num_max=None, output_nodes_only=False)</code>","text":"<p>Search through all possible (binary valued) combinations of input nodes (<code>BooleanNet.input_node_inds</code>) to find and dynamically characterize equilibrium state of the regulatory network system.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Print output while solving (<code>True</code>)?</p> <code>True</code> <code>search_main_nodes_only</code> <code>bool</code> <p>Search only the <code>BooleanNet.main_nodes</code> (<code>True</code>) or search all noninput nodes, <code>BooleanNet.noninput_node_inds</code> nodes (<code>False</code>)?</p> <code>False</code> <code>n_max_steps</code> <code>int</code> <p>The maximum number of steps that the Boolean regulatory network solver should use in determining each eq'm. It is recommended that <code>n_max_steps</code> be greater than twice the total node number (i.e. <code>n_max_steps &gt;= 2*BooleanNet.N_nodes</code>).</p> <code>20</code> <code>order_by_distance</code> <code>bool</code> <p>Order states by increasing distance from the zero state (<code>True</code>)?</p> <code>False</code> <code>node_num_max</code> <code>int | None</code> <p>If <code>n_max_steps</code> is <code>True</code>, further limit the search space dimensions to the first node_num_max nodes according to their hierarchical level (i.e. according to <code>BooleanNet.hier_node_level</code>)? We have found that all equilibrium solutions can be returned by selecting the a subset of nodes with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence on the network.</p> <code>None</code> <code>output_nodes_only</code> <code>bool</code> <p>Define the uniqueness of equilibrium states using only the <code>BooleanNet.output_node_inds</code> (<code>True</code>) or by using all non-input node inds using <code>BooleanNet.noninput_node_inds</code> (<code>False</code>)?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>solsM</code> <code>ndarray</code> <p>The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row representing the node expression level.</p> <code>charM_all</code> <code>ndarray</code> <p>The dynamic characterization of each equilibrium state in solsM, as a linear array of <code>EquilibriumType</code> enumerations.</p> <code>sols_list</code> <code>list</code> <p>The list of all (non-unique) equilibrium state solutions in the order that they were found.</p> <code>states_dict</code> <code>OrderedDict</code> <p>A dictionary with keys as tuples representing each input state, and values being the equilibrium state index as the column index of <code>solsM</code>.</p> <code>sig_test_set</code> <code>ndarray</code> <p>An array containing each of the input states (i.e. all binary-node-level combinations of <code>BooleanNet.input_node_inds</code>) which were applied to the network, for which equilibrium states of the network were found.</p> Source code in <code>cellnition/science/networks_toolbox/boolean_state_machine.py</code> <pre><code>def steady_state_solutions_search(self,\n                                  verbose: bool=True,\n                                  search_main_nodes_only: bool = False,\n                                  n_max_steps: int = 20,\n                                  order_by_distance: bool=False,\n                                  node_num_max: int | None = None,\n                                  output_nodes_only: bool = False\n                                  ) -&gt; tuple[ndarray, ndarray, list, OrderedDict, ndarray]:\n    '''\n    Search through all possible (binary valued) combinations of input nodes\n    (`BooleanNet.input_node_inds`) to find and dynamically characterize equilibrium\n    state of the regulatory network system.\n\n    Parameters\n    ----------\n    verbose : bool, default: True\n        Print output while solving (`True`)?\n    search_main_nodes_only : bool, default: False\n        Search only the `BooleanNet.main_nodes` (`True`) or search all noninput nodes,\n        `BooleanNet.noninput_node_inds` nodes (`False`)?\n    n_max_steps : int, default: 20\n        The maximum number of steps that the Boolean regulatory network solver should use in\n        determining each eq'm. It is recommended that `n_max_steps` be greater than twice the\n        total node number (i.e. `n_max_steps &gt;= 2*BooleanNet.N_nodes`).\n    order_by_distance : bool, default: False\n        Order states by increasing distance from the zero state (`True`)?\n    node_num_max : int|None, default: None\n        If `n_max_steps` is `True`, further limit the search space dimensions to the first node_num_max\n        nodes according to their hierarchical level (i.e. according to `BooleanNet.hier_node_level`)?\n        We have found that all equilibrium solutions can be returned by selecting the a subset of nodes\n        with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence\n        on the network.\n    output_nodes_only : bool, default: False\n        Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n        by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n    Returns\n    -------\n    solsM : ndarray\n        The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n        representing the node expression level.\n    charM_all : ndarray\n        The dynamic characterization of each equilibrium state in solsM, as a linear array of\n        [`EquilibriumType`][cellnition.science.network_models.network_enums]\n        enumerations.\n    sols_list : list\n        The list of all (non-unique) equilibrium state solutions in the order that they were found.\n    states_dict : OrderedDict\n        A dictionary with keys as tuples representing each input state, and values being the equilibrium\n        state index as the column index of `solsM`.\n    sig_test_set : ndarray\n        An array containing each of the input states (i.e. all binary-node-level combinations of\n        `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n        of the network were found.\n\n    '''\n    if self._bnet._A_bool_f is None:\n        raise Exception(\"The BooleanNetwork object needs to have an analytical model constructed using\"\n                        \"the build_boolean_model method.\")\n\n    sig_lin = [0, 1]\n\n    sig_lin_set = [sig_lin for i in self._bnet.input_node_inds]\n\n    sigGrid = np.meshgrid(*sig_lin_set)\n\n    N_vocab = len(sigGrid[0].ravel())\n\n    sig_test_set = np.zeros((N_vocab, len(self._bnet.input_node_inds)))\n\n    for i, sigM in enumerate(sigGrid):\n        sig_test_set[:, i] = sigM.ravel()\n\n    # solsM_allo = np.zeros((self._bnet.N_nodes, 1))\n    # charM_allo = [EquilibriumType.undetermined]\n    solsM_allo = None\n    charM_allo = []\n    sols_list = []\n\n    for sigis in sig_test_set:\n        if verbose:\n            print(f'Signals: {sigis}')\n        sols_M, sols_char = self._bnet.solve_system_equms(\n                                                    self._bnet._A_bool_f,\n                                                    constraint_inds=None,\n                                                    constraint_vals=None,\n                                                    signal_constr_vals=sigis.tolist(),\n                                                    search_main_nodes_only=search_main_nodes_only,\n                                                    n_max_steps=n_max_steps,\n                                                    verbose=False,\n                                                    node_num_max=node_num_max\n                                                    )\n        if solsM_allo is None:\n            solsM_allo = sols_M\n        else:\n            solsM_allo = np.hstack((solsM_allo, sols_M))  # append all unique sols\n        charM_allo.extend(sols_char.tolist())  # append the sol stability characterization tags\n        sols_list.append(sols_M)\n        if verbose:\n            print(sols_M)\n            print('----')\n\n    # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n    if output_nodes_only is True and len(self._bnet.output_node_inds):\n        state_node_inds = self._bnet.output_node_inds\n    else:\n        state_node_inds = self._bnet.noninput_node_inds\n\n    # Eliminate duplicate states, but stack on strings of the eqm char\n    # so we don't lose states with the same values but with different eq'm:\n    # chrm = [eqt.name for eqt in charM_allo]\n    # checkM = np.vstack((solsM_allo[state_node_inds, :], chrm))\n    _, inds_solsM_all_unique = np.unique(solsM_allo[state_node_inds, :], return_index=True, axis=1)\n    solsM_all = solsM_allo[:, inds_solsM_all_unique]\n    charM_all = np.asarray(charM_allo)[inds_solsM_all_unique]\n\n    if order_by_distance:\n        # Order states by distance from the zero vector\n        solsM_all, charM_all = self._order_states_by_distance(solsM_all, charM_all)\n\n    states_dict = OrderedDict()\n    for sigi in sig_test_set:\n        states_dict[tuple(sigi)] = {'States': [], 'Stability': []}\n\n    for sigi, state_subseto in zip(sig_test_set, sols_list):\n        state_subset = state_subseto[state_node_inds, :]\n        for target_state in state_subset.T.tolist():\n            state_match_index, err_match = self._find_state_match(solsM_all[state_node_inds, :],\n                                                                  target_state)\n            if state_match_index not in states_dict[tuple(sigi)]['States']:\n                states_dict[tuple(sigi)]['States'].append(state_match_index)\n                states_dict[tuple(sigi)]['Stability'].append(charM_all[state_match_index])\n\n    return solsM_all, charM_all, sols_list, states_dict, sig_test_set\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/","title":"Continuous Finite State Machine","text":"<p>               Bases: <code>object</code></p> <p>Builds and plots Network Finite State Machines (NFSMs) from a regulatory network modelled using continuous, differential equation based functions (see <code>ProbabilityNet</code>). StateMachine first performs a comprehensive search for stable equilibrium states of the regulatory network. It then uses time simulation, starting the system off at every equilibrium state and every input signal, applying a new input signal transiently, and returning the system to the original input signal. It then detects new equilibrium states occupied by the system after the application of each input signal perturbation. The input-driven transitions between states are recorded as the NFSMs of the system.</p> <p>Attributes:</p> Name Type Description <code>G_states</code> <code>MultiDiGraph</code> <p>General NFSM (G-NFSM), where each equilibrium-state of the regulatory network is a node of the G-NFSM, and labeled directed edges indicate the input state (as an edge label) inducing a transition between one equilibrium state and another. This is a networkx MultiDiGraph, which means parallel edges are allowed to exist and therefore it is possible for different signals to transition the system between the same two state. <code>G_states</code> is created using the <code>create_transition_network</code> method.</p> Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>class StateMachine(object):\n    '''\n    Builds and plots Network Finite State Machines (NFSMs) from a regulatory\n    network modelled using continuous, differential equation based functions (see\n    [`ProbabilityNet`][cellnition.science.network_models.probability_networks.ProbabilityNet]).\n    StateMachine first performs a comprehensive search for stable\n    equilibrium states of the regulatory network. It then uses time simulation,\n    starting the system off at every equilibrium state and every input signal,\n    applying a new input signal transiently, and returning the system to the original input signal.\n    It then detects new equilibrium states occupied by the system after the application\n    of each input signal perturbation. The input-driven transitions between states are\n    recorded as the NFSMs of the system.\n\n    Attributes\n    -----------------\n    G_states : MultiDiGraph\n        General NFSM (G-NFSM), where each equilibrium-state of the\n        regulatory network is a node of the G-NFSM, and labeled directed edges indicate the\n        input state (as an edge label) inducing a transition between one equilibrium state\n        and another. This is a networkx MultiDiGraph,\n        which means parallel edges are allowed to exist and therefore it is possible for different signals to\n        transition the system between the same two state. `G_states` is created using the\n        `create_transition_network` method.\n\n\n    '''\n\n    def __init__(self, pnet: ProbabilityNet):\n        '''\n        Initialize the StateMachine.\n\n        Parameters\n        ----------\n        pnet : NetworkABC\n            An instance of NetworkABC with an analytical model built.\n\n        solsM : ndarray\n            A set of unique steady-state solutions from the GeneNetworkModel.\n            These will be the states of the StateMachine.\n        '''\n\n        self._pnet = pnet\n        self.G_states = None # The state transition network\n\n        # Path to load image assets:\n        GLYPH_DIR = get_data_png_glyph_stability_dir()\n        attractor_fname = FileRelative(GLYPH_DIR, 'glyph_attractor.png')\n        limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_limit_cycle.png')\n        saddle_fname = FileRelative(GLYPH_DIR, 'glyph_saddle.png')\n        attractor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_attractor_limit_cycle.png')\n        repellor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_repellor_limit_cycle.png')\n        repellor_fname = FileRelative(GLYPH_DIR, 'glyph_repellor.png')\n        unknown_fname = FileRelative(GLYPH_DIR, 'glyph_unknown.png')\n        hidden_fname = FileRelative(GLYPH_DIR, 'glyph_hidden.png')\n\n        # Associate each equilibrium type with an image file\n        self._node_image_dict = {\n            EquilibriumType.attractor.name: str(attractor_fname),\n            EquilibriumType.limit_cycle.name: str(limitcycle_fname),\n            EquilibriumType.saddle.name: str(saddle_fname),\n            EquilibriumType.attractor_limit_cycle.name: str(attractor_limitcycle_fname),\n            EquilibriumType.repellor_limit_cycle.name: str(repellor_limitcycle_fname),\n            EquilibriumType.repellor.name: str(repellor_fname),\n            EquilibriumType.undetermined.name: str(unknown_fname),\n            EquilibriumType.hidden.name: str(hidden_fname)\n        }\n\n    def steady_state_solutions_search(self,\n                                      beta_base: float | list,\n                                      n_base: float | list,\n                                      d_base: float | list,\n                                      verbose: bool=True,\n                                      return_saddles: bool=True,\n                                      N_space: int=2,\n                                      search_tol: float=1.0e-15,\n                                      sol_tol: float=1.0e-2,\n                                      search_main_nodes_only: bool = False,\n                                      sig_lino: list|None = None,\n                                      order_by_distance: bool = False,\n                                      node_num_max: int | None = None,\n                                      output_nodes_only: bool = False\n                                      )-&gt; tuple[ndarray, ndarray, list, OrderedDict, ndarray]:\n        '''\n        Search through all possible (binary valued) combinations of input nodes\n        (`ProbabilityNet.input_node_inds`) to find and dynamically characterize equilibrium\n        state of the regulatory network system.\n\n        Parameters\n        ----------\n        verbose : bool, default: True\n            Print output while solving (`True`)?\n        search_main_nodes_only : bool, default: False\n            Search only the `BooleanNet.main_nodes` (`True`) or search all noninput nodes,\n            `BooleanNet.noninput_node_inds` nodes (`False`)?\n        order_by_distance : bool, default: False\n            Order states by increasing distance from the zero state (`True`)?\n        node_num_max : int|None, default: None\n            If `n_max_steps` is `True`, further limit the search space dimensions to the first node_num_max\n            nodes according to their hierarchical level (i.e. according to `BooleanNet.hier_node_level`)?\n            We have found that all equilibrium solutions can be returned by selecting the a subset of nodes\n            with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence\n            on the network.\n        output_nodes_only : bool, default: False\n            Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n            by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n        Returns\n        -------\n        solsM : ndarray\n            The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n            representing the node expression level.\n        charM_all : ndarray\n            The dynamic characterization of each equilibrium state in solsM, as a linear array of\n            [`EquilibriumType`][cellnition.science.network_models.network_enums]\n            enumerations.\n        sols_list : list\n            The list of all (non-unique) equilibrium state solutions in the order that they were found.\n        states_dict : OrderedDict\n            A dictionary with keys as tuples representing each input state, and values being the equilibrium\n            state index as the column index of `solsM`.\n        sig_test_set : ndarray\n            An array containing each of the input states (i.e. all binary-node-level combinations of\n            `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n            of the network were found.\n\n        '''\n\n        if sig_lino is None:\n            sig_lin = [1.0e-6, 1.0]\n        else:\n            sig_lin = sig_lino\n\n        sig_lin_set = [sig_lin for i in self._pnet.input_node_inds]\n\n        sigGrid = np.meshgrid(*sig_lin_set)\n\n        N_vocab = len(sigGrid[0].ravel())\n\n        sig_test_set = np.zeros((N_vocab, len(self._pnet.input_node_inds)))\n\n        for i, sigM in enumerate(sigGrid):\n            sig_test_set[:, i] = sigM.ravel()\n\n        solsM_allo = []\n        charM_allo = []\n        sols_list = []\n\n        for sigis in sig_test_set:\n            # print(f'Signals: {np.round(sigis, 1)}')\n            solsM, sol_M_char, sol_0 = self._pnet.solve_probability_equms(constraint_inds=None,\n                                                                          constraint_vals=None,\n                                                                          signal_constr_vals=sigis.tolist(),\n                                                                          d_base=d_base,\n                                                                          n_base=n_base,\n                                                                          beta_base=beta_base,\n                                                                          N_space=N_space,\n                                                                          search_tol=search_tol,\n                                                                          sol_tol=sol_tol,\n                                                                          verbose=verbose,\n                                                                          return_saddles=return_saddles,\n                                                                          search_main_nodes_only=search_main_nodes_only,\n                                                                          node_num_max=node_num_max\n                                                                          )\n\n\n\n\n            solsM_allo.append(solsM)  # append all unique sols\n            charM_allo.append(sol_M_char)  # append the sol stability characterization tags\n            sols_list.append(solsM)\n            if verbose:\n                print('----')\n\n        # Perform a merger of sols into one array and find only the unique solutions\n        # solsM_all = np.zeros((self._pnet.N_nodes, 1))  # include the zero state\n        # charM_all = [EquilibriumType.undetermined.name]  # set the zero state to undetermined by default\n\n        solsM_all = None\n        charM_all = []\n\n        for i, (soli, chari) in enumerate(zip(solsM_allo, charM_allo)):\n            if i == 0:\n                solsM_all = soli\n            else:\n                solsM_all = np.hstack((solsM_all, soli))\n            charM_all.extend(chari)\n\n\n        # Use numpy unique on specially-rounded set of solutions to exclude similar state cases:\n        solsM_all = self._pnet.multiround(solsM_all)\n\n        # # Next, append all attractor types as an integer value as a way to\n        # # further distinguish states by their dynamics:\n        # charM_all_vals = []\n        # for ci in charM_all:\n        #     attr_type = getattr(EquilibriumType, ci, None)\n        #     if attr_type is not None:\n        #         charM_all_vals.append(attr_type.value)\n        #\n        # select_inds = []\n        # select_inds.extend(self._pnet.noninput_node_inds)\n        # select_inds.append(-1)\n        #\n        # solsM_all_char = np.vstack((solsM_all, charM_all_vals))\n\n        # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n        if output_nodes_only is True and len(self._pnet.output_node_inds):\n            state_node_inds = self._pnet.output_node_inds\n        else:\n            state_node_inds = self._pnet.noninput_node_inds\n\n        # Indices of unique solutions:\n        _, inds_solsM_all_unique = np.unique(solsM_all[state_node_inds, :], return_index=True, axis=1)\n\n        solsM_all = solsM_all[:, inds_solsM_all_unique]\n        charM_all = np.asarray(charM_all)[inds_solsM_all_unique]\n\n        if order_by_distance:\n            # Order states by distance from the zero vector:\n            solsM_all, charM_all = self._order_states_by_distance(solsM_all, charM_all)\n\n        states_dict = OrderedDict()\n        for sigi in sig_test_set:\n            states_dict[tuple(sigi)] = {'States': [], 'Stability': []}\n\n        for sigi, state_subseto in zip(sig_test_set, sols_list):\n            state_subset = state_subseto[self._pnet.noninput_node_inds, :]\n            for target_state in state_subset.T.tolist():\n                state_match_index, err_match = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                       target_state)\n                if state_match_index not in states_dict[tuple(sigi)]['States']:\n                    states_dict[tuple(sigi)]['States'].append(state_match_index)\n                    states_dict[tuple(sigi)]['Stability'].append(charM_all[state_match_index])\n\n        return solsM_all, charM_all, sols_list, states_dict, sig_test_set\n\n    def create_transition_network(self,\n                                  states_dict: dict,\n                                  sig_test_set: list|ndarray,\n                                  solsM_allo: ndarray,\n                                  charM_allo: ndarray,\n                                  dt: float = 5.0e-3,\n                                  delta_sig: float = 40.0,\n                                  t_relax: float = 10.0,\n                                  dt_samp: float=0.1,\n                                  verbose: bool = True,\n                                  match_tol: float = 0.05,\n                                  d_base: float|list[float] = 1.0,\n                                  n_base: float|list[float] = 15.0,\n                                  beta_base: float|list[float] = 0.25,\n                                  remove_inaccessible_states: bool=False,\n                                  save_graph_file: str|None = None,\n                                  save_time_runs: bool=False\n                                  ) -&gt; tuple[set, set, MultiDiGraph]:\n        '''\n        This method builds the Network Finite State Machines by starting the system\n        in different equilibrium states, applying different input signals, and seeing\n        which equilibrium state the system ends up in after\n        a time simulation.\n\n        Parameters\n        ----------\n        states_dict : dict\n        sig_test_set : list|ndarray\n        solsM_allo : ndarray\n        charM_allo : ndarray\n        dt : float, default: 5.0e-3\n        delta_sig : float, default: 40.0\n        t_relax : float, default: 10.0\n        dt_samp : float, default:0.1\n        verbose : bool, default: True\n        match_tol : float, default: 0.05\n        d_base : float|list[float], default: 1.0\n        n_base : float|list[float], default: 15.0\n        beta_base : float|list[float], default: 0.25\n        remove_inaccessible_states : bool, default:False\n        save_graph_file : str|None, default:None\n        save_time_runs : bool, default:False\n\n\n        '''\n\n        # make a copy of solsM_all:\n        solsM_all = solsM_allo.copy()\n        charM_all = charM_allo.copy()\n\n        # make a copy of the states dict that's only used for modifications:\n        states_dict_2 = copy.deepcopy(states_dict)\n\n        # States for perturbation of the zero state inputs\n        # Let's start the system off in the zero vector, then\n        # temporarily perturb the system with each signal set and see what the final state is after\n        # the perturbation.\n\n        sig_inds = self._pnet.input_node_inds\n        N_sigs = len(sig_inds)\n\n        # We want all signals on at the same time (we want the sim to end before\n        # the signal changes again:\n        sig_times = [(delta_sig, 2*delta_sig) for i in range(N_sigs)]\n\n        tend = sig_times[-1][1] + delta_sig\n\n        transition_edges_set = set()\n        perturbation_edges_set = set()\n\n        num_step = 0\n\n        # Get the full time vector and the sampled time vector (tvectr)\n        tvect, tvectr = self._pnet.make_time_vects(tend, dt, dt_samp)\n\n        # Create sampling windows in time:\n        window1 = (0.0 + t_relax, sig_times[0][0])\n        window2 = (sig_times[0][0] + t_relax, sig_times[0][1])\n        window3 = (sig_times[0][1] + t_relax, tend)\n        # get the indices for each window time:\n        inds_win1 = (\n            self._get_index_from_val(tvectr, window1[0], dt_samp),\n            self._get_index_from_val(tvectr, window1[1], dt_samp))\n        inds_win2 = (\n            self._get_index_from_val(tvectr, window2[0], dt_samp),\n            self._get_index_from_val(tvectr, window2[1], dt_samp))\n        inds_win3 = (\n            self._get_index_from_val(tvectr, window3[0], dt_samp),\n            self._get_index_from_val(tvectr, window3[1], dt_samp))\n\n        _all_time_runs = []\n\n        # We want to step through all 'held' signals and potentially multistable states:\n        for base_input_label, (sig_base_set, sc_dict) in enumerate(states_dict.items()):\n\n            states_set = sc_dict['States']\n\n            for si in states_set: # We want to use each state in states_set as the initial condition:\n                if verbose:\n                    print(f\"Testing State {si} in held context I{base_input_label}...\")\n\n                # We then step through all possible perturbation signals:\n                for pert_input_label, sig_val_set in enumerate(sig_test_set):\n\n                    if verbose:\n                        print(f\"--- Step: {num_step} ---\")\n\n                    # we want the signals to go from zero to the new held state defined in sig_val set:\n                    sig_mags = [(sigb, sigi) for sigb, sigi in zip(sig_base_set, sig_val_set)]\n\n                    # Initial state vector: add the small non-zero amount to prevent 0/0 in Hill functions:\n                    cvecti = 1 * solsM_all[:, si] + self._pnet.p_min\n\n                    c_signals = self._pnet.make_pulsed_signals_matrix(tvect, sig_inds, sig_times, sig_mags)\n\n                    ctime = self._pnet.run_time_sim(tvect, tvectr, cvecti.copy(),\n                                                           sig_inds=sig_inds,\n                                                           sig_vals=c_signals,\n                                                           constrained_inds=None,\n                                                           constrained_vals=None,\n                                                           d_base=d_base,\n                                                           n_base=n_base,\n                                                           beta_base=beta_base\n                                                           )\n\n                    c_initial = np.mean(ctime[inds_win1[0]:inds_win1[1], :], axis=0)\n                    # round c_initial so we can match it in solsM_all:\n                    c_initial = self._pnet.multiround(c_initial)\n\n\n                    # match the network state to one that only involves the hub nodes:\n                    initial_state, match_error_initial = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                          c_initial[self._pnet.noninput_node_inds])\n                    # initial_state, match_error_initial = self._find_state_match(solsM_all, c_initial)\n\n                    if match_error_initial &gt; match_tol: # if state is unmatched, flag it with a nan\n                        if verbose:\n                            print(f'WARNING: Initial state not found; adding new state {initial_state} to the solution set...')\n                        solsM_all = np.column_stack((solsM_all, c_initial))\n                        charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                        initial_state = solsM_all.shape[1] - 1\n\n                        # Update the states listing for this input state set\n                        sc_dict2 = states_dict_2[sig_base_set]['States']\n                        sc_dict2.append(initial_state)\n                        states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    # Add this transition to the state transition diagram:\n                    transition_edges_set.add((si, initial_state, base_input_label))\n                    if verbose:\n                        print(f'...State {si} to {initial_state} via I{base_input_label}...')\n\n                    # Next detect the state at the transient input signal:\n                    c_held = np.mean(ctime[inds_win2[0]:inds_win2[1], :], axis=0)\n                    # var_c_held = np.sum(np.std(ctime[inds_win2[0]:inds_win2[1], :], axis=0))\n                    # round c_held so that we can match it in solsM_all:\n                    c_held = self._pnet.multiround(c_held)\n\n                    held_state, match_error_held = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                    c_held[self._pnet.noninput_node_inds])\n                    # held_state, match_error_held = self._find_state_match(solsM_all, c_held)\n\n                    if match_error_held &gt; match_tol: # if state is unmatched, flag it\n                        solsM_all = np.column_stack((solsM_all, c_held))\n                        charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                        held_state = solsM_all.shape[1] -1\n\n                        # Update the states listing for this input state set\n                        sc_dict2 = states_dict_2[sig_base_set]['States']\n                        sc_dict2.append(held_state)\n                        states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                        if verbose:\n                            print(f'WARNING: Held state not found; adding new state {held_state} to the solution set...')\n\n                    transition_edges_set.add((initial_state, held_state, pert_input_label))\n                    if verbose:\n                        print(f'...State {initial_state} to {held_state} via I{pert_input_label}...')\n\n                    c_final = np.mean(ctime[inds_win3[0]:inds_win3[1], :], axis=0)\n                    # round c_final so that we can match it in solsM_all:\n                    c_final = self._pnet.multiround(c_final)\n\n                    final_state, match_error_final = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                      c_final[self._pnet.noninput_node_inds])\n                    # final_state, match_error_final = self._find_state_match(solsM_all, c_final)\n\n                    if match_error_final &gt; match_tol: # if state is unmatched, add it to the system\n\n                        solsM_all = np.column_stack((solsM_all, c_final))\n                        charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                        final_state = solsM_all.shape[1] -1\n\n                        # Update the states listing for this input state set\n                        sc_dict2 = states_dict_2[sig_base_set]['States']\n                        sc_dict2.append(final_state)\n                        states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                        if verbose:\n                            print(f'WARNING: Final state not found; adding new state {final_state} to the solution set...')\n\n                    transition_edges_set.add((held_state, final_state, base_input_label))\n                    if verbose:\n                        print(f'...State {held_state} to {final_state} via I{base_input_label}...')\n\n\n                    if initial_state != final_state:  # add this to the perturbed transitions:\n                        perturbation_edges_set.add((initial_state, final_state, pert_input_label, base_input_label))\n\n                        if verbose:\n                            print(f'Event-driven transition identified from State {initial_state} to {final_state} via '\n                                  f'event I{pert_input_label} under context I{base_input_label}')\n\n\n                    _all_time_runs.append(ctime.copy())\n                    num_step += 1\n\n        # The first thing we do after the construction of the\n        # transition edges set is make a multidigraph and\n        # use networkx to pre-process &amp; simplify it, removing inaccessible states\n        # (states with no non-self input degree)\n\n        if save_time_runs:\n            self._all_time_runs = _all_time_runs\n        else:\n            self._all_time_runs = None\n\n        self._solsM_all = solsM_all\n        self._charM_all = charM_all\n        self._states_dict = states_dict_2\n        self._sig_test_set = sig_test_set\n\n        # Create the multidigraph:\n        GG = nx.MultiDiGraph()\n\n        for ndei, ndej, trans_label_ij in list(transition_edges_set):\n            # Annoyingly, nodes must be strings in order to save properly...\n            GG.add_edge(str(ndei), str(ndej), key=f'I{trans_label_ij}')\n\n        if remove_inaccessible_states:\n            # Remove nodes that have no input degree other than their own self-loop:\n            nodes_with_selfloops = list(nx.nodes_with_selfloops(GG))\n            for node_lab, node_in_deg in list(GG.in_degree()):\n                if (node_in_deg == 1 and node_lab in nodes_with_selfloops) or node_in_deg == 0:\n                    GG.remove_node(node_lab)\n\n        if save_graph_file:\n            nx.write_gml(GG, save_graph_file)\n\n        return transition_edges_set, perturbation_edges_set, GG\n\n    def sim_time_trajectory(self,\n                            starting_state_i: int,\n                            solsM_all: ndarray,\n                            input_list: list[str],\n                            sig_test_set: list|ndarray,\n                            dt: float=1.0e-3,\n                            dt_samp: float=0.1,\n                            input_hold_duration: float = 30.0,\n                            t_wait: float = 10.0,\n                            verbose: bool = True,\n                            match_tol: float = 0.05,\n                            d_base: float|list[float] = 1.0,\n                            n_base: float|list[float] = 15.0,\n                            beta_base: float|list[float] = 0.25,\n                            time_wobble: float = 0.0,\n                            ):\n        '''\n        Use a provided starting state and a list of input signals to hold for\n        a specified duration to simulate a time trajectory of the state machine.\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n        '''\n        c_vecti = solsM_all[:, starting_state_i]  # get the starting state concentrations\n\n        sig_inds = self._pnet.input_node_inds\n\n        N_phases = len(input_list)\n        end_t = N_phases * input_hold_duration\n\n        time_noise = np.random.uniform(0.0, time_wobble)\n\n        phase_time_tuples = [(i * input_hold_duration, (i + 1) * input_hold_duration + time_noise) for i in range(N_phases)]\n\n        # Get the full time vector and the sampled time vector (tvectr)\n        tvect, tvectr = self._pnet.make_time_vects(end_t, dt, dt_samp)\n\n        # list of tuples with indices defining start and stop of phase averaging region (for state matching solutions)\n        c_ave_phase_inds = []\n        for ts, te in phase_time_tuples:\n            rtinds = self._pnet.get_interval_inds(tvectr, ts, te, t_wait=t_wait)\n            c_ave_phase_inds.append((rtinds[0], rtinds[-1]))\n\n        # Get the dictionary that allows us to convert between input signal labels and actual held signal values:\n        signal_lookup_dict = self._get_input_signals_from_label_dict(sig_test_set)\n\n        # Generate a signals matrix:\n        sig_M = np.zeros((len(tvect), self._pnet.N_nodes))\n\n        for sig_label, (ts, te) in zip(input_list, phase_time_tuples):\n            # Get the indices for the time this phase is active:\n            tinds_phase = self._pnet.get_interval_inds(tvect, ts, te, t_wait=0.0)\n\n            sig_vals = signal_lookup_dict[sig_label]\n\n            for si, sigv in zip(sig_inds, sig_vals):\n                sig_M[tinds_phase, si] = sigv\n\n        # now we're ready to run the time sim:\n        ctime = self._pnet.run_time_sim(tvect, tvectr, c_vecti.copy(),\n                                        sig_inds=sig_inds,\n                                        sig_vals=sig_M,\n                                        constrained_inds=None,\n                                        constrained_vals=None,\n                                        d_base=d_base,\n                                        n_base=n_base,\n                                        beta_base=beta_base\n                                        )\n\n        # now we want to state match based on average concentrations in each held-input phase:\n        matched_states = []\n        for i, (si, ei) in enumerate(c_ave_phase_inds):\n            c_ave = np.mean(ctime[si:ei, :], axis=0)\n            c_ave = self._pnet.multiround(c_ave) # we need to round it to the same level as sols in solsM_all\n            state_matcho, match_error = self._find_state_match(solsM_all[self._pnet.noninput_node_inds,:],\n                                                               c_ave[self._pnet.noninput_node_inds])\n            if match_error &lt; match_tol:\n                state_match = state_matcho\n\n                matched_states.append(state_match)\n                if verbose:\n                    print(f'Phase {i} state matched to State {state_match} with input {input_list[i]}')\n            else:\n                matched_states.append(np.nan)\n                if verbose:\n                    print(f'Warning! Phase {i} state matched not found (match error: {match_error})!')\n\n        return tvectr, ctime, matched_states, c_ave_phase_inds\n\n    def plot_state_transition_network(self,\n                                      nodes_listo: list,\n                                      edges_list: list,\n                                      charM_all: list|ndarray,\n                                      save_file: str|None = None,\n                                      graph_layout: str='dot',\n                                      mono_edge: bool = False,\n                                      rank: str='same',\n                                      constraint: bool = False,\n                                      concentrate: bool = True,\n                                      fontsize: float = 18.0,\n                                      node_colors: list|None = None\n                                      ):\n        '''\n\n        '''\n        # Convert nodes from string to int\n        nodes_list = [int(ni) for ni in nodes_listo]\n        img_pos = 'bc'  # position of the glyph in the node\n        subcluster_font = 'DejaVu Sans Bold'\n        node_shape = 'ellipse'\n        clr_map = 'rainbow_r'\n        nde_font_color = 'Black'\n        hex_transparency = '80'\n\n        # Try to make a nested graph:\n        G = pgv.AGraph(strict=mono_edge,\n                       fontname=subcluster_font,\n                       splines=True,\n                       directed=True,\n                       concentrate=concentrate,\n                       constraint=constraint,\n                       rank=rank,\n                       dpi=300)\n\n        cmap = colormaps[clr_map]\n\n        if node_colors is None:\n            norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n        else:\n            norm = colors.Normalize(vmin=np.min(node_colors),\n                                    vmax=np.max(node_colors))\n\n        # Add all the nodes:\n        for nde_i in nodes_list:\n            nde_lab = nde_i\n            nde_index = nodes_list.index(nde_i)\n\n            if node_colors is None:\n                nde_color = colors.rgb2hex(cmap(norm(nde_lab)))\n            else:\n                nde_color = colors.rgb2hex(cmap(norm(node_colors[nde_lab])))\n\n            nde_color += hex_transparency  # add some transparancy to the node\n\n            char_i = charM_all[nde_i] # Get the stability characterization for this state\n\n            G.add_node(nde_i,\n                           label=f'State {nde_lab}',\n                           labelloc='t',\n                           image=self._node_image_dict[char_i],\n                           imagepos=img_pos,\n                           shape=node_shape,\n                           fontcolor=nde_font_color,\n                           style='filled',\n                           fillcolor=nde_color)\n\n\n        # Add all the edges:\n        for nde_i, nde_j, trans_ij in edges_list:\n            G.add_edge(nde_i, nde_j, label=trans_ij, fontsize=fontsize)\n\n        if save_file is not None:\n            G.layout(prog=graph_layout)\n            G.draw(save_file)\n\n        return G\n\n    def plot_state_perturbation_network(self,\n                                       pert_edges_set: set,\n                                       charM_all: list | ndarray,\n                                       nodes_listo: list|ndarray,\n                                       save_file: str|None = None,\n                                       graph_layout: str = 'dot',\n                                       mono_edge: bool=False,\n                                       rank: str = 'same',\n                                       constraint: bool=False,\n                                       concentrate: bool=True,\n                                       fontsize: float = 18.0,\n                                       node_colors: list | None = None\n                                        ):\n        '''\n        This network plotting and generation function is based on the concept\n        that an input node state can be associated with several gene network\n        states if the network has multistability. Here we create a graph with\n        subgraphs, where each subgraph represents the possible states for a\n        held input node state. In the case of multistability, temporary\n        perturbations to the held state can result in transitions between\n        the multistable state (resulting in a memory and path-dependency). The\n        graph indicates which input signal perturbation leads to which state\n        transition via the edge label. Input signal states are represented as\n        integers, where the integer codes for a binary bit string of signal state values.\n\n        Parameters\n        ----------\n        pert_edges_set : set\n            Tuples of state i, state j, perturbation input integer, base input integer, generated\n            by create_transition_network.\n\n        states_dict: dict\n            Dictionary of states and their stability characterization tags for each input signal set.\n\n        nodes_list : list|None = None\n            A list of nodes to include in the network. This is useful to filter out inaccessible states,\n            if desired.\n\n        save_file : str|None = None\n            A file to save the network image to. If None, no image is saved.\n\n        graph_layout : str = 'dot'\n            Layout for the graph when saving to image.\n\n        '''\n\n\n        nodes_list = [int(ni) for ni in nodes_listo] # convert nodes from string to int\n\n        img_pos = 'bc'  # position of the glyph in the node\n        subcluster_font = 'DejaVu Sans Bold'\n        node_shape = 'ellipse'\n        clr_map = 'rainbow_r'\n        nde_font_color = 'Black'\n        hex_transparency = '80'\n\n        # Make a nested graph with compound=True keyword:\n        G = pgv.AGraph(strict=mono_edge,\n                       fontname=subcluster_font,\n                       splines=True,\n                       directed=True,\n                       concentrate=concentrate,\n                       constraint=constraint,\n                       compound=True,\n                       rank=rank,\n                       dpi=300)\n\n        cmap = colormaps[clr_map]\n\n        if node_colors is None:\n            norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n        else:\n            norm = colors.Normalize(vmin=np.min(node_colors), vmax=np.max(node_colors))\n\n        for st_i, st_f, i_pert, i_base in pert_edges_set:\n            # Add in a subgraph box for the \"held\" input node state:\n            Gsub = G.add_subgraph(name=f'cluster_{i_base}', label=f'Held at I{i_base}')\n\n            # next add-in nodes for the initial state:\n            nde_i_name = f'{st_i}.{i_base}' # node name is in terms of the subgraph box index\n            nde_i_lab = f'State {st_i}'\n\n            if node_colors is None:\n                nde_i_color = colors.rgb2hex(cmap(norm(st_i)))\n            else:\n                nde_i_color = colors.rgb2hex(cmap(norm(node_colors[st_i])))\n\n            nde_i_color += hex_transparency  # add some transparency to the node\n\n            chr_i = charM_all[st_i]\n\n            Gsub.add_node(nde_i_name,\n                          label=nde_i_lab,\n                          labelloc='t',\n                          image=self._node_image_dict[chr_i],\n                          imagepos=img_pos,\n                          shape=node_shape,\n                          fontcolor=nde_font_color,\n                          style='filled',\n                          fillcolor=nde_i_color\n                          )\n\n            # ...and for the final state:\n            nde_f_name = f'{st_f}.{i_base}' # node name is in terms of the subgraph box index\n            nde_f_lab = f'State {st_f}'\n            nde_f_color = colors.rgb2hex(cmap(norm(st_f)))\n            nde_f_color += hex_transparency  # add some transparency to the node\n            chr_f = charM_all[st_f]\n\n            Gsub.add_node(nde_f_name,\n                          label=nde_f_lab,\n                          labelloc='t',\n                          image=self._node_image_dict[chr_f],\n                          imagepos=img_pos,\n                          shape=node_shape,\n                          fontcolor=nde_font_color,\n                          style='filled',\n                          fillcolor=nde_f_color\n                          )\n\n            Gsub.add_edge(nde_i_name, nde_f_name, label=f'I{i_pert}', fontsize=fontsize)\n\n        if save_file is not None:\n            G.layout(prog=graph_layout)\n            G.draw(save_file)\n\n        return G\n\n\n    def plot_time_trajectory(self,\n                             c_time: ndarray,\n                             tvectr: ndarray|list,\n                             phase_inds: ndarray|list,\n                             matched_states: ndarray|list,\n                             charM_all: ndarray|list,\n                             gene_plot_inds: list|None=None,\n                             figsize: tuple = (10, 4),\n                             state_label_offset: float = 0.02,\n                             glyph_zoom: float=0.15,\n                             glyph_alignment: tuple[float, float]=(-0.0, -0.15),\n                             fontsize: str='medium',\n                             save_file: str|None = None,\n                             legend: bool=True,\n                             ):\n        '''\n\n        '''\n\n        if gene_plot_inds is None:\n            main_c = c_time[:, self._pnet.noninput_node_inds]\n        else:\n            main_c = c_time[:, gene_plot_inds]\n\n        N_plot_genes = main_c.shape[1]\n\n        # Resize the figure to fit the panel of plotted genes:\n        fig_width = figsize[0]\n        fig_height = figsize[1]\n        figsize = (fig_width, fig_height*N_plot_genes)\n\n        cmap = plt.get_cmap(\"tab10\")\n\n        fig, axes = plt.subplots(N_plot_genes, 1, figsize=figsize, sharex=True, sharey=True)\n        for ii, cc in enumerate(main_c.T):\n            # gene_lab = f'Gene {ii}'\n            gene_lab = self._pnet.nodes_list[gene_plot_inds[ii]]\n            lineplt = axes[ii].plot(tvectr, cc, linewidth=2.0, label=gene_lab, color=cmap(ii))  # plot the time series\n            # annotate the plot with the matched state:\n            for (pi, pj), stateio in zip(phase_inds, matched_states):\n                statei = stateio\n\n                char_i = charM_all[stateio] # We want the state characterization to go to the full state system\n                char_i_fname = self._node_image_dict[char_i]\n                logo = image.imread(char_i_fname)\n                imagebox = OffsetImage(logo, zoom=glyph_zoom)\n                pmid = pi\n                tmid = tvectr[pmid]\n                cc_max = np.max(cc[pi:pj])\n                cmid = cc_max + state_label_offset\n\n                axes[ii].text(tmid, cmid, f'State {statei}', fontsize=fontsize)\n\n                ab = AnnotationBbox(imagebox,\n                                    (tmid, cmid),\n                                    frameon=False,\n                                    box_alignment=glyph_alignment)\n                axes[ii].add_artist(ab)\n\n                axes[ii].spines['top'].set_visible(False)\n                axes[ii].spines['right'].set_visible(False)\n\n                axes[ii].set_ylabel('Expression Probability')\n\n                if legend:\n                    axes[ii].legend(frameon=False)\n\n        axes[-1].set_xlabel('Time')\n\n        if save_file is not None:\n            plt.savefig(save_file, dpi=300, transparent=True, format='png')\n\n        return fig, axes\n\n    def get_state_distance_matrix(self, solsM_all):\n        '''\n        Returns a matrix representing the L2 norm 'distance'\n        between each state in the array of all possible states.\n\n        '''\n        num_sols = solsM_all.shape[1]\n        state_distance_M = np.zeros((num_sols, num_sols))\n        for i in range(num_sols):\n            for j in range(num_sols):\n                # d_states = np.sqrt(np.sum((solsM_all[:,i] - solsM_all[:, j])**2))\n                d_states = np.sqrt(\n                    np.sum((solsM_all[self._pnet.noninput_node_inds, i] -\n                            solsM_all[self._pnet.noninput_node_inds, j]) ** 2))\n                state_distance_M[i, j] = d_states\n\n        return state_distance_M\n\n    def _get_input_signals_from_label_dict(self, sig_test_set: ndarray | list):\n        '''\n\n        '''\n        # Would be very useful to have a lookup dictionary between the integer input\n        # state label and the original signals tuple:\n        input_int_to_signals = {}\n\n        for int_label, input_sigs in enumerate(sig_test_set):\n            # int_label = self._get_integer_label(input_sigs)\n            input_int_to_signals[f'I{int_label}'] = tuple(input_sigs)\n\n        return input_int_to_signals\n\n    def _order_states_by_distance(self, solsM_all, charM_all):\n        '''\n        Re-arrange the supplied solution matrix so that the states are\n        progressively closer to one another, in order to see a more\n        logical transition through the network with perturbation.\n        '''\n        zer_sol = np.zeros(solsM_all[:, 0].shape)\n        dist_list = []\n\n        for soli in solsM_all.T:\n            # calculate the \"distance\" between the two solutions\n            # and append to the distance list:\n            dist_list.append(np.sqrt(np.sum((zer_sol[self._pnet.noninput_node_inds] -\n                                             soli[self._pnet.noninput_node_inds]) ** 2)))\n\n        inds_sort = np.argsort(dist_list)\n\n        solsM_all = solsM_all[:, inds_sort]\n        charM_all = charM_all[inds_sort]\n\n        return solsM_all, charM_all\n\n    def _get_index_from_val(self, val_vect: ndarray, val: float, val_overlap: float):\n        '''\n        Given a value in an array, this method returns the index\n        of the closest value in the array.\n\n        Parameters\n        -----------\n        val_vect : ndarray\n            The vector of values to which the closest index to val is sought.\n\n        val: float\n            A value for which the closest matched index in val_vect is to be\n            returned.\n\n        val_overlap: float\n            An amount of overlap to include in search windows to ensure the\n            search will return at least one index.\n        '''\n        inds_l = (val_vect &lt;= val + val_overlap).nonzero()[0]\n        inds_h = (val_vect &gt;= val - val_overlap).nonzero()[0]\n        indo = np.intersect1d(inds_l, inds_h)\n        if len(indo):\n            ind = indo[0]\n        else:\n            raise Exception(\"No matching index was found.\")\n\n        return ind\n\n    # def _get_integer_label(self, sig_set: tuple|list|ndarray) -&gt; int:\n    #     '''\n    #     Given a list of digits representing a bit string\n    #     (i.e. a list of values close to zero or 1), this method\n    #     treats the list as a binary bit-string and returns the\n    #     base-2 integer representation of the bit-string.\n    #\n    #     Parameters\n    #     ----------\n    #     sig_set : list[float|int]\n    #         The list containing floats or ints that are taken to represent\n    #         a bit string.\n    #\n    #     Returns\n    #     -------\n    #     An integer representation of the binary bit-string.\n    #\n    #     '''\n    #     base_str = ''\n    #     for sigi in sig_set:\n    #         base_str += str(int(sigi))\n    #     return int(base_str, 2)\n\n    def _find_state_match(self,\n                         solsM: ndarray,\n                         cvecti: list | ndarray) -&gt; tuple:\n        '''\n        Given a matrix of possible states and a concentration vector,\n        return the state that best-matches the concentration vector,\n        along with an error for the comparison.\n\n        Parameters\n        ----------\n        solsM : ndarray\n            A matrix with a set of steady-state solutions arranged in\n            columns.\n\n        cvecti : list\n            A list of concentrations with which to compare with each\n            steady-state in solsM, in order to select a best-match state\n            from solsM to cvecti.\n\n        Returns\n        -------\n        state_best_match\n            The index of the best-match state in solsM\n        err\n            The error to the match\n        '''\n\n        # now what we need is a pattern match from concentrations to the stable states:\n        errM = []\n        for soli in solsM.T:\n            sdiff = soli - cvecti\n            errM.append(np.sqrt(np.sum(sdiff ** 2)))\n        errM = np.asarray(errM)\n        state_best_match = (errM == errM.min()).nonzero()[0][0]\n\n        return state_best_match, errM[state_best_match]\n\n    def plot_input_words_array(self,\n                        sig_test_set: ndarray,\n                        gene_list: list|ndarray,\n                        figsave: str | None = None,\n                        cmap: str | None =None,\n                        save_format: str='png',\n                        figsize: tuple=(10,10)):\n        '''\n\n        '''\n\n        if cmap is None:\n            cmap = 'magma'\n\n        state_labels = [f'I{i}' for i in range(sig_test_set.shape[0])]\n\n        gene_labels = np.asarray(gene_list)\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        im = ax.imshow(sig_test_set, cmap=cmap)\n\n        ax.set_xticks(np.arange(len(gene_labels)), labels=gene_labels)\n        ax.set_yticks(np.arange(len(state_labels)), labels=state_labels)\n\n        plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n                 rotation_mode=\"anchor\")\n        fig.colorbar(im, label='Expression Level')\n\n        if figsave is not None:\n            plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n        return fig, ax\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.__init__","title":"<code>__init__(pnet)</code>","text":"<p>Initialize the StateMachine.</p> <p>Parameters:</p> Name Type Description Default <code>pnet</code> <code>NetworkABC</code> <p>An instance of NetworkABC with an analytical model built.</p> required <code>solsM</code> <code>ndarray</code> <p>A set of unique steady-state solutions from the GeneNetworkModel. These will be the states of the StateMachine.</p> required Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def __init__(self, pnet: ProbabilityNet):\n    '''\n    Initialize the StateMachine.\n\n    Parameters\n    ----------\n    pnet : NetworkABC\n        An instance of NetworkABC with an analytical model built.\n\n    solsM : ndarray\n        A set of unique steady-state solutions from the GeneNetworkModel.\n        These will be the states of the StateMachine.\n    '''\n\n    self._pnet = pnet\n    self.G_states = None # The state transition network\n\n    # Path to load image assets:\n    GLYPH_DIR = get_data_png_glyph_stability_dir()\n    attractor_fname = FileRelative(GLYPH_DIR, 'glyph_attractor.png')\n    limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_limit_cycle.png')\n    saddle_fname = FileRelative(GLYPH_DIR, 'glyph_saddle.png')\n    attractor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_attractor_limit_cycle.png')\n    repellor_limitcycle_fname = FileRelative(GLYPH_DIR, 'glyph_repellor_limit_cycle.png')\n    repellor_fname = FileRelative(GLYPH_DIR, 'glyph_repellor.png')\n    unknown_fname = FileRelative(GLYPH_DIR, 'glyph_unknown.png')\n    hidden_fname = FileRelative(GLYPH_DIR, 'glyph_hidden.png')\n\n    # Associate each equilibrium type with an image file\n    self._node_image_dict = {\n        EquilibriumType.attractor.name: str(attractor_fname),\n        EquilibriumType.limit_cycle.name: str(limitcycle_fname),\n        EquilibriumType.saddle.name: str(saddle_fname),\n        EquilibriumType.attractor_limit_cycle.name: str(attractor_limitcycle_fname),\n        EquilibriumType.repellor_limit_cycle.name: str(repellor_limitcycle_fname),\n        EquilibriumType.repellor.name: str(repellor_fname),\n        EquilibriumType.undetermined.name: str(unknown_fname),\n        EquilibriumType.hidden.name: str(hidden_fname)\n    }\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.create_transition_network","title":"<code>create_transition_network(states_dict, sig_test_set, solsM_allo, charM_allo, dt=0.005, delta_sig=40.0, t_relax=10.0, dt_samp=0.1, verbose=True, match_tol=0.05, d_base=1.0, n_base=15.0, beta_base=0.25, remove_inaccessible_states=False, save_graph_file=None, save_time_runs=False)</code>","text":"<p>This method builds the Network Finite State Machines by starting the system in different equilibrium states, applying different input signals, and seeing which equilibrium state the system ends up in after a time simulation.</p> <p>Parameters:</p> Name Type Description Default <code>states_dict</code> <code>dict</code> required <code>sig_test_set</code> <code>list | ndarray</code> required <code>solsM_allo</code> <code>ndarray</code> required <code>charM_allo</code> <code>ndarray</code> required <code>dt</code> <code>float</code> <code>5.0e-3</code> <code>delta_sig</code> <code>float</code> <code>40.0</code> <code>t_relax</code> <code>float</code> <code>10.0</code> <code>dt_samp</code> <code>float, default:0.1</code> <code>0.1</code> <code>verbose</code> <code>bool</code> <code>True</code> <code>match_tol</code> <code>float</code> <code>0.05</code> <code>d_base</code> <code>float | list[float]</code> <code>1.0</code> <code>n_base</code> <code>float | list[float]</code> <code>15.0</code> <code>beta_base</code> <code>float | list[float]</code> <code>0.25</code> <code>remove_inaccessible_states</code> <code>bool, default:False</code> <code>False</code> <code>save_graph_file</code> <code>str|None, default:None</code> <code>None</code> <code>save_time_runs</code> <code>bool, default:False</code> <code>False</code> Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def create_transition_network(self,\n                              states_dict: dict,\n                              sig_test_set: list|ndarray,\n                              solsM_allo: ndarray,\n                              charM_allo: ndarray,\n                              dt: float = 5.0e-3,\n                              delta_sig: float = 40.0,\n                              t_relax: float = 10.0,\n                              dt_samp: float=0.1,\n                              verbose: bool = True,\n                              match_tol: float = 0.05,\n                              d_base: float|list[float] = 1.0,\n                              n_base: float|list[float] = 15.0,\n                              beta_base: float|list[float] = 0.25,\n                              remove_inaccessible_states: bool=False,\n                              save_graph_file: str|None = None,\n                              save_time_runs: bool=False\n                              ) -&gt; tuple[set, set, MultiDiGraph]:\n    '''\n    This method builds the Network Finite State Machines by starting the system\n    in different equilibrium states, applying different input signals, and seeing\n    which equilibrium state the system ends up in after\n    a time simulation.\n\n    Parameters\n    ----------\n    states_dict : dict\n    sig_test_set : list|ndarray\n    solsM_allo : ndarray\n    charM_allo : ndarray\n    dt : float, default: 5.0e-3\n    delta_sig : float, default: 40.0\n    t_relax : float, default: 10.0\n    dt_samp : float, default:0.1\n    verbose : bool, default: True\n    match_tol : float, default: 0.05\n    d_base : float|list[float], default: 1.0\n    n_base : float|list[float], default: 15.0\n    beta_base : float|list[float], default: 0.25\n    remove_inaccessible_states : bool, default:False\n    save_graph_file : str|None, default:None\n    save_time_runs : bool, default:False\n\n\n    '''\n\n    # make a copy of solsM_all:\n    solsM_all = solsM_allo.copy()\n    charM_all = charM_allo.copy()\n\n    # make a copy of the states dict that's only used for modifications:\n    states_dict_2 = copy.deepcopy(states_dict)\n\n    # States for perturbation of the zero state inputs\n    # Let's start the system off in the zero vector, then\n    # temporarily perturb the system with each signal set and see what the final state is after\n    # the perturbation.\n\n    sig_inds = self._pnet.input_node_inds\n    N_sigs = len(sig_inds)\n\n    # We want all signals on at the same time (we want the sim to end before\n    # the signal changes again:\n    sig_times = [(delta_sig, 2*delta_sig) for i in range(N_sigs)]\n\n    tend = sig_times[-1][1] + delta_sig\n\n    transition_edges_set = set()\n    perturbation_edges_set = set()\n\n    num_step = 0\n\n    # Get the full time vector and the sampled time vector (tvectr)\n    tvect, tvectr = self._pnet.make_time_vects(tend, dt, dt_samp)\n\n    # Create sampling windows in time:\n    window1 = (0.0 + t_relax, sig_times[0][0])\n    window2 = (sig_times[0][0] + t_relax, sig_times[0][1])\n    window3 = (sig_times[0][1] + t_relax, tend)\n    # get the indices for each window time:\n    inds_win1 = (\n        self._get_index_from_val(tvectr, window1[0], dt_samp),\n        self._get_index_from_val(tvectr, window1[1], dt_samp))\n    inds_win2 = (\n        self._get_index_from_val(tvectr, window2[0], dt_samp),\n        self._get_index_from_val(tvectr, window2[1], dt_samp))\n    inds_win3 = (\n        self._get_index_from_val(tvectr, window3[0], dt_samp),\n        self._get_index_from_val(tvectr, window3[1], dt_samp))\n\n    _all_time_runs = []\n\n    # We want to step through all 'held' signals and potentially multistable states:\n    for base_input_label, (sig_base_set, sc_dict) in enumerate(states_dict.items()):\n\n        states_set = sc_dict['States']\n\n        for si in states_set: # We want to use each state in states_set as the initial condition:\n            if verbose:\n                print(f\"Testing State {si} in held context I{base_input_label}...\")\n\n            # We then step through all possible perturbation signals:\n            for pert_input_label, sig_val_set in enumerate(sig_test_set):\n\n                if verbose:\n                    print(f\"--- Step: {num_step} ---\")\n\n                # we want the signals to go from zero to the new held state defined in sig_val set:\n                sig_mags = [(sigb, sigi) for sigb, sigi in zip(sig_base_set, sig_val_set)]\n\n                # Initial state vector: add the small non-zero amount to prevent 0/0 in Hill functions:\n                cvecti = 1 * solsM_all[:, si] + self._pnet.p_min\n\n                c_signals = self._pnet.make_pulsed_signals_matrix(tvect, sig_inds, sig_times, sig_mags)\n\n                ctime = self._pnet.run_time_sim(tvect, tvectr, cvecti.copy(),\n                                                       sig_inds=sig_inds,\n                                                       sig_vals=c_signals,\n                                                       constrained_inds=None,\n                                                       constrained_vals=None,\n                                                       d_base=d_base,\n                                                       n_base=n_base,\n                                                       beta_base=beta_base\n                                                       )\n\n                c_initial = np.mean(ctime[inds_win1[0]:inds_win1[1], :], axis=0)\n                # round c_initial so we can match it in solsM_all:\n                c_initial = self._pnet.multiround(c_initial)\n\n\n                # match the network state to one that only involves the hub nodes:\n                initial_state, match_error_initial = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                      c_initial[self._pnet.noninput_node_inds])\n                # initial_state, match_error_initial = self._find_state_match(solsM_all, c_initial)\n\n                if match_error_initial &gt; match_tol: # if state is unmatched, flag it with a nan\n                    if verbose:\n                        print(f'WARNING: Initial state not found; adding new state {initial_state} to the solution set...')\n                    solsM_all = np.column_stack((solsM_all, c_initial))\n                    charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                    initial_state = solsM_all.shape[1] - 1\n\n                    # Update the states listing for this input state set\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(initial_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                # Add this transition to the state transition diagram:\n                transition_edges_set.add((si, initial_state, base_input_label))\n                if verbose:\n                    print(f'...State {si} to {initial_state} via I{base_input_label}...')\n\n                # Next detect the state at the transient input signal:\n                c_held = np.mean(ctime[inds_win2[0]:inds_win2[1], :], axis=0)\n                # var_c_held = np.sum(np.std(ctime[inds_win2[0]:inds_win2[1], :], axis=0))\n                # round c_held so that we can match it in solsM_all:\n                c_held = self._pnet.multiround(c_held)\n\n                held_state, match_error_held = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                c_held[self._pnet.noninput_node_inds])\n                # held_state, match_error_held = self._find_state_match(solsM_all, c_held)\n\n                if match_error_held &gt; match_tol: # if state is unmatched, flag it\n                    solsM_all = np.column_stack((solsM_all, c_held))\n                    charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                    held_state = solsM_all.shape[1] -1\n\n                    # Update the states listing for this input state set\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(held_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    if verbose:\n                        print(f'WARNING: Held state not found; adding new state {held_state} to the solution set...')\n\n                transition_edges_set.add((initial_state, held_state, pert_input_label))\n                if verbose:\n                    print(f'...State {initial_state} to {held_state} via I{pert_input_label}...')\n\n                c_final = np.mean(ctime[inds_win3[0]:inds_win3[1], :], axis=0)\n                # round c_final so that we can match it in solsM_all:\n                c_final = self._pnet.multiround(c_final)\n\n                final_state, match_error_final = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                  c_final[self._pnet.noninput_node_inds])\n                # final_state, match_error_final = self._find_state_match(solsM_all, c_final)\n\n                if match_error_final &gt; match_tol: # if state is unmatched, add it to the system\n\n                    solsM_all = np.column_stack((solsM_all, c_final))\n                    charM_all = np.hstack((charM_all, EquilibriumType.undetermined.name))\n                    final_state = solsM_all.shape[1] -1\n\n                    # Update the states listing for this input state set\n                    sc_dict2 = states_dict_2[sig_base_set]['States']\n                    sc_dict2.append(final_state)\n                    states_dict_2[sig_base_set]['States'] = sc_dict2\n\n                    if verbose:\n                        print(f'WARNING: Final state not found; adding new state {final_state} to the solution set...')\n\n                transition_edges_set.add((held_state, final_state, base_input_label))\n                if verbose:\n                    print(f'...State {held_state} to {final_state} via I{base_input_label}...')\n\n\n                if initial_state != final_state:  # add this to the perturbed transitions:\n                    perturbation_edges_set.add((initial_state, final_state, pert_input_label, base_input_label))\n\n                    if verbose:\n                        print(f'Event-driven transition identified from State {initial_state} to {final_state} via '\n                              f'event I{pert_input_label} under context I{base_input_label}')\n\n\n                _all_time_runs.append(ctime.copy())\n                num_step += 1\n\n    # The first thing we do after the construction of the\n    # transition edges set is make a multidigraph and\n    # use networkx to pre-process &amp; simplify it, removing inaccessible states\n    # (states with no non-self input degree)\n\n    if save_time_runs:\n        self._all_time_runs = _all_time_runs\n    else:\n        self._all_time_runs = None\n\n    self._solsM_all = solsM_all\n    self._charM_all = charM_all\n    self._states_dict = states_dict_2\n    self._sig_test_set = sig_test_set\n\n    # Create the multidigraph:\n    GG = nx.MultiDiGraph()\n\n    for ndei, ndej, trans_label_ij in list(transition_edges_set):\n        # Annoyingly, nodes must be strings in order to save properly...\n        GG.add_edge(str(ndei), str(ndej), key=f'I{trans_label_ij}')\n\n    if remove_inaccessible_states:\n        # Remove nodes that have no input degree other than their own self-loop:\n        nodes_with_selfloops = list(nx.nodes_with_selfloops(GG))\n        for node_lab, node_in_deg in list(GG.in_degree()):\n            if (node_in_deg == 1 and node_lab in nodes_with_selfloops) or node_in_deg == 0:\n                GG.remove_node(node_lab)\n\n    if save_graph_file:\n        nx.write_gml(GG, save_graph_file)\n\n    return transition_edges_set, perturbation_edges_set, GG\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.get_state_distance_matrix","title":"<code>get_state_distance_matrix(solsM_all)</code>","text":"<p>Returns a matrix representing the L2 norm 'distance' between each state in the array of all possible states.</p> Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def get_state_distance_matrix(self, solsM_all):\n    '''\n    Returns a matrix representing the L2 norm 'distance'\n    between each state in the array of all possible states.\n\n    '''\n    num_sols = solsM_all.shape[1]\n    state_distance_M = np.zeros((num_sols, num_sols))\n    for i in range(num_sols):\n        for j in range(num_sols):\n            # d_states = np.sqrt(np.sum((solsM_all[:,i] - solsM_all[:, j])**2))\n            d_states = np.sqrt(\n                np.sum((solsM_all[self._pnet.noninput_node_inds, i] -\n                        solsM_all[self._pnet.noninput_node_inds, j]) ** 2))\n            state_distance_M[i, j] = d_states\n\n    return state_distance_M\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.plot_input_words_array","title":"<code>plot_input_words_array(sig_test_set, gene_list, figsave=None, cmap=None, save_format='png', figsize=(10, 10))</code>","text":"Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def plot_input_words_array(self,\n                    sig_test_set: ndarray,\n                    gene_list: list|ndarray,\n                    figsave: str | None = None,\n                    cmap: str | None =None,\n                    save_format: str='png',\n                    figsize: tuple=(10,10)):\n    '''\n\n    '''\n\n    if cmap is None:\n        cmap = 'magma'\n\n    state_labels = [f'I{i}' for i in range(sig_test_set.shape[0])]\n\n    gene_labels = np.asarray(gene_list)\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    im = ax.imshow(sig_test_set, cmap=cmap)\n\n    ax.set_xticks(np.arange(len(gene_labels)), labels=gene_labels)\n    ax.set_yticks(np.arange(len(state_labels)), labels=state_labels)\n\n    plt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\",\n             rotation_mode=\"anchor\")\n    fig.colorbar(im, label='Expression Level')\n\n    if figsave is not None:\n        plt.savefig(figsave, dpi=300, transparent=True, format=save_format)\n\n    return fig, ax\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.plot_state_perturbation_network","title":"<code>plot_state_perturbation_network(pert_edges_set, charM_all, nodes_listo, save_file=None, graph_layout='dot', mono_edge=False, rank='same', constraint=False, concentrate=True, fontsize=18.0, node_colors=None)</code>","text":"<p>This network plotting and generation function is based on the concept that an input node state can be associated with several gene network states if the network has multistability. Here we create a graph with subgraphs, where each subgraph represents the possible states for a held input node state. In the case of multistability, temporary perturbations to the held state can result in transitions between the multistable state (resulting in a memory and path-dependency). The graph indicates which input signal perturbation leads to which state transition via the edge label. Input signal states are represented as integers, where the integer codes for a binary bit string of signal state values.</p> <p>Parameters:</p> Name Type Description Default <code>pert_edges_set</code> <code>set</code> <p>Tuples of state i, state j, perturbation input integer, base input integer, generated by create_transition_network.</p> required <code>states_dict</code> <p>Dictionary of states and their stability characterization tags for each input signal set.</p> required <code>nodes_list</code> <code>list|None = None</code> <p>A list of nodes to include in the network. This is useful to filter out inaccessible states, if desired.</p> required <code>save_file</code> <code>str|None = None</code> <p>A file to save the network image to. If None, no image is saved.</p> <code>None</code> <code>graph_layout</code> <code>str = 'dot'</code> <p>Layout for the graph when saving to image.</p> <code>'dot'</code> Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def plot_state_perturbation_network(self,\n                                   pert_edges_set: set,\n                                   charM_all: list | ndarray,\n                                   nodes_listo: list|ndarray,\n                                   save_file: str|None = None,\n                                   graph_layout: str = 'dot',\n                                   mono_edge: bool=False,\n                                   rank: str = 'same',\n                                   constraint: bool=False,\n                                   concentrate: bool=True,\n                                   fontsize: float = 18.0,\n                                   node_colors: list | None = None\n                                    ):\n    '''\n    This network plotting and generation function is based on the concept\n    that an input node state can be associated with several gene network\n    states if the network has multistability. Here we create a graph with\n    subgraphs, where each subgraph represents the possible states for a\n    held input node state. In the case of multistability, temporary\n    perturbations to the held state can result in transitions between\n    the multistable state (resulting in a memory and path-dependency). The\n    graph indicates which input signal perturbation leads to which state\n    transition via the edge label. Input signal states are represented as\n    integers, where the integer codes for a binary bit string of signal state values.\n\n    Parameters\n    ----------\n    pert_edges_set : set\n        Tuples of state i, state j, perturbation input integer, base input integer, generated\n        by create_transition_network.\n\n    states_dict: dict\n        Dictionary of states and their stability characterization tags for each input signal set.\n\n    nodes_list : list|None = None\n        A list of nodes to include in the network. This is useful to filter out inaccessible states,\n        if desired.\n\n    save_file : str|None = None\n        A file to save the network image to. If None, no image is saved.\n\n    graph_layout : str = 'dot'\n        Layout for the graph when saving to image.\n\n    '''\n\n\n    nodes_list = [int(ni) for ni in nodes_listo] # convert nodes from string to int\n\n    img_pos = 'bc'  # position of the glyph in the node\n    subcluster_font = 'DejaVu Sans Bold'\n    node_shape = 'ellipse'\n    clr_map = 'rainbow_r'\n    nde_font_color = 'Black'\n    hex_transparency = '80'\n\n    # Make a nested graph with compound=True keyword:\n    G = pgv.AGraph(strict=mono_edge,\n                   fontname=subcluster_font,\n                   splines=True,\n                   directed=True,\n                   concentrate=concentrate,\n                   constraint=constraint,\n                   compound=True,\n                   rank=rank,\n                   dpi=300)\n\n    cmap = colormaps[clr_map]\n\n    if node_colors is None:\n        norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n    else:\n        norm = colors.Normalize(vmin=np.min(node_colors), vmax=np.max(node_colors))\n\n    for st_i, st_f, i_pert, i_base in pert_edges_set:\n        # Add in a subgraph box for the \"held\" input node state:\n        Gsub = G.add_subgraph(name=f'cluster_{i_base}', label=f'Held at I{i_base}')\n\n        # next add-in nodes for the initial state:\n        nde_i_name = f'{st_i}.{i_base}' # node name is in terms of the subgraph box index\n        nde_i_lab = f'State {st_i}'\n\n        if node_colors is None:\n            nde_i_color = colors.rgb2hex(cmap(norm(st_i)))\n        else:\n            nde_i_color = colors.rgb2hex(cmap(norm(node_colors[st_i])))\n\n        nde_i_color += hex_transparency  # add some transparency to the node\n\n        chr_i = charM_all[st_i]\n\n        Gsub.add_node(nde_i_name,\n                      label=nde_i_lab,\n                      labelloc='t',\n                      image=self._node_image_dict[chr_i],\n                      imagepos=img_pos,\n                      shape=node_shape,\n                      fontcolor=nde_font_color,\n                      style='filled',\n                      fillcolor=nde_i_color\n                      )\n\n        # ...and for the final state:\n        nde_f_name = f'{st_f}.{i_base}' # node name is in terms of the subgraph box index\n        nde_f_lab = f'State {st_f}'\n        nde_f_color = colors.rgb2hex(cmap(norm(st_f)))\n        nde_f_color += hex_transparency  # add some transparency to the node\n        chr_f = charM_all[st_f]\n\n        Gsub.add_node(nde_f_name,\n                      label=nde_f_lab,\n                      labelloc='t',\n                      image=self._node_image_dict[chr_f],\n                      imagepos=img_pos,\n                      shape=node_shape,\n                      fontcolor=nde_font_color,\n                      style='filled',\n                      fillcolor=nde_f_color\n                      )\n\n        Gsub.add_edge(nde_i_name, nde_f_name, label=f'I{i_pert}', fontsize=fontsize)\n\n    if save_file is not None:\n        G.layout(prog=graph_layout)\n        G.draw(save_file)\n\n    return G\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.plot_state_transition_network","title":"<code>plot_state_transition_network(nodes_listo, edges_list, charM_all, save_file=None, graph_layout='dot', mono_edge=False, rank='same', constraint=False, concentrate=True, fontsize=18.0, node_colors=None)</code>","text":"Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def plot_state_transition_network(self,\n                                  nodes_listo: list,\n                                  edges_list: list,\n                                  charM_all: list|ndarray,\n                                  save_file: str|None = None,\n                                  graph_layout: str='dot',\n                                  mono_edge: bool = False,\n                                  rank: str='same',\n                                  constraint: bool = False,\n                                  concentrate: bool = True,\n                                  fontsize: float = 18.0,\n                                  node_colors: list|None = None\n                                  ):\n    '''\n\n    '''\n    # Convert nodes from string to int\n    nodes_list = [int(ni) for ni in nodes_listo]\n    img_pos = 'bc'  # position of the glyph in the node\n    subcluster_font = 'DejaVu Sans Bold'\n    node_shape = 'ellipse'\n    clr_map = 'rainbow_r'\n    nde_font_color = 'Black'\n    hex_transparency = '80'\n\n    # Try to make a nested graph:\n    G = pgv.AGraph(strict=mono_edge,\n                   fontname=subcluster_font,\n                   splines=True,\n                   directed=True,\n                   concentrate=concentrate,\n                   constraint=constraint,\n                   rank=rank,\n                   dpi=300)\n\n    cmap = colormaps[clr_map]\n\n    if node_colors is None:\n        norm = colors.Normalize(vmin=0, vmax=self._solsM_all.shape[1] +1)\n    else:\n        norm = colors.Normalize(vmin=np.min(node_colors),\n                                vmax=np.max(node_colors))\n\n    # Add all the nodes:\n    for nde_i in nodes_list:\n        nde_lab = nde_i\n        nde_index = nodes_list.index(nde_i)\n\n        if node_colors is None:\n            nde_color = colors.rgb2hex(cmap(norm(nde_lab)))\n        else:\n            nde_color = colors.rgb2hex(cmap(norm(node_colors[nde_lab])))\n\n        nde_color += hex_transparency  # add some transparancy to the node\n\n        char_i = charM_all[nde_i] # Get the stability characterization for this state\n\n        G.add_node(nde_i,\n                       label=f'State {nde_lab}',\n                       labelloc='t',\n                       image=self._node_image_dict[char_i],\n                       imagepos=img_pos,\n                       shape=node_shape,\n                       fontcolor=nde_font_color,\n                       style='filled',\n                       fillcolor=nde_color)\n\n\n    # Add all the edges:\n    for nde_i, nde_j, trans_ij in edges_list:\n        G.add_edge(nde_i, nde_j, label=trans_ij, fontsize=fontsize)\n\n    if save_file is not None:\n        G.layout(prog=graph_layout)\n        G.draw(save_file)\n\n    return G\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.plot_time_trajectory","title":"<code>plot_time_trajectory(c_time, tvectr, phase_inds, matched_states, charM_all, gene_plot_inds=None, figsize=(10, 4), state_label_offset=0.02, glyph_zoom=0.15, glyph_alignment=(-0.0, -0.15), fontsize='medium', save_file=None, legend=True)</code>","text":"Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def plot_time_trajectory(self,\n                         c_time: ndarray,\n                         tvectr: ndarray|list,\n                         phase_inds: ndarray|list,\n                         matched_states: ndarray|list,\n                         charM_all: ndarray|list,\n                         gene_plot_inds: list|None=None,\n                         figsize: tuple = (10, 4),\n                         state_label_offset: float = 0.02,\n                         glyph_zoom: float=0.15,\n                         glyph_alignment: tuple[float, float]=(-0.0, -0.15),\n                         fontsize: str='medium',\n                         save_file: str|None = None,\n                         legend: bool=True,\n                         ):\n    '''\n\n    '''\n\n    if gene_plot_inds is None:\n        main_c = c_time[:, self._pnet.noninput_node_inds]\n    else:\n        main_c = c_time[:, gene_plot_inds]\n\n    N_plot_genes = main_c.shape[1]\n\n    # Resize the figure to fit the panel of plotted genes:\n    fig_width = figsize[0]\n    fig_height = figsize[1]\n    figsize = (fig_width, fig_height*N_plot_genes)\n\n    cmap = plt.get_cmap(\"tab10\")\n\n    fig, axes = plt.subplots(N_plot_genes, 1, figsize=figsize, sharex=True, sharey=True)\n    for ii, cc in enumerate(main_c.T):\n        # gene_lab = f'Gene {ii}'\n        gene_lab = self._pnet.nodes_list[gene_plot_inds[ii]]\n        lineplt = axes[ii].plot(tvectr, cc, linewidth=2.0, label=gene_lab, color=cmap(ii))  # plot the time series\n        # annotate the plot with the matched state:\n        for (pi, pj), stateio in zip(phase_inds, matched_states):\n            statei = stateio\n\n            char_i = charM_all[stateio] # We want the state characterization to go to the full state system\n            char_i_fname = self._node_image_dict[char_i]\n            logo = image.imread(char_i_fname)\n            imagebox = OffsetImage(logo, zoom=glyph_zoom)\n            pmid = pi\n            tmid = tvectr[pmid]\n            cc_max = np.max(cc[pi:pj])\n            cmid = cc_max + state_label_offset\n\n            axes[ii].text(tmid, cmid, f'State {statei}', fontsize=fontsize)\n\n            ab = AnnotationBbox(imagebox,\n                                (tmid, cmid),\n                                frameon=False,\n                                box_alignment=glyph_alignment)\n            axes[ii].add_artist(ab)\n\n            axes[ii].spines['top'].set_visible(False)\n            axes[ii].spines['right'].set_visible(False)\n\n            axes[ii].set_ylabel('Expression Probability')\n\n            if legend:\n                axes[ii].legend(frameon=False)\n\n    axes[-1].set_xlabel('Time')\n\n    if save_file is not None:\n        plt.savefig(save_file, dpi=300, transparent=True, format='png')\n\n    return fig, axes\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.sim_time_trajectory","title":"<code>sim_time_trajectory(starting_state_i, solsM_all, input_list, sig_test_set, dt=0.001, dt_samp=0.1, input_hold_duration=30.0, t_wait=10.0, verbose=True, match_tol=0.05, d_base=1.0, n_base=15.0, beta_base=0.25, time_wobble=0.0)</code>","text":"<p>Use a provided starting state and a list of input signals to hold for a specified duration to simulate a time trajectory of the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>Returns</code> required Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def sim_time_trajectory(self,\n                        starting_state_i: int,\n                        solsM_all: ndarray,\n                        input_list: list[str],\n                        sig_test_set: list|ndarray,\n                        dt: float=1.0e-3,\n                        dt_samp: float=0.1,\n                        input_hold_duration: float = 30.0,\n                        t_wait: float = 10.0,\n                        verbose: bool = True,\n                        match_tol: float = 0.05,\n                        d_base: float|list[float] = 1.0,\n                        n_base: float|list[float] = 15.0,\n                        beta_base: float|list[float] = 0.25,\n                        time_wobble: float = 0.0,\n                        ):\n    '''\n    Use a provided starting state and a list of input signals to hold for\n    a specified duration to simulate a time trajectory of the state machine.\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n    '''\n    c_vecti = solsM_all[:, starting_state_i]  # get the starting state concentrations\n\n    sig_inds = self._pnet.input_node_inds\n\n    N_phases = len(input_list)\n    end_t = N_phases * input_hold_duration\n\n    time_noise = np.random.uniform(0.0, time_wobble)\n\n    phase_time_tuples = [(i * input_hold_duration, (i + 1) * input_hold_duration + time_noise) for i in range(N_phases)]\n\n    # Get the full time vector and the sampled time vector (tvectr)\n    tvect, tvectr = self._pnet.make_time_vects(end_t, dt, dt_samp)\n\n    # list of tuples with indices defining start and stop of phase averaging region (for state matching solutions)\n    c_ave_phase_inds = []\n    for ts, te in phase_time_tuples:\n        rtinds = self._pnet.get_interval_inds(tvectr, ts, te, t_wait=t_wait)\n        c_ave_phase_inds.append((rtinds[0], rtinds[-1]))\n\n    # Get the dictionary that allows us to convert between input signal labels and actual held signal values:\n    signal_lookup_dict = self._get_input_signals_from_label_dict(sig_test_set)\n\n    # Generate a signals matrix:\n    sig_M = np.zeros((len(tvect), self._pnet.N_nodes))\n\n    for sig_label, (ts, te) in zip(input_list, phase_time_tuples):\n        # Get the indices for the time this phase is active:\n        tinds_phase = self._pnet.get_interval_inds(tvect, ts, te, t_wait=0.0)\n\n        sig_vals = signal_lookup_dict[sig_label]\n\n        for si, sigv in zip(sig_inds, sig_vals):\n            sig_M[tinds_phase, si] = sigv\n\n    # now we're ready to run the time sim:\n    ctime = self._pnet.run_time_sim(tvect, tvectr, c_vecti.copy(),\n                                    sig_inds=sig_inds,\n                                    sig_vals=sig_M,\n                                    constrained_inds=None,\n                                    constrained_vals=None,\n                                    d_base=d_base,\n                                    n_base=n_base,\n                                    beta_base=beta_base\n                                    )\n\n    # now we want to state match based on average concentrations in each held-input phase:\n    matched_states = []\n    for i, (si, ei) in enumerate(c_ave_phase_inds):\n        c_ave = np.mean(ctime[si:ei, :], axis=0)\n        c_ave = self._pnet.multiround(c_ave) # we need to round it to the same level as sols in solsM_all\n        state_matcho, match_error = self._find_state_match(solsM_all[self._pnet.noninput_node_inds,:],\n                                                           c_ave[self._pnet.noninput_node_inds])\n        if match_error &lt; match_tol:\n            state_match = state_matcho\n\n            matched_states.append(state_match)\n            if verbose:\n                print(f'Phase {i} state matched to State {state_match} with input {input_list[i]}')\n        else:\n            matched_states.append(np.nan)\n            if verbose:\n                print(f'Warning! Phase {i} state matched not found (match error: {match_error})!')\n\n    return tvectr, ctime, matched_states, c_ave_phase_inds\n</code></pre>"},{"location":"2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/#cellnition.science.networks_toolbox.state_machine.StateMachine.steady_state_solutions_search","title":"<code>steady_state_solutions_search(beta_base, n_base, d_base, verbose=True, return_saddles=True, N_space=2, search_tol=1e-15, sol_tol=0.01, search_main_nodes_only=False, sig_lino=None, order_by_distance=False, node_num_max=None, output_nodes_only=False)</code>","text":"<p>Search through all possible (binary valued) combinations of input nodes (<code>ProbabilityNet.input_node_inds</code>) to find and dynamically characterize equilibrium state of the regulatory network system.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Print output while solving (<code>True</code>)?</p> <code>True</code> <code>search_main_nodes_only</code> <code>bool</code> <p>Search only the <code>BooleanNet.main_nodes</code> (<code>True</code>) or search all noninput nodes, <code>BooleanNet.noninput_node_inds</code> nodes (<code>False</code>)?</p> <code>False</code> <code>order_by_distance</code> <code>bool</code> <p>Order states by increasing distance from the zero state (<code>True</code>)?</p> <code>False</code> <code>node_num_max</code> <code>int | None</code> <p>If <code>n_max_steps</code> is <code>True</code>, further limit the search space dimensions to the first node_num_max nodes according to their hierarchical level (i.e. according to <code>BooleanNet.hier_node_level</code>)? We have found that all equilibrium solutions can be returned by selecting the a subset of nodes with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence on the network.</p> <code>None</code> <code>output_nodes_only</code> <code>bool</code> <p>Define the uniqueness of equilibrium states using only the <code>BooleanNet.output_node_inds</code> (<code>True</code>) or by using all non-input node inds using <code>BooleanNet.noninput_node_inds</code> (<code>False</code>)?</p> <code>False</code> <p>Returns:</p> Name Type Description <code>solsM</code> <code>ndarray</code> <p>The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row representing the node expression level.</p> <code>charM_all</code> <code>ndarray</code> <p>The dynamic characterization of each equilibrium state in solsM, as a linear array of <code>EquilibriumType</code> enumerations.</p> <code>sols_list</code> <code>list</code> <p>The list of all (non-unique) equilibrium state solutions in the order that they were found.</p> <code>states_dict</code> <code>OrderedDict</code> <p>A dictionary with keys as tuples representing each input state, and values being the equilibrium state index as the column index of <code>solsM</code>.</p> <code>sig_test_set</code> <code>ndarray</code> <p>An array containing each of the input states (i.e. all binary-node-level combinations of <code>BooleanNet.input_node_inds</code>) which were applied to the network, for which equilibrium states of the network were found.</p> Source code in <code>cellnition/science/networks_toolbox/state_machine.py</code> <pre><code>def steady_state_solutions_search(self,\n                                  beta_base: float | list,\n                                  n_base: float | list,\n                                  d_base: float | list,\n                                  verbose: bool=True,\n                                  return_saddles: bool=True,\n                                  N_space: int=2,\n                                  search_tol: float=1.0e-15,\n                                  sol_tol: float=1.0e-2,\n                                  search_main_nodes_only: bool = False,\n                                  sig_lino: list|None = None,\n                                  order_by_distance: bool = False,\n                                  node_num_max: int | None = None,\n                                  output_nodes_only: bool = False\n                                  )-&gt; tuple[ndarray, ndarray, list, OrderedDict, ndarray]:\n    '''\n    Search through all possible (binary valued) combinations of input nodes\n    (`ProbabilityNet.input_node_inds`) to find and dynamically characterize equilibrium\n    state of the regulatory network system.\n\n    Parameters\n    ----------\n    verbose : bool, default: True\n        Print output while solving (`True`)?\n    search_main_nodes_only : bool, default: False\n        Search only the `BooleanNet.main_nodes` (`True`) or search all noninput nodes,\n        `BooleanNet.noninput_node_inds` nodes (`False`)?\n    order_by_distance : bool, default: False\n        Order states by increasing distance from the zero state (`True`)?\n    node_num_max : int|None, default: None\n        If `n_max_steps` is `True`, further limit the search space dimensions to the first node_num_max\n        nodes according to their hierarchical level (i.e. according to `BooleanNet.hier_node_level`)?\n        We have found that all equilibrium solutions can be returned by selecting the a subset of nodes\n        with the ones with the highest hierarchical level (i.e. closest to inputs) having maximum influence\n        on the network.\n    output_nodes_only : bool, default: False\n        Define the uniqueness of equilibrium states using only the `BooleanNet.output_node_inds` (`True`) or\n        by using all non-input node inds using `BooleanNet.noninput_node_inds` (`False`)?\n\n    Returns\n    -------\n    solsM : ndarray\n        The matrix of unique equilibrium state solutions, with each solution appearing in columns, and each row\n        representing the node expression level.\n    charM_all : ndarray\n        The dynamic characterization of each equilibrium state in solsM, as a linear array of\n        [`EquilibriumType`][cellnition.science.network_models.network_enums]\n        enumerations.\n    sols_list : list\n        The list of all (non-unique) equilibrium state solutions in the order that they were found.\n    states_dict : OrderedDict\n        A dictionary with keys as tuples representing each input state, and values being the equilibrium\n        state index as the column index of `solsM`.\n    sig_test_set : ndarray\n        An array containing each of the input states (i.e. all binary-node-level combinations of\n        `BooleanNet.input_node_inds`) which were applied to the network, for which equilibrium states\n        of the network were found.\n\n    '''\n\n    if sig_lino is None:\n        sig_lin = [1.0e-6, 1.0]\n    else:\n        sig_lin = sig_lino\n\n    sig_lin_set = [sig_lin for i in self._pnet.input_node_inds]\n\n    sigGrid = np.meshgrid(*sig_lin_set)\n\n    N_vocab = len(sigGrid[0].ravel())\n\n    sig_test_set = np.zeros((N_vocab, len(self._pnet.input_node_inds)))\n\n    for i, sigM in enumerate(sigGrid):\n        sig_test_set[:, i] = sigM.ravel()\n\n    solsM_allo = []\n    charM_allo = []\n    sols_list = []\n\n    for sigis in sig_test_set:\n        # print(f'Signals: {np.round(sigis, 1)}')\n        solsM, sol_M_char, sol_0 = self._pnet.solve_probability_equms(constraint_inds=None,\n                                                                      constraint_vals=None,\n                                                                      signal_constr_vals=sigis.tolist(),\n                                                                      d_base=d_base,\n                                                                      n_base=n_base,\n                                                                      beta_base=beta_base,\n                                                                      N_space=N_space,\n                                                                      search_tol=search_tol,\n                                                                      sol_tol=sol_tol,\n                                                                      verbose=verbose,\n                                                                      return_saddles=return_saddles,\n                                                                      search_main_nodes_only=search_main_nodes_only,\n                                                                      node_num_max=node_num_max\n                                                                      )\n\n\n\n\n        solsM_allo.append(solsM)  # append all unique sols\n        charM_allo.append(sol_M_char)  # append the sol stability characterization tags\n        sols_list.append(solsM)\n        if verbose:\n            print('----')\n\n    # Perform a merger of sols into one array and find only the unique solutions\n    # solsM_all = np.zeros((self._pnet.N_nodes, 1))  # include the zero state\n    # charM_all = [EquilibriumType.undetermined.name]  # set the zero state to undetermined by default\n\n    solsM_all = None\n    charM_all = []\n\n    for i, (soli, chari) in enumerate(zip(solsM_allo, charM_allo)):\n        if i == 0:\n            solsM_all = soli\n        else:\n            solsM_all = np.hstack((solsM_all, soli))\n        charM_all.extend(chari)\n\n\n    # Use numpy unique on specially-rounded set of solutions to exclude similar state cases:\n    solsM_all = self._pnet.multiround(solsM_all)\n\n    # # Next, append all attractor types as an integer value as a way to\n    # # further distinguish states by their dynamics:\n    # charM_all_vals = []\n    # for ci in charM_all:\n    #     attr_type = getattr(EquilibriumType, ci, None)\n    #     if attr_type is not None:\n    #         charM_all_vals.append(attr_type.value)\n    #\n    # select_inds = []\n    # select_inds.extend(self._pnet.noninput_node_inds)\n    # select_inds.append(-1)\n    #\n    # solsM_all_char = np.vstack((solsM_all, charM_all_vals))\n\n    # If desired, states can be defined as \"unique\" with respect to the output nodes only:\n    if output_nodes_only is True and len(self._pnet.output_node_inds):\n        state_node_inds = self._pnet.output_node_inds\n    else:\n        state_node_inds = self._pnet.noninput_node_inds\n\n    # Indices of unique solutions:\n    _, inds_solsM_all_unique = np.unique(solsM_all[state_node_inds, :], return_index=True, axis=1)\n\n    solsM_all = solsM_all[:, inds_solsM_all_unique]\n    charM_all = np.asarray(charM_all)[inds_solsM_all_unique]\n\n    if order_by_distance:\n        # Order states by distance from the zero vector:\n        solsM_all, charM_all = self._order_states_by_distance(solsM_all, charM_all)\n\n    states_dict = OrderedDict()\n    for sigi in sig_test_set:\n        states_dict[tuple(sigi)] = {'States': [], 'Stability': []}\n\n    for sigi, state_subseto in zip(sig_test_set, sols_list):\n        state_subset = state_subseto[self._pnet.noninput_node_inds, :]\n        for target_state in state_subset.T.tolist():\n            state_match_index, err_match = self._find_state_match(solsM_all[self._pnet.noninput_node_inds, :],\n                                                                   target_state)\n            if state_match_index not in states_dict[tuple(sigi)]['States']:\n                states_dict[tuple(sigi)]['States'].append(state_match_index)\n                states_dict[tuple(sigi)]['Stability'].append(charM_all[state_match_index])\n\n    return solsM_all, charM_all, sols_list, states_dict, sig_test_set\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_basic_network/","title":"Basic Network","text":"<p>               Bases: <code>NetworkABC</code></p> Source code in <code>cellnition/science/network_models/basic_network.py</code> <pre><code>class BasicNet(NetworkABC):\n    '''\n\n    '''\n\n    def __init__(self):\n        '''\n\n        '''\n\n        super().__init__()  # Initialize the base class\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_basic_network/#cellnition.science.network_models.basic_network.BasicNet.__init__","title":"<code>__init__()</code>","text":"Source code in <code>cellnition/science/network_models/basic_network.py</code> <pre><code>def __init__(self):\n    '''\n\n    '''\n\n    super().__init__()  # Initialize the base class\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/","title":"Network Library","text":"<p>This module defines multiple regulatory networks as directed graphs for general use in Cellnition regulatory network models.</p>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.AKTNet","title":"<code>AKTNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is the PI3K/AKT/mTOR (PAM) signaling transduction pathway.</p> <p>The network is sourced from the reference:</p> <p>Glaviano et al. PI3K/AKT/mTOR signaling transduction pathway and targeted therapies in cancer. Mol Cancer. 2023 Aug 18;22(1):138. doi: 10.1186/s12943-023-01827-6.</p> <p>The modelled network has been slightly simplified from the source reference by combining elements in direct signalling chains, and is the version that appeared in the first pre-print of our RNM paper.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class AKTNet(LibNet):\n    '''\n    This biological network is the PI3K/AKT/mTOR (PAM) signaling transduction pathway.\n\n    The network is sourced from the reference:\n\n    Glaviano et al. PI3K/AKT/mTOR signaling transduction pathway and targeted therapies in cancer.\n    Mol Cancer. 2023 Aug 18;22(1):138. doi: 10.1186/s12943-023-01827-6.\n\n    The modelled network has been slightly simplified from the source reference by combining elements in direct\n    signalling chains, and is the version that appeared in the first pre-print of our RNM paper.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'AKTNet'\n\n        self.N_nodes = 24\n        self.edges = [\n                      # Input edges:\n                      ('Growth_RTK', 'RAS'),\n                      ('Growth_RTK', 'GAB12'),\n                      ('Survival_RTK', 'PI3K'),\n                      ('Wnt_Frizzled', 'Dsh'),\n\n                      # RTK-Growth sub-pathway:\n                      ('RAS', 'RAF'),\n                      ('RAS', 'PI3K'),\n                      ('GAB12', 'PI3K'),\n                      ('RAF', 'ERK'),\n                      ('ERK', 'TSCComplex'),\n                      ('ERK', 'eIF4E'),\n\n                      # RTK-survival sub-pathway:\n                      ('PI3K', 'AKT'),\n                      ('AKT', 'RAF'),\n                      ('AKT', 'TSCComplex'),\n                      ('AKT', 'FOXO'),\n                      ('AKT', 'AxinComplex'),\n                      ('AKT', 'bCAT'),\n                      ('TSCComplex', 'mTORC1'),\n                      ('mTORC1', 'EBP1'),\n                      ('EBP1', 'eIF4E'),\n\n                      # WNT-Frizzled sub-pathway\n                      ('Dsh', 'AxinComplex'),\n                      ('AxinComplex', 'bCAT'),\n\n                      # Output edges\n                      ('ERK', 'CellSurvival'),\n                      ('eIF4E', 'Translation'),\n                      ('mTORC1', 'CellCycle'),\n                      ('mTORC1', 'CellSurvival'),\n                      ('mTORC1', 'Metabolism'),\n                      ('bCAT', 'Proliferation'),\n                      ('bCAT', 'Proteosomes'),\n                      ('FOXO', 'Apoptosis'),\n\n                 ]\n\n        self.edge_types = [\n                          # Input edge types:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n\n                           # RTK-Growth sub-pathway:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n\n                          # RTK-survival sub-pathway:\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n\n                         # WNT-Frizzled sub-pathway:\n                           EdgeType.I,\n                           EdgeType.A,\n\n                         # Output edge types:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                      ]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n\n        self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.AKTNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'AKTNet'\n\n    self.N_nodes = 24\n    self.edges = [\n                  # Input edges:\n                  ('Growth_RTK', 'RAS'),\n                  ('Growth_RTK', 'GAB12'),\n                  ('Survival_RTK', 'PI3K'),\n                  ('Wnt_Frizzled', 'Dsh'),\n\n                  # RTK-Growth sub-pathway:\n                  ('RAS', 'RAF'),\n                  ('RAS', 'PI3K'),\n                  ('GAB12', 'PI3K'),\n                  ('RAF', 'ERK'),\n                  ('ERK', 'TSCComplex'),\n                  ('ERK', 'eIF4E'),\n\n                  # RTK-survival sub-pathway:\n                  ('PI3K', 'AKT'),\n                  ('AKT', 'RAF'),\n                  ('AKT', 'TSCComplex'),\n                  ('AKT', 'FOXO'),\n                  ('AKT', 'AxinComplex'),\n                  ('AKT', 'bCAT'),\n                  ('TSCComplex', 'mTORC1'),\n                  ('mTORC1', 'EBP1'),\n                  ('EBP1', 'eIF4E'),\n\n                  # WNT-Frizzled sub-pathway\n                  ('Dsh', 'AxinComplex'),\n                  ('AxinComplex', 'bCAT'),\n\n                  # Output edges\n                  ('ERK', 'CellSurvival'),\n                  ('eIF4E', 'Translation'),\n                  ('mTORC1', 'CellCycle'),\n                  ('mTORC1', 'CellSurvival'),\n                  ('mTORC1', 'Metabolism'),\n                  ('bCAT', 'Proliferation'),\n                  ('bCAT', 'Proteosomes'),\n                  ('FOXO', 'Apoptosis'),\n\n             ]\n\n    self.edge_types = [\n                      # Input edge types:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n\n                       # RTK-Growth sub-pathway:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n\n                      # RTK-survival sub-pathway:\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n\n                     # WNT-Frizzled sub-pathway:\n                       EdgeType.I,\n                       EdgeType.A,\n\n                     # Output edge types:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                  ]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n\n    self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.AKTNet1","title":"<code>AKTNet1</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is the PI3K/AKT/mTOR (PAM) signaling transduction pathway.</p> <p>The network is sourced from the reference:</p> <p>Glaviano et al. PI3K/AKT/mTOR signaling transduction pathway and targeted therapies in cancer. Mol Cancer. 2023 Aug 18;22(1):138. doi: 10.1186/s12943-023-01827-6.</p> <p>The modelled network has been slightly simplified from the source reference by combining elements in direct signalling chains and by removing some cross-talk connections between pathways in order to prevent nonsense output.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class AKTNet1(LibNet):\n    '''\n    This biological network is the PI3K/AKT/mTOR (PAM) signaling transduction pathway.\n\n    The network is sourced from the reference:\n\n    Glaviano et al. PI3K/AKT/mTOR signaling transduction pathway and targeted therapies in cancer.\n    Mol Cancer. 2023 Aug 18;22(1):138. doi: 10.1186/s12943-023-01827-6.\n\n    The modelled network has been slightly simplified from the source reference by combining elements in direct\n    signalling chains and by removing some cross-talk connections between pathways in order to\n    prevent nonsense output.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'AKTNet1'\n\n        self.N_nodes = 26\n        self.edges = [\n                      # Input edges:\n                      ('Growth_RTK', 'RAS'),\n                      ('Survival_RTK', 'PI3K'),\n                      ('Wnt_Frizzled', 'Dsh'),\n\n                      # RTK-Growth sub-pathway:\n                      ('RAS', 'RAF'),\n                      ('RAF', 'MEK'),\n                      ('MEK', 'ERK'),\n                      ('ERK', 'MNK1'),\n                      ('ERK', 'RSK'),\n                      ('ERK', 'mTORC1'),\n                      ('ERK', 'TSCComplex'),\n                      ('RSK', 'mTORC1'),\n                      ('MNK1', 'eIF4E'),\n\n                      # RTK-survival sub-pathway:\n                      ('PI3K', 'AKT'),\n                      ('AKT', 'RAF'),\n                      ('AKT', 'TSCComplex'),\n                      ('AKT', 'FOXO'),\n                      ('AKT', 'AxinComplex'),\n                      ('AKT', 'bCAT'),\n                      ('TSCComplex', 'mTORC1'),\n                      ('mTORC1', 'EBP1'),\n                      ('EBP1', 'eIF4E'),\n\n                      # WNT-Frizzled sub-pathway\n                      ('Dsh', 'AxinComplex'),\n                      ('AxinComplex', 'bCAT'),\n\n                      # Output edges\n                      ('ERK', 'CellSurvival'),\n                      ('eIF4E', 'Translation'),\n                      ('mTORC1', 'CellCycle'),\n                      ('mTORC1', 'Metabolism'),\n                      ('bCAT', 'Proliferation'),\n                      ('bCAT', 'Proteosomes'),\n                      ('FOXO', 'Apoptosis'),\n\n                 ]\n\n        self.edge_types = [\n                          # Input edge types:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n\n                           # RTK-Growth sub-pathway:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n\n                          # RTK-survival sub-pathway:\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n\n                         # WNT-Frizzled sub-pathway:\n                           EdgeType.I,\n                           EdgeType.A,\n\n                         # Output edge types:\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                      ]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n\n        self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.AKTNet1.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'AKTNet1'\n\n    self.N_nodes = 26\n    self.edges = [\n                  # Input edges:\n                  ('Growth_RTK', 'RAS'),\n                  ('Survival_RTK', 'PI3K'),\n                  ('Wnt_Frizzled', 'Dsh'),\n\n                  # RTK-Growth sub-pathway:\n                  ('RAS', 'RAF'),\n                  ('RAF', 'MEK'),\n                  ('MEK', 'ERK'),\n                  ('ERK', 'MNK1'),\n                  ('ERK', 'RSK'),\n                  ('ERK', 'mTORC1'),\n                  ('ERK', 'TSCComplex'),\n                  ('RSK', 'mTORC1'),\n                  ('MNK1', 'eIF4E'),\n\n                  # RTK-survival sub-pathway:\n                  ('PI3K', 'AKT'),\n                  ('AKT', 'RAF'),\n                  ('AKT', 'TSCComplex'),\n                  ('AKT', 'FOXO'),\n                  ('AKT', 'AxinComplex'),\n                  ('AKT', 'bCAT'),\n                  ('TSCComplex', 'mTORC1'),\n                  ('mTORC1', 'EBP1'),\n                  ('EBP1', 'eIF4E'),\n\n                  # WNT-Frizzled sub-pathway\n                  ('Dsh', 'AxinComplex'),\n                  ('AxinComplex', 'bCAT'),\n\n                  # Output edges\n                  ('ERK', 'CellSurvival'),\n                  ('eIF4E', 'Translation'),\n                  ('mTORC1', 'CellCycle'),\n                  ('mTORC1', 'Metabolism'),\n                  ('bCAT', 'Proliferation'),\n                  ('bCAT', 'Proteosomes'),\n                  ('FOXO', 'Apoptosis'),\n\n             ]\n\n    self.edge_types = [\n                      # Input edge types:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n\n                       # RTK-Growth sub-pathway:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n\n                      # RTK-survival sub-pathway:\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n\n                     # WNT-Frizzled sub-pathway:\n                       EdgeType.I,\n                       EdgeType.A,\n\n                     # Output edge types:\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                  ]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n\n    self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.ActivatorExample","title":"<code>ActivatorExample</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple two-node example of an activating interaction.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class ActivatorExample(LibNet):\n    '''\n    Simple two-node example of an activating interaction.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'ActivatorExample'\n\n        self.N_nodes = 2\n        self.edges = [('S0', 'H0')]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.ActivatorExample.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'ActivatorExample'\n\n    self.N_nodes = 2\n    self.edges = [('S0', 'H0')]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A,\n                           ]\n    else:\n        self.edge_types = [EdgeType.I,\n                           ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BasicQuadnodeNet","title":"<code>BasicQuadnodeNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of four nodes in a cycle, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BasicQuadnodeNet(LibNet):\n    '''\n    Simple example of four nodes in a cycle,\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BasicQuadnodeNet'\n\n        self.N_nodes = 8\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BasicQuadnodeNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BasicQuadnodeNet'\n\n    self.N_nodes = 8\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet","title":"<code>BiLoopControlNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of a simple network arrangement that can act as a homeostat by creating attractor limit cycles.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BiLoopControlNet(LibNet):\n    '''\n    Example of a simple network arrangement that can act as a\n    homeostat by creating attractor limit cycles.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BiLoopControlNet'\n\n        self.N_nodes = 7\n        self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                      ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                      # ('H0', 'H1'), ('H1', 'H0'),\n                      ('F0', 'P0')]\n\n        self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.I,\n                           EdgeType.I, EdgeType.I, EdgeType.A,\n                           # EdgeType.I, EdgeType.I,\n                           EdgeType.A\n                           ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'E': NodeType.effector,\n                               'P': NodeType.process,\n                               'F': NodeType.factor,\n                               'H': NodeType.core\n                               }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BiLoopControlNet'\n\n    self.N_nodes = 7\n    self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                  ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                  # ('H0', 'H1'), ('H1', 'H0'),\n                  ('F0', 'P0')]\n\n    self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.I,\n                       EdgeType.I, EdgeType.I, EdgeType.A,\n                       # EdgeType.I, EdgeType.I,\n                       EdgeType.A\n                       ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'E': NodeType.effector,\n                           'P': NodeType.process,\n                           'F': NodeType.factor,\n                           'H': NodeType.core\n                           }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet2","title":"<code>BiLoopControlNet2</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of a simple network arrangement that can act as a homeostat by creating attractor limit cycles.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BiLoopControlNet2(LibNet):\n    '''\n    Example of a simple network arrangement that can act as a\n    homeostat by creating attractor limit cycles.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BiLoopControlNet2'\n\n        self.N_nodes = 7\n        self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                      ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                      ('H0', 'H1'), ('H1', 'H0'),\n                      ('F0', 'P0')]\n\n        self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                           EdgeType.I, EdgeType.A, EdgeType.A,\n                           EdgeType.I, EdgeType.I,\n                           EdgeType.A\n                           ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'E': NodeType.effector,\n                               'P': NodeType.process,\n                               'F': NodeType.factor\n                               }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet2.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BiLoopControlNet2'\n\n    self.N_nodes = 7\n    self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                  ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                  ('H0', 'H1'), ('H1', 'H0'),\n                  ('F0', 'P0')]\n\n    self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                       EdgeType.I, EdgeType.A, EdgeType.A,\n                       EdgeType.I, EdgeType.I,\n                       EdgeType.A\n                       ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'E': NodeType.effector,\n                           'P': NodeType.process,\n                           'F': NodeType.factor\n                           }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet3","title":"<code>BiLoopControlNet3</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of a simple network arrangement that can act as a homeostat by creating attractor limit cycles.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BiLoopControlNet3(LibNet):\n    '''\n    Example of a simple network arrangement that can act as a\n    homeostat by creating attractor limit cycles.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BiLoopControlNet3'\n\n        self.N_nodes = 7\n        self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                      ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                      ('F0', 'P0')]\n\n        self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                           EdgeType.I, EdgeType.A, EdgeType.A,\n                           EdgeType.A\n                           ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'E': NodeType.effector,\n                               'P': NodeType.process,\n                               'F': NodeType.factor\n                               }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BiLoopControlNet3.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BiLoopControlNet3'\n\n    self.N_nodes = 7\n    self.edges = [('S0', 'H0'), ('H0', 'E0'), ('E0', 'P0'), ('P0', 'S0'),\n                  ('S0', 'H1'), ('H1', 'E1'), ('E1', 'P0'),\n                  ('F0', 'P0')]\n\n    self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                       EdgeType.I, EdgeType.A, EdgeType.A,\n                       EdgeType.A\n                       ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'E': NodeType.effector,\n                           'P': NodeType.process,\n                           'F': NodeType.factor\n                           }\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChain","title":"<code>BinodeChain</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a chain with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeChain(LibNet):\n    '''\n    Simple example of two-nodes in a chain with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeChain'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A,\n                                   ]\n        else:\n            self.N_nodes = 3\n            self.edges = [('H0', 'H1'),\n                     ('S0', 'H0')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A,\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.I,\n                                   ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChain.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeChain'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A,\n                               ]\n    else:\n        self.N_nodes = 3\n        self.edges = [('H0', 'H1'),\n                 ('S0', 'H0')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.I,\n                               ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChainSelfLoop","title":"<code>BinodeChainSelfLoop</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a chain, with self loop on one node, and  with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeChainSelfLoop(LibNet):\n    '''\n    Simple example of two-nodes in a chain, with self loop on one node, and\n     with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeChainSelfLoop'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'),\n                     ('H0', 'H0'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n        else:\n            self.N_nodes = 3\n            self.edges = [('H0', 'H1'),\n                     ('H0', 'H0'),\n                     ('S0', 'H0')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I,\n                          EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n        else:\n            self.edge_types = [EdgeType.Is,\n                          EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChainSelfLoop.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeChainSelfLoop'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'),\n                 ('H0', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n    else:\n        self.N_nodes = 3\n        self.edges = [('H0', 'H1'),\n                 ('H0', 'H0'),\n                 ('S0', 'H0')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I,\n                      EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n    else:\n        self.edge_types = [EdgeType.Is,\n                      EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChainSelfLoops","title":"<code>BinodeChainSelfLoops</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a chain, with self loops on both nodes, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeChainSelfLoops(LibNet):\n    '''\n     Simple example of two-nodes in a chain, with self loops on both nodes, and\n     with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeChainSelfLoops'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'),\n                     ('H0', 'H0'), ('H1', 'H1'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A,\n                                   EdgeType.A, EdgeType.A\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A,\n                                   EdgeType.I, EdgeType.I\n                                   ]\n        else:\n            self.N_nodes = 3\n            self.edges = [('H0', 'H1'),\n                     ('H0', 'H0'), ('H1', 'H1'),\n                     ('S0', 'H0')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A,\n                                   EdgeType.A\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I,\n                                   EdgeType.A, EdgeType.A,\n                                   EdgeType.I\n                                   ]\n\n\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeChainSelfLoops.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeChainSelfLoops'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'),\n                 ('H0', 'H0'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I\n                               ]\n    else:\n        self.N_nodes = 3\n        self.edges = [('H0', 'H1'),\n                 ('H0', 'H0'), ('H1', 'H1'),\n                 ('S0', 'H0')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I\n                               ]\n\n\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycle","title":"<code>BinodeCycle</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a cycle, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeCycle(LibNet):\n    '''\n     Simple example of two-nodes in a cycle,\n     with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeCycle'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n        else:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('S0', 'H0')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.A,\n                          EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.A,\n                          EdgeType.I, EdgeType.I\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycle.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeCycle'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n    else:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('S0', 'H0')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.A,\n                      EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.A,\n                      EdgeType.I, EdgeType.I\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycleSelfLoop","title":"<code>BinodeCycleSelfLoop</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a cycle, with self loop on one node, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeCycleSelfLoop(LibNet):\n    '''\n     Simple example of two-nodes in a cycle, with self loop on one node, and\n     with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeCycleSelfLoop'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('H0', 'H0'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n        else:\n            self.N_nodes = 3\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('H0', 'H0'),\n                     ('S0', 'H0')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                          EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n        else:\n            self.edge_types = [EdgeType.Is, EdgeType.Is,\n                          EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycleSelfLoop.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeCycleSelfLoop'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('H0', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n    else:\n        self.N_nodes = 3\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('H0', 'H0'),\n                 ('S0', 'H0')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I,\n                      EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n    else:\n        self.edge_types = [EdgeType.Is, EdgeType.Is,\n                      EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycleSelfLoops","title":"<code>BinodeCycleSelfLoops</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a cycle, with self loops on both nodes, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeCycleSelfLoops(LibNet):\n    '''\n     Simple example of two-nodes in a cycle, with self loops on both nodes, and\n     with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeCycleSelfLoops'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('H0', 'H0'), ('H1', 'H1'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n        else:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                     ('H0', 'H0'), ('H1', 'H1'),\n                     ('S0', 'H0')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n        else:\n            self.edge_types = [EdgeType.Is, EdgeType.Is,\n                          EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeCycleSelfLoops.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeCycleSelfLoops'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('H0', 'H0'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n    else:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'), ('H1', 'H0'),\n                 ('H0', 'H0'), ('H1', 'H1'),\n                 ('S0', 'H0')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n    else:\n        self.edge_types = [EdgeType.Is, EdgeType.Is,\n                      EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeDoubleChain","title":"<code>BinodeDoubleChain</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of two-nodes in a double chain with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class BinodeDoubleChain(LibNet):\n    '''\n    Simple example of two-nodes in a double chain with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'BinodeDoubleChain'\n\n        if one_input is False:\n            self.N_nodes = 4\n            self.edges = [('H0', 'H1'),\n                          ('H1', 'H0'),\n                     ('S0', 'H0'), ('S1', 'H1')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I, EdgeType.I,\n                                   EdgeType.A, EdgeType.A\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I, EdgeType.I,\n                                   EdgeType.I, EdgeType.I,\n                                   ]\n        else:\n            self.N_nodes = 3\n            self.edges = [('H0', 'H1'),\n                          ('H1', 'H0'),\n                     ('S0', 'H0')\n                     ]\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I, EdgeType.I,\n                                   EdgeType.A,\n                                   ]\n            else:\n                self.edge_types = [EdgeType.I, EdgeType.I,\n                                   EdgeType.I,\n                                   ]\n\n\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.BinodeDoubleChain.__init__","title":"<code>__init__(activator_signals=True, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'BinodeDoubleChain'\n\n    if one_input is False:\n        self.N_nodes = 4\n        self.edges = [('H0', 'H1'),\n                      ('H1', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A\n                               ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.I, EdgeType.I,\n                               ]\n    else:\n        self.N_nodes = 3\n        self.edges = [('H0', 'H1'),\n                      ('H1', 'H0'),\n                 ('S0', 'H0')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.I,\n                               ]\n\n\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullQuadnodeNet","title":"<code>FullQuadnodeNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of four nodes in a cycle, with many output nodes spanning from the core four nodes, and three input nodes acting on the four core nodes.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class FullQuadnodeNet(LibNet):\n    '''\n    Example of four nodes in a cycle, with many\n    output nodes spanning from the core four nodes,\n    and three input nodes acting on the four core nodes.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'FullQuadnodeNet'\n\n        self.N_nodes = 16\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n                      ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3'),\n                      ('H0', 'G0'), ('H0', 'G1'), ('H0', 'G2'), ('H1', 'G3'),\n                      ('H1', 'G4'), ('H2', 'G5'), ('H2', 'G6'), ('H3', 'G7'),\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                               EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.A,\n                              ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                               EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                               EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.A,\n                              ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'G': NodeType.effector,\n                               'H': NodeType.core}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullQuadnodeNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'FullQuadnodeNet'\n\n    self.N_nodes = 16\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n                  ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'),\n                  ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3'),\n                  ('H0', 'G0'), ('H0', 'G1'), ('H0', 'G2'), ('H1', 'G3'),\n                  ('H1', 'G4'), ('H2', 'G5'), ('H2', 'G6'), ('H3', 'G7'),\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                           EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.A,\n                          ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                           EdgeType.A, EdgeType.A, EdgeType.I, EdgeType.A,\n                           EdgeType.I, EdgeType.A, EdgeType.I, EdgeType.A,\n                          ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'G': NodeType.effector,\n                           'H': NodeType.core}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullTrinodeNet","title":"<code>FullTrinodeNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of three nodes in a cycle, with many output nodes spanning from the core three nodes, and three input nodes acting on the three core nodes.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class FullTrinodeNet(LibNet):\n    '''\n    Example of three nodes in a cycle, with many\n    output nodes spanning from the core three nodes,\n    and three input nodes acting on the three core nodes.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'FullTrinodeNet'\n\n        # CASE TYPE QUADSTABLE with sensors and auxillary nodes in scale-free configuration:\n        # Core is triangle loop with all auto-nodes edges:\n        self.N_nodes = 14\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                 ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                 ('H2', 'G0'), ('H2', 'G1'), ('H2', 'G2'), ('H2', 'G3'), ('H2', 'G4'),\n                 ('H0', 'G5'), ('H0', 'G6'), ('H0', 'G7'),\n                 ('H1', 'G8')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                          EdgeType.A, EdgeType.I, EdgeType.A,\n                          EdgeType.A\n                          ]\n\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                          EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                          EdgeType.A, EdgeType.I, EdgeType.A,\n                          EdgeType.A\n                          ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'G': NodeType.effector,\n                               'H': NodeType.core}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullTrinodeNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'FullTrinodeNet'\n\n    # CASE TYPE QUADSTABLE with sensors and auxillary nodes in scale-free configuration:\n    # Core is triangle loop with all auto-nodes edges:\n    self.N_nodes = 14\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n             ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n             ('H2', 'G0'), ('H2', 'G1'), ('H2', 'G2'), ('H2', 'G3'), ('H2', 'G4'),\n             ('H0', 'G5'), ('H0', 'G6'), ('H0', 'G7'),\n             ('H1', 'G8')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                      EdgeType.A, EdgeType.I, EdgeType.A,\n                      EdgeType.A\n                      ]\n\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                      EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                      EdgeType.A, EdgeType.I, EdgeType.A,\n                      EdgeType.A\n                      ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'G': NodeType.effector,\n                           'H': NodeType.core}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullTrinodeNetFeedback","title":"<code>FullTrinodeNetFeedback</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Example of three nodes in a cycle, with many output nodes spanning from the core three nodes, and three input nodes acting on the three core nodes. This network has feedback between output and input nodes.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class FullTrinodeNetFeedback(LibNet):\n    '''\n    Example of three nodes in a cycle, with many\n    output nodes spanning from the core three nodes,\n    and three input nodes acting on the three core nodes.\n    This network has feedback between output and input nodes.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'FullTrinodeNetFeedback'\n\n        # CASE TYPE QUADSTABLE with sensors and auxillary nodes in scale-free configuration:\n        # Core is triangle loop with all auto-nodes edges:\n        self.N_nodes = 9\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                 ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                 ('F0', 'H0'), ('F1', 'H1'), ('F2', 'H2'),\n                 # ('H2', 'G0'), ('H2', 'G1'), ('H2', 'G2'), ('H2', 'G3'), ('H2', 'G4'),\n                 # ('H0', 'G5'), ('H0', 'G6'), ('H0', 'G7'),\n                 # ('H1', 'G8')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          # EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                          # EdgeType.A, EdgeType.I, EdgeType.A,\n                          # EdgeType.A\n                          ]\n\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                          EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                          # EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                          # EdgeType.A, EdgeType.I, EdgeType.A,\n                          # EdgeType.A\n                          ]\n\n        self.node_type_dict = {'S': NodeType.sensor,\n                               'F': NodeType.factor,\n                               'G': NodeType.effector,\n                               'H': NodeType.core}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.FullTrinodeNetFeedback.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'FullTrinodeNetFeedback'\n\n    # CASE TYPE QUADSTABLE with sensors and auxillary nodes in scale-free configuration:\n    # Core is triangle loop with all auto-nodes edges:\n    self.N_nodes = 9\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n             ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n             ('F0', 'H0'), ('F1', 'H1'), ('F2', 'H2'),\n             # ('H2', 'G0'), ('H2', 'G1'), ('H2', 'G2'), ('H2', 'G3'), ('H2', 'G4'),\n             # ('H0', 'G5'), ('H0', 'G6'), ('H0', 'G7'),\n             # ('H1', 'G8')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      # EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                      # EdgeType.A, EdgeType.I, EdgeType.A,\n                      # EdgeType.A\n                      ]\n\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                      EdgeType.Is, EdgeType.Is, EdgeType.Is,\n                      # EdgeType.A, EdgeType.I, EdgeType.A, EdgeType.A, EdgeType.I,\n                      # EdgeType.A, EdgeType.I, EdgeType.A,\n                      # EdgeType.A\n                      ]\n\n    self.node_type_dict = {'S': NodeType.sensor,\n                           'F': NodeType.factor,\n                           'G': NodeType.effector,\n                           'H': NodeType.core}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.InhibitorExample","title":"<code>InhibitorExample</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple two-node example of an inhibiting interaction.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class InhibitorExample(LibNet):\n    '''\n    Simple two-node example of an inhibiting interaction.\n    '''\n\n    def __init__(self, activator_signals: bool=False, one_input: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'InhibitorExample'\n\n        self.N_nodes = 2\n        self.edges = [('S0', 'H0')]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.InhibitorExample.__init__","title":"<code>__init__(activator_signals=False, one_input=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=False, one_input: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'InhibitorExample'\n\n    self.N_nodes = 2\n    self.edges = [('S0', 'H0')]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A,\n                           ]\n    else:\n        self.edge_types = [EdgeType.I,\n                           ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.LibNet","title":"<code>LibNet</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class LibNet(object, metaclass=ABCMeta):\n    '''\n\n    '''\n    def __init__(self):\n        '''\n\n        '''\n\n        pass\n\n    def count_nodes(self):\n\n        # count the nodes based on the edges, just in case there's an error:\n        nodes = []\n        for ei, ej in self.edges:\n            if ei not in nodes:\n                nodes.append(ei)\n            if ej not in nodes:\n                nodes.append(ej)\n\n        self.N_nodes = len(nodes)\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.LibNet.__init__","title":"<code>__init__()</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self):\n    '''\n\n    '''\n\n    pass\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.MAPK_net","title":"<code>MAPK_net</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This method imports the MAPK cancer cell fate network developed by Grieco et al. \"Integrative Modelling of the Influence of MAPK Network on Cancer Cell Fate Decision.\" PLoS Comp. Bio. 9(10): e1003286. 2013 https://doi.org/10.1371/journal.pcbi.1003286</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class MAPK_net(LibNet):\n    '''\n    This method imports the MAPK cancer cell fate network developed by\n    Grieco et al. \"Integrative Modelling of the Influence of MAPK Network on\n    Cancer Cell Fate Decision.\" PLoS Comp. Bio. 9(10): e1003286. 2013\n    https://doi.org/10.1371/journal.pcbi.1003286\n    '''\n\n    def __init__(self):\n        '''\n\n        '''\n\n        super().__init__()\n\n        self.name = 'MAPK_Cancer'\n\n        # nodes from the reference:\n        self.nodes_list = ['AKT',\n                            'AP1',\n                            'Apoptosis',\n                            'ATF2',\n                            'ATM',\n                            'BCL2',\n                            'CREB',\n                            'DNA_damage',\n                            'DUSP1',\n                            'EGFR',\n                            'EGFR_stimulus',\n                            'ELK1',\n                            'ERK',\n                            'FGFR3',\n                            'FGFR3_stimulus',\n                            'FOS',\n                            'FOXO3',\n                            'FRS2',\n                            'GAB1',\n                            'GADD45',\n                            'GRB2',\n                            'Growth_Arrest',\n                            'JNK',\n                            'JUN',\n                            'MAP3K1_3',\n                            'MAX',\n                            'MDM2',\n                            'MEK1_2',\n                            'MSK',\n                            'MTK1',\n                            'MYC',\n                            'p14',\n                            'p21',\n                            'p38',\n                            'p53',\n                            'p70',\n                            'PDK1',\n                            'PI3K',\n                            'PKC',\n                            'PLCG',\n                            'PPP2CA',\n                            'Proliferation',\n                            'PTEN',\n                            'RAF',\n                            'RAS',\n                            'RSK',\n                            'SMAD',\n                            'SOS',\n                            'SPRY',\n                            'TAK1',\n                            'TAOK',\n                            'TGFBR',\n                            'TGFBR_stimulus']\n\n        self.N_nodes = len(self.nodes_list)\n        self.node_type_dict = None\n\n        # As this network is very large, here we create the edges and edge types using a\n        # signed adjacency matrix acquired from Cell Collective.\n\n        # Path to load the signed adjacency matrix:\n        CSV_DIR = get_data_csv_dir()\n        csv_fname = FileRelative(CSV_DIR, 'MAPK_Cancer_Mo.csv')\n\n        # Load the csv file as a numpy matrix:\n        self._A_o = np.genfromtxt(csv_fname, delimiter=',', dtype=np.int32)\n\n        # Generate edges and edge types using a signed adjacency matrix:\n        self.edges = []\n        self.edge_types = []\n        for nde_i, nme_i in enumerate(self.nodes_list):\n            for nde_j, nme_j in enumerate(self.nodes_list):\n                a_ij = self._A_o[nde_i, nde_j]\n                if a_ij != 0:\n                    self.edges.append((nme_j, nme_i))\n                    if a_ij == 1:\n                        self.edge_types.append(EdgeType.A)\n                    elif a_ij == -1:\n                        self.edge_types.append(EdgeType.I)\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.MAPK_net.__init__","title":"<code>__init__()</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self):\n    '''\n\n    '''\n\n    super().__init__()\n\n    self.name = 'MAPK_Cancer'\n\n    # nodes from the reference:\n    self.nodes_list = ['AKT',\n                        'AP1',\n                        'Apoptosis',\n                        'ATF2',\n                        'ATM',\n                        'BCL2',\n                        'CREB',\n                        'DNA_damage',\n                        'DUSP1',\n                        'EGFR',\n                        'EGFR_stimulus',\n                        'ELK1',\n                        'ERK',\n                        'FGFR3',\n                        'FGFR3_stimulus',\n                        'FOS',\n                        'FOXO3',\n                        'FRS2',\n                        'GAB1',\n                        'GADD45',\n                        'GRB2',\n                        'Growth_Arrest',\n                        'JNK',\n                        'JUN',\n                        'MAP3K1_3',\n                        'MAX',\n                        'MDM2',\n                        'MEK1_2',\n                        'MSK',\n                        'MTK1',\n                        'MYC',\n                        'p14',\n                        'p21',\n                        'p38',\n                        'p53',\n                        'p70',\n                        'PDK1',\n                        'PI3K',\n                        'PKC',\n                        'PLCG',\n                        'PPP2CA',\n                        'Proliferation',\n                        'PTEN',\n                        'RAF',\n                        'RAS',\n                        'RSK',\n                        'SMAD',\n                        'SOS',\n                        'SPRY',\n                        'TAK1',\n                        'TAOK',\n                        'TGFBR',\n                        'TGFBR_stimulus']\n\n    self.N_nodes = len(self.nodes_list)\n    self.node_type_dict = None\n\n    # As this network is very large, here we create the edges and edge types using a\n    # signed adjacency matrix acquired from Cell Collective.\n\n    # Path to load the signed adjacency matrix:\n    CSV_DIR = get_data_csv_dir()\n    csv_fname = FileRelative(CSV_DIR, 'MAPK_Cancer_Mo.csv')\n\n    # Load the csv file as a numpy matrix:\n    self._A_o = np.genfromtxt(csv_fname, delimiter=',', dtype=np.int32)\n\n    # Generate edges and edge types using a signed adjacency matrix:\n    self.edges = []\n    self.edge_types = []\n    for nde_i, nme_i in enumerate(self.nodes_list):\n        for nde_j, nme_j in enumerate(self.nodes_list):\n            a_ij = self._A_o[nde_i, nde_j]\n            if a_ij != 0:\n                self.edges.append((nme_j, nme_i))\n                if a_ij == 1:\n                    self.edge_types.append(EdgeType.A)\n                elif a_ij == -1:\n                    self.edge_types.append(EdgeType.I)\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.PentanodeNet","title":"<code>PentanodeNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of five nodes in a cycle, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class PentanodeNet(LibNet):\n    '''\n    Simple example of five nodes in a cycle,\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'PentanodeNet'\n\n        self.N_nodes = 10\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H4'), ('H4', 'H0'),\n                 ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'), ('H4', 'H4'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3'), ('S4', 'H4')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.Is, EdgeType.Is, EdgeType.Is,EdgeType.Is, EdgeType.Is\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.PentanodeNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'PentanodeNet'\n\n    self.N_nodes = 10\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H4'), ('H4', 'H0'),\n             ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'), ('H4', 'H4'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3'), ('S4', 'H4')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.Is, EdgeType.Is, EdgeType.Is,EdgeType.Is, EdgeType.Is\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.QuadnodeNet","title":"<code>QuadnodeNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of four nodes in a cycle, with self-loops on each internal node, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class QuadnodeNet(LibNet):\n    '''\n    Simple example of four nodes in a cycle,\n    with self-loops on each internal node, and\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'QuadnodeNet'\n\n        self.N_nodes = 8\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n                      ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                              ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is\n                              ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.QuadnodeNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'QuadnodeNet'\n\n    self.N_nodes = 8\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H3'), ('H3', 'H0'),\n                  ('H0', 'H0'), ('H1', 'H1'), ('H2', 'H2'), ('H3', 'H3'),\n                  ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.Is, EdgeType.Is, EdgeType.Is, EdgeType.Is\n                          ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellNet","title":"<code>StemCellNet</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is the Oct4-Sox2-Nanog multistable core network of embryonic stem cells, with extrinsic signalling factors excluded.</p> <p>The network is sourced from the reference: Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellNet(LibNet):\n    '''\n    This biological network is the Oct4-Sox2-Nanog multistable core\n    network of embryonic stem cells, with extrinsic signalling\n    factors excluded.\n\n    The network is sourced from the reference:\n    Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem\n    cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellNet'\n\n        self.N_nodes = 6\n        self.edges = [\n                      ('NANOG', 'OCT4'),\n                      ('OCT4', 'NANOG'),\n                      ('OCT4', 'SOX2'),\n                      ('SOX2', 'OCT4'),\n                      ('SOX2', 'NANOG'),\n                      ('NANOG', 'SOX2'),\n                      ('SOX2', 'SOX2'),\n                      ('OCT4', 'OCT4'),\n                      ('S0', 'SOX2'),\n                      ('S1', 'NANOG'),\n                      ('S2', 'OCT4'),\n\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.I,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.I,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                               EdgeType.A,\n                          ]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n        self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellNet.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'StemCellNet'\n\n    self.N_nodes = 6\n    self.edges = [\n                  ('NANOG', 'OCT4'),\n                  ('OCT4', 'NANOG'),\n                  ('OCT4', 'SOX2'),\n                  ('SOX2', 'OCT4'),\n                  ('SOX2', 'NANOG'),\n                  ('NANOG', 'SOX2'),\n                  ('SOX2', 'SOX2'),\n                  ('OCT4', 'OCT4'),\n                  ('S0', 'SOX2'),\n                  ('S1', 'NANOG'),\n                  ('S2', 'OCT4'),\n\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                      ]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n    self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellNetFull","title":"<code>StemCellNetFull</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is the Oct4-Sox2-Nanog multistable core network of embryonic stem cells, with extrinsic signalling factors included.</p> <p>The network is sourced from the reference: Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellNetFull(LibNet):\n    '''\n    This biological network is the Oct4-Sox2-Nanog multistable core\n    network of embryonic stem cells, with extrinsic signalling\n    factors included.\n\n    The network is sourced from the reference:\n    Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem\n    cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellNetFull'\n\n        self.N_nodes = 27\n        self.edges = [('FGF2', 'RAS'),\n                      ('FGF2', 'PLCg'),\n                      ('FGF2', 'PI3k'),\n                      ('RAS', 'RAF'),\n                      ('RAF', 'MEK1/2'),\n                      ('MEK1/2', 'ERK1/2'),\n                      ('ERK1/2', 'TBX3'),\n                      ('TBX3', 'NANOG'),\n                      ('NANOG', 'OCT4'),\n                      ('OCT4', 'SOX2'),\n                      ('SOX2', 'NANOG'),\n                      ('OCT4', 'NANOG'),\n                      ('NANOG', 'SOX2'),\n                      ('SOX2', 'OCT4'),\n                      ('SOX2', 'SOX2'),\n                      ('OCT4', 'OCT4'),\n                      ('PLCg', 'DAG'),\n                      ('PKC', 'GSK3b'),\n                      ('GSK3b', 'cMYC'),\n                      ('cMYC', 'SOX2'),\n                      ('IGF2', 'PIP3'),\n                      ('PIP3', 'PKD1'),\n                      ('PKD1', 'AKT'),\n                      ('AKT', 'GSK3b'),\n                      ('BMP4', 'SMAD1584'),\n                      ('SMAD1584', 'NANOG'),\n                      ('TGF', 'SMAD234'),\n                      ('SMAD234', 'NANOG'),\n                      ('WNT', 'DVL'),\n                      ('DVL', 'bCAT'),\n                      ('bCAT', 'TCF3'),\n                      ('TCF3', 'NANOG'),\n                      ('PI3k', 'PIP3'),\n                      ('DAG', 'PKC')\n                 ]\n\n        self.edge_types = [EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                      ]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellNetFull.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'StemCellNetFull'\n\n    self.N_nodes = 27\n    self.edges = [('FGF2', 'RAS'),\n                  ('FGF2', 'PLCg'),\n                  ('FGF2', 'PI3k'),\n                  ('RAS', 'RAF'),\n                  ('RAF', 'MEK1/2'),\n                  ('MEK1/2', 'ERK1/2'),\n                  ('ERK1/2', 'TBX3'),\n                  ('TBX3', 'NANOG'),\n                  ('NANOG', 'OCT4'),\n                  ('OCT4', 'SOX2'),\n                  ('SOX2', 'NANOG'),\n                  ('OCT4', 'NANOG'),\n                  ('NANOG', 'SOX2'),\n                  ('SOX2', 'OCT4'),\n                  ('SOX2', 'SOX2'),\n                  ('OCT4', 'OCT4'),\n                  ('PLCg', 'DAG'),\n                  ('PKC', 'GSK3b'),\n                  ('GSK3b', 'cMYC'),\n                  ('cMYC', 'SOX2'),\n                  ('IGF2', 'PIP3'),\n                  ('PIP3', 'PKD1'),\n                  ('PKD1', 'AKT'),\n                  ('AKT', 'GSK3b'),\n                  ('BMP4', 'SMAD1584'),\n                  ('SMAD1584', 'NANOG'),\n                  ('TGF', 'SMAD234'),\n                  ('SMAD234', 'NANOG'),\n                  ('WNT', 'DVL'),\n                  ('DVL', 'bCAT'),\n                  ('bCAT', 'TCF3'),\n                  ('TCF3', 'NANOG'),\n                  ('PI3k', 'PIP3'),\n                  ('DAG', 'PKC')\n             ]\n\n    self.edge_types = [EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                  ]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellQuadrad","title":"<code>StemCellQuadrad</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is the Oct4-Sox2-Nanog + KLF4 multistable core network of embryonic stem cells, with some extrinsic signalling factors included.</p> <p>The network is sourced from the reference: Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellQuadrad(LibNet):\n    '''\n    This biological network is the Oct4-Sox2-Nanog + KLF4 multistable core\n    network of embryonic stem cells, with some extrinsic signalling\n    factors included.\n\n    The network is sourced from the reference:\n    Mossahbi-Mohammadi, M. et al. FGF signalling pathway: A key regulator of stem\n    cell pluripotency. Frontiers in Cell and Developmental Biology. 8:79. 2020.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellQuadrad'\n\n        self.N_nodes = 8\n        self.edges = [\n                      ('NANOG', 'OCT4'),\n                      ('OCT4', 'NANOG'),\n                      ('OCT4', 'SOX2'),\n                      ('SOX2', 'OCT4'),\n                      ('SOX2', 'NANOG'),\n                      ('NANOG', 'SOX2'),\n                      ('SOX2', 'SOX2'),\n                      ('OCT4', 'OCT4'),\n                      ('KLF4', 'KLF4'),\n                      ('KLF4', 'NANOG'),\n                      ('KLF4', 'SOX2'),\n                      ('KLF4', 'OCT4'),\n                      ('S1', 'SOX2'),\n                      ('S2', 'NANOG'),\n                      ('S0', 'OCT4'),\n                      # ('S3', 'KLF4'),\n\n                 ]\n\n        self.edge_types = [EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.I,\n                           EdgeType.I,\n                           # EdgeType.I,\n                      ]\n\n        self.N_input_edges = 3\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellQuadrad.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'StemCellQuadrad'\n\n    self.N_nodes = 8\n    self.edges = [\n                  ('NANOG', 'OCT4'),\n                  ('OCT4', 'NANOG'),\n                  ('OCT4', 'SOX2'),\n                  ('SOX2', 'OCT4'),\n                  ('SOX2', 'NANOG'),\n                  ('NANOG', 'SOX2'),\n                  ('SOX2', 'SOX2'),\n                  ('OCT4', 'OCT4'),\n                  ('KLF4', 'KLF4'),\n                  ('KLF4', 'NANOG'),\n                  ('KLF4', 'SOX2'),\n                  ('KLF4', 'OCT4'),\n                  ('S1', 'SOX2'),\n                  ('S2', 'NANOG'),\n                  ('S0', 'OCT4'),\n                  # ('S3', 'KLF4'),\n\n             ]\n\n    self.edge_types = [EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.I,\n                       EdgeType.I,\n                       # EdgeType.I,\n                  ]\n\n    self.N_input_edges = 3\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellTriad","title":"<code>StemCellTriad</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>This biological network is based on the Oct4-Sox2-Nanog multistable core network of embryonic stem cells, with basic signalling factors included. Here we are using this network to explore different combinations and permutations of edge interaction types.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellTriad(LibNet):\n    '''\n    This biological network is based on the Oct4-Sox2-Nanog multistable core\n    network of embryonic stem cells, with basic signalling factors included.\n    Here we are using this network to explore different combinations and\n    permutations of edge interaction types.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellTriad'\n\n        self.N_nodes = 3\n        self.edges = [\n                      ('NANOG', 'OCT4'),\n                      ('OCT4', 'NANOG'),\n                      ('OCT4', 'SOX2'),\n                      ('SOX2', 'OCT4'),\n                      ('SOX2', 'NANOG'),\n                      ('NANOG', 'SOX2'),\n                      ('SOX2', 'SOX2'),\n                      ('OCT4', 'OCT4'),\n                 ]\n\n        self.edge_types = [EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.I,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                           EdgeType.A,\n                      ]\n\n        self.N_input_edges = 0\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellTriad.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'StemCellTriad'\n\n    self.N_nodes = 3\n    self.edges = [\n                  ('NANOG', 'OCT4'),\n                  ('OCT4', 'NANOG'),\n                  ('OCT4', 'SOX2'),\n                  ('SOX2', 'OCT4'),\n                  ('SOX2', 'NANOG'),\n                  ('NANOG', 'SOX2'),\n                  ('SOX2', 'SOX2'),\n                  ('OCT4', 'OCT4'),\n             ]\n\n    self.edge_types = [EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.I,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                       EdgeType.A,\n                  ]\n\n    self.N_input_edges = 0\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellTriadChain","title":"<code>StemCellTriadChain</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>No matter which combination of activating or inhibiting edges were chosen, equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could not be produced with a fully-connected cycle. We found that by breaking the cycle into a double chain, biorealistic equilibrium states could be produced.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellTriadChain(LibNet):\n    '''\n    No matter which combination of activating or inhibiting edges were chosen,\n    equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could\n    not be produced with a fully-connected cycle. We found that by breaking the\n    cycle into a double chain, biorealistic equilibrium states could be produced.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = False):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellTriadChain'\n\n        self.N_nodes = 6\n        self.edges = [('OCT4', 'NANOG'), ('NANOG', 'SOX2'),\n                      ('NANOG', 'OCT4'), ('SOX2', 'NANOG'),\n                      ('OCT4', 'OCT4'), ('SOX2', 'SOX2'),\n                      ('S0', 'OCT4'), ('S1', 'NANOG'), ('S2', 'SOX2')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellTriadChain0","title":"<code>StemCellTriadChain0</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>No matter which combination of activating or inhibiting edges were chosen, equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could not be produced with a fully-connected cycle. We found that by breaking the cycle into a double chain, biorealistic equilibrium states could be produced. (Not sure how this differs from StemCellTriadChain; keeping just in case).</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellTriadChain0(LibNet):\n    '''\n    No matter which combination of activating or inhibiting edges were chosen,\n    equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could\n    not be produced with a fully-connected cycle. We found that by breaking the\n    cycle into a double chain, biorealistic equilibrium states could be produced.\n    (Not sure how this differs from StemCellTriadChain; keeping just in case).\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = False):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellTriadChain0'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H1'),\n                      ('H0', 'H0'), ('H2', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.StemCellTriadChain2","title":"<code>StemCellTriadChain2</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>No matter which combination of activating or inhibiting edges were chosen, equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could not be produced with a fully-connected cycle. We found that by breaking the cycle into a double chain, biorealistic equilibrium states could be produced. (Not sure how this differs from StemCellTriadChain; keeping just in case).</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class StemCellTriadChain2(LibNet):\n    '''\n    No matter which combination of activating or inhibiting edges were chosen,\n    equilibrium states corresponding to the SOX2-OCT4-NANOG triad system could\n    not be produced with a fully-connected cycle. We found that by breaking the\n    cycle into a double chain, biorealistic equilibrium states could be produced.\n    (Not sure how this differs from StemCellTriadChain; keeping just in case).\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = False):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'StemCellTriadChain2'\n\n        self.N_nodes = 8\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H1'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H3', 'H3'),\n                      ('H3', 'H0'), ('H3', 'H1'), ('H3', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'), ('S3', 'H3')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeChain","title":"<code>TrinodeChain</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a chain, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeChain(LibNet):\n    '''\n     Simple example of three-nodes in a chain,\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeChain'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.Is, EdgeType.Is,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeChainFullyConnected","title":"<code>TrinodeChainFullyConnected</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a double chain configuration, with self-loops on all internal nodes, and  with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeChainFullyConnected(LibNet):\n    '''\n    Simple example of three-nodes in a double chain configuration, with\n    self-loops on all internal nodes, and\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = False):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeChainFullyConnected'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H1'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeChainSelfLoops","title":"<code>TrinodeChainSelfLoops</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a chain, with self loops on each node, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeChainSelfLoops(LibNet):\n    '''\n     Simple example of three-nodes in a chain, with self loops on each node, and\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeChainSelfLoops'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.Is, EdgeType.Is,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycle","title":"<code>TrinodeCycle</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three nodes in a cycle, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeCycle(LibNet):\n    '''\n    Simple example of three nodes in a cycle,\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeCycle'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.A,\n                          EdgeType.I, EdgeType.I, EdgeType.I,\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycle.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeCycle'\n\n    self.N_nodes = 6\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.A,\n                      EdgeType.I, EdgeType.I, EdgeType.I,\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleFullyConnected","title":"<code>TrinodeCycleFullyConnected</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three nodes in a double cycle, with self-loops on all internal nodes, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeCycleFullyConnected(LibNet):\n    '''\n    Simple example of three nodes in a double cycle,\n    with self-loops on all internal nodes, and\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeCycleFullyConnected'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                      ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                     ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.I, EdgeType.A, EdgeType.A,\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleFullyConnected.__init__","title":"<code>__init__(activator_signals=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeCycleFullyConnected'\n\n    self.N_nodes = 6\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                  ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                  ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.I, EdgeType.A, EdgeType.A,\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleFullyConnected2","title":"<code>TrinodeCycleFullyConnected2</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three nodes in a double cycle, with self-loops on all internal nodes, and with input nodes acting on each internal node. (Not sure how this differs from TrinodeCycleFullyConnected, but keeping just in case we need it someday.)</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeCycleFullyConnected2(LibNet):\n    '''\n    Simple example of three nodes in a double cycle,\n    with self-loops on all internal nodes, and\n    with input nodes acting on each internal node.\n    (Not sure how this differs from TrinodeCycleFullyConnected,\n    but keeping just in case we need it someday.)\n    '''\n\n    def __init__(self, activator_signals: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeCycleFullyConnected2'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                      ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                     ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.I, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.I, EdgeType.A, EdgeType.A,\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleFullyConnected2.__init__","title":"<code>__init__(activator_signals=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeCycleFullyConnected2'\n\n    self.N_nodes = 6\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                  ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                  ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.I, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.I, EdgeType.I, EdgeType.I,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.I, EdgeType.A, EdgeType.A,\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleSelfLoops","title":"<code>TrinodeCycleSelfLoops</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three nodes in a cycle, with self-loops on all internal nodes, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeCycleSelfLoops(LibNet):\n    '''\n    Simple example of three nodes in a cycle,\n    with self-loops on all internal nodes, and\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeCycleSelfLoops'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                 ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.I, EdgeType.I, EdgeType.I,\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCycleSelfLoops.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeCycleSelfLoops'\n\n    self.N_nodes = 6\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n             ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.I, EdgeType.I,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.I, EdgeType.I, EdgeType.I,\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = None\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCyclesConnected","title":"<code>TrinodeCyclesConnected</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Two three-node cycles connected together, with self-loops on three internal nodes, and with input nodes acting on three internal nodes.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeCyclesConnected(LibNet):\n    '''\n    Two three-node cycles connected together,\n    with self-loops on three internal nodes, and\n    with input nodes acting on three internal nodes.\n    '''\n\n    def __init__(self, activator_signals: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeCyclesConnected'\n\n        self.N_nodes = 9\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                      ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                      ('H3', 'H4'), ('H4', 'H5'), ('H5', 'H3'),\n                      ('H4', 'H3'), ('H5', 'H4'), ('H3', 'H5'),\n                      ('H3', 'H3'), ('H5', 'H5'), ('H4', 'H4'),\n                      ('H2', 'H3'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                     ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A for i in self.edges]\n        else:\n            self.edge_types = [EdgeType.A for i in self.edges]\n            self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = Non\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeCyclesConnected.__init__","title":"<code>__init__(activator_signals=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeCyclesConnected'\n\n    self.N_nodes = 9\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                  ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                  ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                  ('H3', 'H4'), ('H4', 'H5'), ('H5', 'H3'),\n                  ('H4', 'H3'), ('H5', 'H4'), ('H3', 'H5'),\n                  ('H3', 'H3'), ('H5', 'H5'), ('H4', 'H4'),\n                  ('H2', 'H3'),\n                  ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                 ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A for i in self.edges]\n    else:\n        self.edge_types = [EdgeType.A for i in self.edges]\n        self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n    self.node_type_dict = {'S': NodeType.signal}\n    # self.node_type_dict = Non\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeDoubleChain","title":"<code>TrinodeDoubleChain</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a double chain, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeDoubleChain(LibNet):\n    '''\n     Simple example of three-nodes in a double chain,\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeDoubleChain'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H1'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeDoubleCycle","title":"<code>TrinodeDoubleCycle</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three nodes in a double cycle, with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeDoubleCycle(LibNet):\n    '''\n    Simple example of three nodes in a double cycle,\n    with input nodes acting on each internal node.\n    '''\n\n    def __init__(self, activator_signals: bool=False):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeDoubleCycle'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                      ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n                 ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n                 ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                          EdgeType.A, EdgeType.A, EdgeType.A,\n                          ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.I,\n                               EdgeType.I, EdgeType.I, EdgeType.A,\n                          EdgeType.I, EdgeType.I, EdgeType.I,\n                          ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeDoubleCycle.__init__","title":"<code>__init__(activator_signals=False)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=False):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'TrinodeDoubleCycle'\n\n    self.N_nodes = 6\n    self.edges = [('H0', 'H1'), ('H1', 'H2'), ('H2', 'H0'),\n                  ('H1', 'H0'), ('H2', 'H1'), ('H0', 'H2'),\n             ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2')\n             ]\n\n    if activator_signals:\n        self.edge_types = [EdgeType.A, EdgeType.A, EdgeType.A,\n                           EdgeType.A, EdgeType.A, EdgeType.A,\n                      EdgeType.A, EdgeType.A, EdgeType.A,\n                      ]\n    else:\n        self.edge_types = [EdgeType.I, EdgeType.A, EdgeType.I,\n                           EdgeType.I, EdgeType.I, EdgeType.A,\n                      EdgeType.I, EdgeType.I, EdgeType.I,\n                      ]\n\n    self.node_type_dict = {'S': NodeType.signal}\n\n    self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeDoubleFork","title":"<code>TrinodeDoubleFork</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a double forked configuration,  with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeDoubleFork(LibNet):\n    '''\n    Simple example of three-nodes in a double forked configuration,\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeDoubleFork'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H0', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H0'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeFork","title":"<code>TrinodeFork</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a forked configuration,  with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeFork(LibNet):\n    '''\n    Simple example of three-nodes in a forked configuration,\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeFork'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H0', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeForkFullyConnected","title":"<code>TrinodeForkFullyConnected</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a double fork configuration, with self-loops on all internal nodes, and  with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeForkFullyConnected(LibNet):\n    '''\n    Simple example of three-nodes in a double fork configuration, with\n    self-loops on all internal nodes, and\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = False):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeForkFullyConnected'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H0', 'H2'),\n                      ('H1', 'H0'), ('H2', 'H0'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.I, EdgeType.I, EdgeType.I,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.TrinodeForkSelfLoops","title":"<code>TrinodeForkSelfLoops</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Simple example of three-nodes in a forked configuration, with self loops on each node, and with input nodes acting on each internal node.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class TrinodeForkSelfLoops(LibNet):\n    '''\n     Simple example of three-nodes in a forked configuration, with self loops on each node, and\n     with input nodes acting on each internal node.\n    '''\n    # Initialize the superclass:\n\n    def __init__(self, activator_signals: bool = True):\n\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'TrinodeForkSelfLoops'\n\n        self.N_nodes = 6\n        self.edges = [('H0', 'H1'), ('H0', 'H2'),\n                      ('S0', 'H0'), ('S1', 'H1'), ('S2', 'H2'),\n                      ('H0', 'H0'), ('H2', 'H2'), ('H1', 'H1'),\n                      ]\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I, EdgeType.I,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n        else:\n            self.edge_types = [EdgeType.Is, EdgeType.Is,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               EdgeType.A, EdgeType.A, EdgeType.A,\n                               ]\n\n        self.node_type_dict = {'S': NodeType.signal}\n        # self.node_type_dict = None\n\n        self.add_interactions = True\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9","title":"<code>hESC_9</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate more structure around the classic SOX2-OCT4-NANOG triad.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class hESC_9(LibNet):\n    '''\n    Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate\n    more structure around the classic SOX2-OCT4-NANOG triad.\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'hESC_9'\n\n        self.N_nodes = 12\n        SOX2 = 'SOX2'\n        POU5F1 = 'OCT4'\n        NANOG = 'NANOG'\n        KLF4 = 'KLF4'\n        KLF15 = 'KLF15'\n        SP1 = 'SP1'\n        SP2 = 'SP2'\n        SP3 = 'SP3'\n        EGR2 = 'EGR2'\n\n        self.edges = [\n            (EGR2, KLF15),\n            (EGR2, KLF4),\n            (EGR2, POU5F1),\n            (EGR2, SOX2),\n            (EGR2, SP1),\n            (EGR2, SP2),\n            (EGR2, SP3),\n            (KLF15, KLF15),\n            (KLF15, KLF4),\n            (KLF15, POU5F1),\n            (KLF15, SOX2),\n            (KLF15, SP1),\n            (KLF15, SP2),\n            (KLF15, SP3),\n            (KLF4, KLF15),\n            (KLF4, KLF4),\n            (KLF4, NANOG),\n            (KLF4, POU5F1),\n            (KLF4, SOX2),\n            (KLF4, SP1),\n            (NANOG, POU5F1),\n            (NANOG, SOX2),\n            (POU5F1, EGR2),\n            (POU5F1, NANOG),\n            (POU5F1, POU5F1),\n            (POU5F1, SOX2),\n            (SOX2, NANOG),\n            (SOX2, POU5F1),\n            (SOX2, SOX2),\n            (SP1, EGR2),\n            (SP1, KLF15),\n            (SP1, KLF4),\n            (SP1, POU5F1),\n            (SP1, SOX2),\n            (SP1, SP1),\n            (SP1, SP2),\n            (SP1, SP3),\n            (SP2, EGR2),\n            (SP2, KLF15),\n            (SP2, KLF4),\n            (SP2, POU5F1),\n            (SP2, SOX2),\n            (SP2, SP1),\n            (SP2, SP2),\n            (SP2, SP3),\n            (SP3, EGR2),\n            (SP3, KLF15),\n            (SP3, KLF4),\n            (SP3, POU5F1),\n            (SP3, SOX2),\n            (SP3, SP1),\n            (SP3, SP2),\n            (SP3, SP3),\n            (\"S2\", NANOG),\n            (\"S1\", SOX2),\n            (\"S3\", KLF4),\n            (\"S0\", POU5F1)\n                 ]\n\n        self.edge_types = [EdgeType.A for i in self.edges]\n        self.edge_types[-4:] = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n\n        self.N_input_edges = 4\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'hESC_9'\n\n    self.N_nodes = 12\n    SOX2 = 'SOX2'\n    POU5F1 = 'OCT4'\n    NANOG = 'NANOG'\n    KLF4 = 'KLF4'\n    KLF15 = 'KLF15'\n    SP1 = 'SP1'\n    SP2 = 'SP2'\n    SP3 = 'SP3'\n    EGR2 = 'EGR2'\n\n    self.edges = [\n        (EGR2, KLF15),\n        (EGR2, KLF4),\n        (EGR2, POU5F1),\n        (EGR2, SOX2),\n        (EGR2, SP1),\n        (EGR2, SP2),\n        (EGR2, SP3),\n        (KLF15, KLF15),\n        (KLF15, KLF4),\n        (KLF15, POU5F1),\n        (KLF15, SOX2),\n        (KLF15, SP1),\n        (KLF15, SP2),\n        (KLF15, SP3),\n        (KLF4, KLF15),\n        (KLF4, KLF4),\n        (KLF4, NANOG),\n        (KLF4, POU5F1),\n        (KLF4, SOX2),\n        (KLF4, SP1),\n        (NANOG, POU5F1),\n        (NANOG, SOX2),\n        (POU5F1, EGR2),\n        (POU5F1, NANOG),\n        (POU5F1, POU5F1),\n        (POU5F1, SOX2),\n        (SOX2, NANOG),\n        (SOX2, POU5F1),\n        (SOX2, SOX2),\n        (SP1, EGR2),\n        (SP1, KLF15),\n        (SP1, KLF4),\n        (SP1, POU5F1),\n        (SP1, SOX2),\n        (SP1, SP1),\n        (SP1, SP2),\n        (SP1, SP3),\n        (SP2, EGR2),\n        (SP2, KLF15),\n        (SP2, KLF4),\n        (SP2, POU5F1),\n        (SP2, SOX2),\n        (SP2, SP1),\n        (SP2, SP2),\n        (SP2, SP3),\n        (SP3, EGR2),\n        (SP3, KLF15),\n        (SP3, KLF4),\n        (SP3, POU5F1),\n        (SP3, SOX2),\n        (SP3, SP1),\n        (SP3, SP2),\n        (SP3, SP3),\n        (\"S2\", NANOG),\n        (\"S1\", SOX2),\n        (\"S3\", KLF4),\n        (\"S0\", POU5F1)\n             ]\n\n    self.edge_types = [EdgeType.A for i in self.edges]\n    self.edge_types[-4:] = [EdgeType.I, EdgeType.I, EdgeType.I, EdgeType.I]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n\n    self.N_input_edges = 4\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9a","title":"<code>hESC_9a</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate more structure around the classic SOX2-OCT4-NANOG triad.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class hESC_9a(LibNet):\n    '''\n    Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate\n    more structure around the classic SOX2-OCT4-NANOG triad.\n    '''\n\n    def __init__(self, activator_signals: bool=True, use_special_edges: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'hESC_9a'\n\n        self.N_nodes = 12\n        SOX2 = 'SOX2'\n        POU5F1 = 'OCT4'\n        NANOG = 'NANOG'\n        KLF4 = 'KLF4'\n        KLF15 = 'KLF15'\n        SP1 = 'SP1'\n        SP2 = 'SP2'\n        SP3 = 'SP3'\n        EGR2 = 'EGR2'\n\n\n        self.edges = [\n            (EGR2, KLF15),\n            (EGR2, KLF4),\n            (EGR2, POU5F1),\n            (EGR2, SOX2),\n            (EGR2, SP1),\n            (EGR2, SP2),\n            (EGR2, SP3),\n            (KLF15, KLF4),\n            (KLF15, POU5F1),\n            (KLF15, SOX2),\n            (KLF15, SP1),\n            (KLF15, SP2),\n            (KLF15, SP3),\n            (KLF4, KLF15),\n            (KLF4, KLF4),\n            (KLF4, NANOG),\n            (KLF4, POU5F1),\n            (KLF4, SOX2),\n            (KLF4, SP1),\n            (NANOG, POU5F1),\n            (NANOG, SOX2),\n            (POU5F1, EGR2),\n            (POU5F1, NANOG),\n            (POU5F1, POU5F1),\n            (POU5F1, SOX2),\n            (SOX2, NANOG),\n            (SOX2, POU5F1),\n            (SP1, EGR2),\n            (SP1, KLF15),\n            (SP1, KLF4),\n            (SP1, POU5F1),\n            (SP1, SOX2),\n            (SP1, SP1),\n            (SP1, SP2),\n            (SP1, SP3),\n            (SP2, EGR2),\n            (SP2, KLF15),\n            (SP2, KLF4),\n            (SP2, POU5F1),\n            (SP2, SOX2),\n            (SP2, SP1),\n            (SP2, SP3),\n            (SP3, EGR2),\n            (SP3, KLF15),\n            (SP3, KLF4),\n            (SP3, POU5F1),\n            (SP3, SOX2),\n            (SP3, SP1),\n            (SP3, SP2),\n            (SOX2, SOX2),\n            (SP3, SP3),\n            (SP2, SP2),\n            (KLF15, KLF15),\n            (\"S0\", NANOG),\n            (\"S1\", SOX2),\n            (\"S2\", KLF4)\n                 ]\n\n\n        if use_special_edges is False:\n\n            if activator_signals:\n                self.edge_types = [EdgeType.I for i in self.edges]\n                self.edge_types[-7:] = [EdgeType.A, EdgeType.A, EdgeType.A]\n\n            else:\n                self.edge_types = [EdgeType.A for i in self.edges]\n                self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n        else:\n\n            self.edge_types = [EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.A,\n                                EdgeType.I,\n                                EdgeType.I,\n                                EdgeType.I]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n\n        self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9a.__init__","title":"<code>__init__(activator_signals=True, use_special_edges=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True, use_special_edges: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'hESC_9a'\n\n    self.N_nodes = 12\n    SOX2 = 'SOX2'\n    POU5F1 = 'OCT4'\n    NANOG = 'NANOG'\n    KLF4 = 'KLF4'\n    KLF15 = 'KLF15'\n    SP1 = 'SP1'\n    SP2 = 'SP2'\n    SP3 = 'SP3'\n    EGR2 = 'EGR2'\n\n\n    self.edges = [\n        (EGR2, KLF15),\n        (EGR2, KLF4),\n        (EGR2, POU5F1),\n        (EGR2, SOX2),\n        (EGR2, SP1),\n        (EGR2, SP2),\n        (EGR2, SP3),\n        (KLF15, KLF4),\n        (KLF15, POU5F1),\n        (KLF15, SOX2),\n        (KLF15, SP1),\n        (KLF15, SP2),\n        (KLF15, SP3),\n        (KLF4, KLF15),\n        (KLF4, KLF4),\n        (KLF4, NANOG),\n        (KLF4, POU5F1),\n        (KLF4, SOX2),\n        (KLF4, SP1),\n        (NANOG, POU5F1),\n        (NANOG, SOX2),\n        (POU5F1, EGR2),\n        (POU5F1, NANOG),\n        (POU5F1, POU5F1),\n        (POU5F1, SOX2),\n        (SOX2, NANOG),\n        (SOX2, POU5F1),\n        (SP1, EGR2),\n        (SP1, KLF15),\n        (SP1, KLF4),\n        (SP1, POU5F1),\n        (SP1, SOX2),\n        (SP1, SP1),\n        (SP1, SP2),\n        (SP1, SP3),\n        (SP2, EGR2),\n        (SP2, KLF15),\n        (SP2, KLF4),\n        (SP2, POU5F1),\n        (SP2, SOX2),\n        (SP2, SP1),\n        (SP2, SP3),\n        (SP3, EGR2),\n        (SP3, KLF15),\n        (SP3, KLF4),\n        (SP3, POU5F1),\n        (SP3, SOX2),\n        (SP3, SP1),\n        (SP3, SP2),\n        (SOX2, SOX2),\n        (SP3, SP3),\n        (SP2, SP2),\n        (KLF15, KLF15),\n        (\"S0\", NANOG),\n        (\"S1\", SOX2),\n        (\"S2\", KLF4)\n             ]\n\n\n    if use_special_edges is False:\n\n        if activator_signals:\n            self.edge_types = [EdgeType.I for i in self.edges]\n            self.edge_types[-7:] = [EdgeType.A, EdgeType.A, EdgeType.A]\n\n        else:\n            self.edge_types = [EdgeType.A for i in self.edges]\n            self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n    else:\n\n        self.edge_types = [EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.A,\n                            EdgeType.I,\n                            EdgeType.I,\n                            EdgeType.I]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n\n    self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9b","title":"<code>hESC_9b</code>","text":"<p>               Bases: <code>LibNet</code></p> <p>Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate more structure around the classic SOX2-OCT4-NANOG triad.</p> Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>class hESC_9b(LibNet):\n    '''\n    Uses the DNase Footprint derived TF networks at regulatory_networks.org to generate\n    more structure around the classic SOX2-OCT4-NANOG triad.\n\n    '''\n\n    def __init__(self, activator_signals: bool=True):\n        '''\n\n        '''\n        # Initialize the superclass:\n        super().__init__()\n\n        self.name = 'hESC_9b'\n\n        self.N_nodes = 12\n        SOX2 = 'SOX2'\n        POU5F1 = 'OCT4'\n        NANOG = 'NANOG'\n        KLF4 = 'KLF4'\n        KLF15 = 'KLF15'\n        SP1 = 'SP1'\n        SP2 = 'SP2'\n        SP3 = 'SP3'\n        EGR2 = 'EGR2'\n\n\n        self.edges = [\n            (EGR2, KLF15),\n            (EGR2, KLF4),\n            (EGR2, POU5F1),\n            (EGR2, SOX2),\n            (EGR2, SP1),\n            (EGR2, SP2),\n            (EGR2, SP3),\n            (KLF15, KLF15),\n            (KLF15, KLF4),\n            (KLF15, POU5F1),\n            (KLF15, SOX2),\n            (KLF15, SP1),\n            (KLF15, SP2),\n            (KLF15, SP3),\n            (KLF4, KLF15),\n            (KLF4, KLF4),\n            (KLF4, NANOG),\n            (KLF4, POU5F1),\n            (KLF4, SOX2),\n            (KLF4, SP1),\n            (NANOG, POU5F1),\n            (NANOG, SOX2),\n            (POU5F1, EGR2),\n            (POU5F1, NANOG),\n            (POU5F1, POU5F1),\n            (POU5F1, SOX2),\n            (SOX2, NANOG),\n            (SOX2, POU5F1),\n            (SOX2, SOX2),\n            (SP1, EGR2),\n            (SP1, KLF15),\n            (SP1, KLF4),\n            (SP1, POU5F1),\n            (SP1, SOX2),\n            (SP1, SP1),\n            (SP1, SP2),\n            (SP1, SP3),\n            (SP2, EGR2),\n            (SP2, KLF15),\n            (SP2, KLF4),\n            (SP2, POU5F1),\n            (SP2, SOX2),\n            (SP2, SP1),\n            (SP2, SP2),\n            (SP2, SP3),\n            (SP3, EGR2),\n            (SP3, KLF15),\n            (SP3, KLF4),\n            (SP3, POU5F1),\n            (SP3, SOX2),\n            (SP3, SP1),\n            (SP3, SP2),\n            (SP3, SP3),\n            (\"S0\", POU5F1),\n            (\"S1\", SOX2),\n            (\"S2\", NANOG)\n                 ]\n\n        self.edge_types = [EdgeType.A for i in self.edges]\n        self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n        self.node_type_dict = None\n\n        self.add_interactions = True\n\n        self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library.hESC_9b.__init__","title":"<code>__init__(activator_signals=True)</code>","text":"Source code in <code>cellnition/science/network_models/network_library.py</code> <pre><code>def __init__(self, activator_signals: bool=True):\n    '''\n\n    '''\n    # Initialize the superclass:\n    super().__init__()\n\n    self.name = 'hESC_9b'\n\n    self.N_nodes = 12\n    SOX2 = 'SOX2'\n    POU5F1 = 'OCT4'\n    NANOG = 'NANOG'\n    KLF4 = 'KLF4'\n    KLF15 = 'KLF15'\n    SP1 = 'SP1'\n    SP2 = 'SP2'\n    SP3 = 'SP3'\n    EGR2 = 'EGR2'\n\n\n    self.edges = [\n        (EGR2, KLF15),\n        (EGR2, KLF4),\n        (EGR2, POU5F1),\n        (EGR2, SOX2),\n        (EGR2, SP1),\n        (EGR2, SP2),\n        (EGR2, SP3),\n        (KLF15, KLF15),\n        (KLF15, KLF4),\n        (KLF15, POU5F1),\n        (KLF15, SOX2),\n        (KLF15, SP1),\n        (KLF15, SP2),\n        (KLF15, SP3),\n        (KLF4, KLF15),\n        (KLF4, KLF4),\n        (KLF4, NANOG),\n        (KLF4, POU5F1),\n        (KLF4, SOX2),\n        (KLF4, SP1),\n        (NANOG, POU5F1),\n        (NANOG, SOX2),\n        (POU5F1, EGR2),\n        (POU5F1, NANOG),\n        (POU5F1, POU5F1),\n        (POU5F1, SOX2),\n        (SOX2, NANOG),\n        (SOX2, POU5F1),\n        (SOX2, SOX2),\n        (SP1, EGR2),\n        (SP1, KLF15),\n        (SP1, KLF4),\n        (SP1, POU5F1),\n        (SP1, SOX2),\n        (SP1, SP1),\n        (SP1, SP2),\n        (SP1, SP3),\n        (SP2, EGR2),\n        (SP2, KLF15),\n        (SP2, KLF4),\n        (SP2, POU5F1),\n        (SP2, SOX2),\n        (SP2, SP1),\n        (SP2, SP2),\n        (SP2, SP3),\n        (SP3, EGR2),\n        (SP3, KLF15),\n        (SP3, KLF4),\n        (SP3, POU5F1),\n        (SP3, SOX2),\n        (SP3, SP1),\n        (SP3, SP2),\n        (SP3, SP3),\n        (\"S0\", POU5F1),\n        (\"S1\", SOX2),\n        (\"S2\", NANOG)\n             ]\n\n    self.edge_types = [EdgeType.A for i in self.edges]\n    self.edge_types[-3:] = [EdgeType.I, EdgeType.I, EdgeType.I]\n\n    self.node_type_dict = None\n\n    self.add_interactions = True\n\n    self.N_input_edges = 3\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/","title":"Gene Knockout Simulator","text":"<p>               Bases: <code>object</code></p> <p>Given a network model, this class contains routines to perform gene-knockout experiments (gene silencing) whereby individual genes are silenced and the behaviour of the network re-assessed.</p> Source code in <code>cellnition/science/networks_toolbox/gene_knockout.py</code> <pre><code>class GeneKnockout(object):\n    '''\n    Given a network model, this class contains routines to perform gene-knockout\n    experiments (gene silencing) whereby individual genes are silenced and\n    the behaviour of the network re-assessed.\n\n    '''\n    def __init__(self, pnet: ProbabilityNet):\n        '''\n        Initialize the class.\n\n        Parameters\n        ----------\n        pnet : GeneNetworkModel\n            An instance of GeneNetworkModel with an analytical model built;\n            forms the basis of the knockout experiment.\n\n        '''\n        self._pnet = pnet # initialize the system\n\n    def gene_knockout_ss_solve(self,\n                               Ns: int = 3,\n                               tol: float = 1.0e-15,\n                               sol_tol: float = 1.0e-1,\n                               d_base: float = 1.0,\n                               n_base: float = 3.0,\n                               beta_base: float = 4.0,\n                               verbose: bool = True,\n                               save_file_basename: str | None = None,\n                               constraint_vals: list[float]|None = None,\n                               constraint_inds: list[int]|None = None,\n                               signal_constr_vals: list | None = None,\n                               search_cycle_nodes_only: bool = False,\n                               ):\n        '''\n        Performs a sequential knockout of all genes in the network, computing all possible steady-state\n        solutions for the resulting knockout. This is different from the transition matrix,\n        as the knockouts aren't a temporary perturbation, but a long-term silencing.\n\n        '''\n\n        if constraint_vals is not None and constraint_inds is not None:\n            if len(constraint_vals) != len(constraint_inds):\n                raise Exception(\"Node constraint values must be same length as constrained node indices!\")\n\n        knockout_sol_set = [] # Master list to hold all -- possibly multistable -- solutions.\n        knockout_header = [] # Header to hold an index of the gene knockout and the sub-solution indices\n\n        if save_file_basename is not None:\n            save_file_list = [f'{save_file_basename}_allc.csv']\n            save_file_list.extend([f'{save_file_basename}_ko_c{i}.csv' for i in range(self._pnet.N_nodes)])\n\n        else:\n            save_file_list = [None]\n            save_file_list.extend([None for i in range(self._pnet.N_nodes)])\n\n        constrained_inds, constrained_vals = self._pnet._handle_constrained_nodes(constraint_inds,\n                                                                                  constraint_vals)\n\n\n        solsM, sol_M0_char, sols_0 = self._pnet.solve_probability_equms(constraint_inds=constrained_inds,\n                                                                        constraint_vals=constrained_vals,\n                                                                        signal_constr_vals=signal_constr_vals,\n                                                                        d_base=d_base,\n                                                                        n_base=n_base,\n                                                                        beta_base=beta_base,\n                                                                        N_space=Ns,\n                                                                        search_tol=tol,\n                                                                        sol_tol=sol_tol,\n                                                                        search_main_nodes_only=search_cycle_nodes_only\n                                                                        )\n\n        if verbose:\n            print(f'-------------------')\n\n        # print(f'size of solM before clustering: {solsM.shape}')\n\n        # Cluster solutions to exclude those that are very similar\n        solsM = self.find_unique_sols(solsM)\n\n        # print(f'size of solM after clustering: {solsM.shape}')\n\n        knockout_sol_set.append(solsM.copy()) # append the \"wild-type\" solution set\n        knockout_header.extend([f'wt,' for j in range(solsM.shape[1])])\n\n        for nde_i in self._pnet.nodes_index:\n\n            if nde_i in self._pnet.input_node_inds:\n                sig_ind = self._pnet.input_node_inds.index(nde_i)\n                signal_constr_vals_mod = signal_constr_vals.copy()\n                signal_constr_vals_mod[sig_ind] = self._pnet.p_min\n\n                if constraint_vals is not None or constraint_inds is not None:\n                    cvals = constraint_vals\n                    cinds = constraint_inds\n                else:\n                    cvals = None\n                    cinds = None\n\n            else:\n                signal_constr_vals_mod = signal_constr_vals\n\n                if constraint_vals is None or constraint_inds is None:\n                    # Gene knockout is the only constraint:\n                    cvals = [self._pnet.p_min]\n                    cinds = [nde_i]\n\n                else: # add the gene knockout as a final constraint:\n                    cvals = constraint_vals + [self._pnet.p_min]\n                    cinds = constraint_inds + [nde_i]\n\n            # We also need to add in naturally-occurring constraints from unregulated nodes:\n\n            solsM, sol_M0_char, sols_1 = self._pnet.solve_probability_equms(constraint_inds=cinds,\n                                                                            constraint_vals=cvals,\n                                                                            signal_constr_vals=signal_constr_vals_mod,\n                                                                            d_base=d_base,\n                                                                            n_base=n_base,\n                                                                            beta_base=beta_base,\n                                                                            N_space=Ns,\n                                                                            search_tol=tol,\n                                                                            sol_tol=sol_tol,\n                                                                            verbose=verbose,\n                                                                            search_main_nodes_only=search_cycle_nodes_only\n                                                                            )\n\n            if verbose:\n                print(f'-------------------')\n\n            # print(f'size of solM {i} before clustering: {solsM.shape}')\n\n            # Cluster solutions to exclude those that are very similar\n            solsM = self.find_unique_sols(solsM)\n\n            # print(f'size of solM {i} after clustering: {solsM.shape}')\n\n            knockout_sol_set.append(solsM.copy())\n            knockout_header.extend([f'{self._pnet.nodes_list[nde_i]},' for j in range(solsM.shape[1])])\n\n        # merge this into a master matrix:\n        ko_M = None\n        for i, ko_aro in enumerate(knockout_sol_set):\n            if len(ko_aro) == 0:\n                ko_ar = np.asarray([np.zeros(self._pnet.N_nodes)]).T\n            else:\n                ko_ar = ko_aro\n\n            if i == 0:\n                ko_M = ko_ar\n            else:\n                ko_M = np.hstack((ko_M, ko_ar))\n\n        return knockout_sol_set, ko_M, knockout_header\n\n\n    def plot_knockout_arrays(self, knockout_sol_set: list | ndarray, figsave: str=None):\n            '''\n            Plot all steady-state solution arrays in a knockout experiment solution set.\n\n            '''\n\n            # let's plot this as a multidimensional set of master arrays:\n            knock_flat = []\n            for kmat in knockout_sol_set:\n                for ki in kmat:\n                    knock_flat.extend(ki)\n\n            vmax = np.max(knock_flat)\n            vmin = np.min(knock_flat)\n\n            cmap = 'magma'\n\n            N_axis = len(knockout_sol_set)\n\n            fig, axes = plt.subplots(1, N_axis, sharey=True, sharex=True)\n\n            for i, (axi, solsMio) in enumerate(zip(axes, knockout_sol_set)):\n                if len(solsMio):\n                    solsMi = solsMio\n                else:\n                    solsMi = np.asarray([np.zeros(self._pnet.N_nodes)]).T\n                axi.imshow(solsMi, aspect=\"equal\", vmax=vmax, vmin=vmin, cmap=cmap)\n                axi.axis('off')\n                if i != 0:\n                    axi.set_title(f'c{i - 1}')\n                else:\n                    axi.set_title(f'Full')\n\n            if figsave is not None:\n                plt.savefig(figsave, dpi=300, transparent=True, format='png')\n\n            return fig, axes\n\n    def find_unique_sols(self,\n                         solsM\n                         ):\n        '''\n\n        '''\n\n        # redefine the solsM data structures:\n        solsM = self._pnet.multiround(solsM)\n\n        # # # first use numpy unique on rounded set of solutions to exclude similar cases:\n        _, inds_solsM_all_unique = np.unique(solsM, return_index=True, axis=1)\n        solsM = solsM[:, inds_solsM_all_unique]\n\n        return solsM\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/#cellnition.science.networks_toolbox.gene_knockout.GeneKnockout.__init__","title":"<code>__init__(pnet)</code>","text":"<p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>pnet</code> <code>GeneNetworkModel</code> <p>An instance of GeneNetworkModel with an analytical model built; forms the basis of the knockout experiment.</p> required Source code in <code>cellnition/science/networks_toolbox/gene_knockout.py</code> <pre><code>def __init__(self, pnet: ProbabilityNet):\n    '''\n    Initialize the class.\n\n    Parameters\n    ----------\n    pnet : GeneNetworkModel\n        An instance of GeneNetworkModel with an analytical model built;\n        forms the basis of the knockout experiment.\n\n    '''\n    self._pnet = pnet # initialize the system\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/#cellnition.science.networks_toolbox.gene_knockout.GeneKnockout.find_unique_sols","title":"<code>find_unique_sols(solsM)</code>","text":"Source code in <code>cellnition/science/networks_toolbox/gene_knockout.py</code> <pre><code>def find_unique_sols(self,\n                     solsM\n                     ):\n    '''\n\n    '''\n\n    # redefine the solsM data structures:\n    solsM = self._pnet.multiround(solsM)\n\n    # # # first use numpy unique on rounded set of solutions to exclude similar cases:\n    _, inds_solsM_all_unique = np.unique(solsM, return_index=True, axis=1)\n    solsM = solsM[:, inds_solsM_all_unique]\n\n    return solsM\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/#cellnition.science.networks_toolbox.gene_knockout.GeneKnockout.gene_knockout_ss_solve","title":"<code>gene_knockout_ss_solve(Ns=3, tol=1e-15, sol_tol=0.1, d_base=1.0, n_base=3.0, beta_base=4.0, verbose=True, save_file_basename=None, constraint_vals=None, constraint_inds=None, signal_constr_vals=None, search_cycle_nodes_only=False)</code>","text":"<p>Performs a sequential knockout of all genes in the network, computing all possible steady-state solutions for the resulting knockout. This is different from the transition matrix, as the knockouts aren't a temporary perturbation, but a long-term silencing.</p> Source code in <code>cellnition/science/networks_toolbox/gene_knockout.py</code> <pre><code>def gene_knockout_ss_solve(self,\n                           Ns: int = 3,\n                           tol: float = 1.0e-15,\n                           sol_tol: float = 1.0e-1,\n                           d_base: float = 1.0,\n                           n_base: float = 3.0,\n                           beta_base: float = 4.0,\n                           verbose: bool = True,\n                           save_file_basename: str | None = None,\n                           constraint_vals: list[float]|None = None,\n                           constraint_inds: list[int]|None = None,\n                           signal_constr_vals: list | None = None,\n                           search_cycle_nodes_only: bool = False,\n                           ):\n    '''\n    Performs a sequential knockout of all genes in the network, computing all possible steady-state\n    solutions for the resulting knockout. This is different from the transition matrix,\n    as the knockouts aren't a temporary perturbation, but a long-term silencing.\n\n    '''\n\n    if constraint_vals is not None and constraint_inds is not None:\n        if len(constraint_vals) != len(constraint_inds):\n            raise Exception(\"Node constraint values must be same length as constrained node indices!\")\n\n    knockout_sol_set = [] # Master list to hold all -- possibly multistable -- solutions.\n    knockout_header = [] # Header to hold an index of the gene knockout and the sub-solution indices\n\n    if save_file_basename is not None:\n        save_file_list = [f'{save_file_basename}_allc.csv']\n        save_file_list.extend([f'{save_file_basename}_ko_c{i}.csv' for i in range(self._pnet.N_nodes)])\n\n    else:\n        save_file_list = [None]\n        save_file_list.extend([None for i in range(self._pnet.N_nodes)])\n\n    constrained_inds, constrained_vals = self._pnet._handle_constrained_nodes(constraint_inds,\n                                                                              constraint_vals)\n\n\n    solsM, sol_M0_char, sols_0 = self._pnet.solve_probability_equms(constraint_inds=constrained_inds,\n                                                                    constraint_vals=constrained_vals,\n                                                                    signal_constr_vals=signal_constr_vals,\n                                                                    d_base=d_base,\n                                                                    n_base=n_base,\n                                                                    beta_base=beta_base,\n                                                                    N_space=Ns,\n                                                                    search_tol=tol,\n                                                                    sol_tol=sol_tol,\n                                                                    search_main_nodes_only=search_cycle_nodes_only\n                                                                    )\n\n    if verbose:\n        print(f'-------------------')\n\n    # print(f'size of solM before clustering: {solsM.shape}')\n\n    # Cluster solutions to exclude those that are very similar\n    solsM = self.find_unique_sols(solsM)\n\n    # print(f'size of solM after clustering: {solsM.shape}')\n\n    knockout_sol_set.append(solsM.copy()) # append the \"wild-type\" solution set\n    knockout_header.extend([f'wt,' for j in range(solsM.shape[1])])\n\n    for nde_i in self._pnet.nodes_index:\n\n        if nde_i in self._pnet.input_node_inds:\n            sig_ind = self._pnet.input_node_inds.index(nde_i)\n            signal_constr_vals_mod = signal_constr_vals.copy()\n            signal_constr_vals_mod[sig_ind] = self._pnet.p_min\n\n            if constraint_vals is not None or constraint_inds is not None:\n                cvals = constraint_vals\n                cinds = constraint_inds\n            else:\n                cvals = None\n                cinds = None\n\n        else:\n            signal_constr_vals_mod = signal_constr_vals\n\n            if constraint_vals is None or constraint_inds is None:\n                # Gene knockout is the only constraint:\n                cvals = [self._pnet.p_min]\n                cinds = [nde_i]\n\n            else: # add the gene knockout as a final constraint:\n                cvals = constraint_vals + [self._pnet.p_min]\n                cinds = constraint_inds + [nde_i]\n\n        # We also need to add in naturally-occurring constraints from unregulated nodes:\n\n        solsM, sol_M0_char, sols_1 = self._pnet.solve_probability_equms(constraint_inds=cinds,\n                                                                        constraint_vals=cvals,\n                                                                        signal_constr_vals=signal_constr_vals_mod,\n                                                                        d_base=d_base,\n                                                                        n_base=n_base,\n                                                                        beta_base=beta_base,\n                                                                        N_space=Ns,\n                                                                        search_tol=tol,\n                                                                        sol_tol=sol_tol,\n                                                                        verbose=verbose,\n                                                                        search_main_nodes_only=search_cycle_nodes_only\n                                                                        )\n\n        if verbose:\n            print(f'-------------------')\n\n        # print(f'size of solM {i} before clustering: {solsM.shape}')\n\n        # Cluster solutions to exclude those that are very similar\n        solsM = self.find_unique_sols(solsM)\n\n        # print(f'size of solM {i} after clustering: {solsM.shape}')\n\n        knockout_sol_set.append(solsM.copy())\n        knockout_header.extend([f'{self._pnet.nodes_list[nde_i]},' for j in range(solsM.shape[1])])\n\n    # merge this into a master matrix:\n    ko_M = None\n    for i, ko_aro in enumerate(knockout_sol_set):\n        if len(ko_aro) == 0:\n            ko_ar = np.asarray([np.zeros(self._pnet.N_nodes)]).T\n        else:\n            ko_ar = ko_aro\n\n        if i == 0:\n            ko_M = ko_ar\n        else:\n            ko_M = np.hstack((ko_M, ko_ar))\n\n    return knockout_sol_set, ko_M, knockout_header\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/#cellnition.science.networks_toolbox.gene_knockout.GeneKnockout.plot_knockout_arrays","title":"<code>plot_knockout_arrays(knockout_sol_set, figsave=None)</code>","text":"<p>Plot all steady-state solution arrays in a knockout experiment solution set.</p> Source code in <code>cellnition/science/networks_toolbox/gene_knockout.py</code> <pre><code>def plot_knockout_arrays(self, knockout_sol_set: list | ndarray, figsave: str=None):\n        '''\n        Plot all steady-state solution arrays in a knockout experiment solution set.\n\n        '''\n\n        # let's plot this as a multidimensional set of master arrays:\n        knock_flat = []\n        for kmat in knockout_sol_set:\n            for ki in kmat:\n                knock_flat.extend(ki)\n\n        vmax = np.max(knock_flat)\n        vmin = np.min(knock_flat)\n\n        cmap = 'magma'\n\n        N_axis = len(knockout_sol_set)\n\n        fig, axes = plt.subplots(1, N_axis, sharey=True, sharex=True)\n\n        for i, (axi, solsMio) in enumerate(zip(axes, knockout_sol_set)):\n            if len(solsMio):\n                solsMi = solsMio\n            else:\n                solsMi = np.asarray([np.zeros(self._pnet.N_nodes)]).T\n            axi.imshow(solsMi, aspect=\"equal\", vmax=vmax, vmin=vmin, cmap=cmap)\n            axi.axis('off')\n            if i != 0:\n                axi.set_title(f'c{i - 1}')\n            else:\n                axi.set_title(f'Full')\n\n        if figsave is not None:\n            plt.savefig(figsave, dpi=300, transparent=True, format='png')\n\n        return fig, axes\n</code></pre>"},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_netplot_plotnetwork/","title":"Network Plotting","text":""},{"location":"3%29%20Additional%20GRN%20Resources/networks_toolbox_netplot_plotnetwork/#cellnition.science.networks_toolbox.netplot.plot_network","title":"<code>plot_network(nodes_list, edge_list, nodes_type, edges_type, node_vals=None, node_shape='ellipse', val_cmap=None, dpi=300, save_path=None, layout='dot', vminmax=None, rev_font_color=False, label_edges=False, net_font_name='DejaVu Sans Bold', node_font_size=48, edge_width=8.0, nde_outline='Black', arrowsize=4.0)</code>","text":"<p>layout options: 'dot' \"fdp\" 'neato'</p> Source code in <code>cellnition/science/networks_toolbox/netplot.py</code> <pre><code>def plot_network(nodes_list: list|ndarray,\n                 edge_list: list|ndarray,\n                 nodes_type: list|ndarray,\n                 edges_type: list|ndarray,\n                 node_vals: list|ndarray|None = None,\n                 node_shape: str='ellipse',\n                 val_cmap: str|None = None,\n                 dpi: int|float=300,\n                 save_path: str|None=None,\n                 layout: str='dot',\n                 vminmax: tuple|None = None,\n                 rev_font_color: bool=False,\n                 label_edges: bool=False,\n                 net_font_name='DejaVu Sans Bold',\n                 node_font_size: int=48,\n                 edge_width: float=8.0,\n                 nde_outline: str='Black',\n                 arrowsize: float=4.0\n                ):\n    '''\n\n    layout options:\n    'dot'\n    \"fdp\"\n    'neato'\n    '''\n\n    G = pgv.AGraph(strict=False,\n                   splines=True,\n                   directed=True,\n                   concentrate=False,\n                   dpi=dpi)\n\n    if node_vals is not None:\n        if vminmax is None:\n            vmin = np.min(node_vals)\n            vmax = np.max(node_vals)\n        else:\n            vmin = vminmax[0]\n            vmax = vminmax[1]\n\n        if val_cmap is None:\n            cmap = colormaps['Greys'] # default colormap\n        else:\n            cmap = colormaps[val_cmap]\n\n        norm = colors.Normalize(vmin=vmin, vmax=vmax)\n\n    else:\n        cmap = None\n        norm = None\n\n    transp = 'c0'\n    hub_clr = '#151F30'\n    sig_clr = '#FF7A48' + transp\n    out_clr = '#0593A2' + transp\n    low_clr = '#1F2024'\n    nde_font_clr1 = 'White'\n    nde_font_clr2 = 'Black'\n    node_shape_gen = node_shape\n\n    node_dict_gene = {\n        'node_font_color': 'Black',\n        'node_color': 'GhostWhite',\n        'node_shape': node_shape_gen,\n        'outline_color': nde_outline\n    }\n\n    node_dict_signal = {\n        'node_font_color': 'White',\n        'node_color': sig_clr,\n        'node_shape': node_shape_gen,\n        'outline_color': sig_clr\n    }\n\n    node_dict_cycle = {\n        'node_font_color': 'White',\n        'node_color': hub_clr,\n        'node_shape': node_shape_gen,\n        'outline_color': hub_clr\n    }\n\n    node_dict_sensor = {\n        'node_font_color': 'White',\n        'node_color': sig_clr,\n        'node_shape': node_shape_gen,\n        'outline_color': sig_clr\n    }\n\n    node_dict_core = {\n        'node_font_color': 'White',\n        'node_color': hub_clr,\n        'node_shape': node_shape_gen,\n        'outline_color': hub_clr\n    }\n\n    node_dict_effector = {\n        'node_font_color': 'White',\n        'node_color': out_clr,\n        'node_shape': node_shape_gen,\n        'outline_color': out_clr\n    }\n\n    node_dict_process = {\n        'node_font_color': 'White',\n        'node_color': low_clr,\n        'node_shape': 'rect',\n        'outline_color': low_clr\n    }\n\n    node_dict_factor = {\n        'node_font_color': 'White',\n        'node_color': sig_clr,\n        'node_shape': 'diamond',\n        'outline_color': sig_clr\n    }\n\n    node_plot_dict = {NodeType.gene.value: node_dict_gene,\n                      NodeType.signal.value: node_dict_signal,\n                      NodeType.sensor.value: node_dict_sensor,\n                      NodeType.process.value: node_dict_process,\n                      NodeType.effector.value: node_dict_effector,\n                      NodeType.core.value: node_dict_core,\n                      NodeType.cycle.value: node_dict_cycle,\n                      NodeType.factor.value: node_dict_factor}\n\n    for ni, (nn, nt) in enumerate(zip(nodes_list, nodes_type)):\n\n        nde_dict = node_plot_dict[nt.value]\n\n        if node_vals is None:\n            nde_color = nde_dict['node_color']\n            nde_outline = nde_dict['outline_color']\n            nde_font_color = nde_dict['node_font_color']\n\n            # print(nt.name, nde_color)\n\n        else:\n            nde_color = colors.rgb2hex(cmap(norm(node_vals[ni])))\n            nde_outline = 'Black'\n\n            if rev_font_color is False:\n                if norm(node_vals[ni]) &lt; 0.5:\n                    nde_font_color = 'Black'\n                else:\n                    nde_font_color = 'White'\n\n            else:\n                if norm(node_vals[ni]) &gt;= 0.5:\n                    nde_font_color = 'Black'\n                else:\n                    nde_font_color = 'White'\n\n        G.add_node(nn,\n                   style='filled',\n                   fillcolor=nde_color,\n                   color=nde_outline,\n                   shape=nde_dict['node_shape'],\n                   fontcolor=nde_font_color,\n                   fontname=net_font_name,\n                   fontsize=node_font_size,\n                   )\n\n    for ei, ((ndei, ndej), et) in enumerate(zip(edge_list, edges_type)):\n\n        if label_edges:\n            edge_lab = f'e{ei}'\n\n        else:\n            edge_lab = ''\n\n        if et is EdgeType.A or et is EdgeType.As:\n            G.add_edge(ndei, ndej,\n                       label=edge_lab,\n                       arrowhead='dot',\n                       color='blue',\n                       arrowsize=arrowsize,\n                       penwidth=edge_width)\n\n        elif et is EdgeType.I or et is EdgeType.Is:\n            G.add_edge(ndei, ndej,\n                       label=edge_lab,\n                       arrowhead='tee',\n                       color='red',\n                       arrowsize=arrowsize,\n                       penwidth=edge_width)\n\n        elif et is EdgeType.N:\n            G.add_edge(ndei, ndej,\n                       label=edge_lab,\n                       arrowhead='normal',\n                       color='black',\n                       arrowsize=arrowsize,\n                       penwidth=edge_width)\n\n        else:\n            raise Exception('Edge type not found.')\n\n    G.layout(prog=layout) # default to neato\n\n    if save_path is not None:\n        G.draw(save_path)\n\n    return G\n</code></pre>"}]}