
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../usage/">
      
      
        <link rel="next" href="../network_models_interaction_functions/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Boolean Network Model - Cellnition</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#boolean-network-model" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Cellnition" class="md-header__button md-logo" aria-label="Cellnition" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Cellnition
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Boolean Network Model
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Cellnition" class="md-nav__button md-logo" aria-label="Cellnition" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Cellnition
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Welcome
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../about/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Background
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../features/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Features
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Usage
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    1) GRN Model Building
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            1) GRN Model Building
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Boolean Network Model
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Boolean Network Model
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet" class="md-nav__link">
    <span class="md-ellipsis">
      BooleanNet
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.bool_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      bool_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.build_adjacency_matrices" class="md-nav__link">
    <span class="md-ellipsis">
      build_adjacency_matrices
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.build_boolean_model" class="md-nav__link">
    <span class="md-ellipsis">
      build_boolean_model
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.generate_bool_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      generate_bool_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.generate_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      generate_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_multisequence_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_multisequence_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_sequence_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_sequence_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_state_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_state_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.run_iter_sim" class="md-nav__link">
    <span class="md-ellipsis">
      run_iter_sim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.save_model_equations" class="md-nav__link">
    <span class="md-ellipsis">
      save_model_equations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.solve_system_equms" class="md-nav__link">
    <span class="md-ellipsis">
      solve_system_equms
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_models_interaction_functions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Interaction Functions
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_models_network_abc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Network Base Class
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_models_network_enums/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Model Enumerations
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../network_models_probability_networks/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Continuous Network Model
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    2) Construction of NFSMs
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            2) Construction of NFSMs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Boolean Finite State Machine
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../2%29%20Construction%20of%20NFSMs/networks_toolbox_state_machine/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Continuous Finite State Machine
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    3) Additional GRN Resources
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            3) Additional GRN Resources
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3%29%20Additional%20GRN%20Resources/network_models_basic_network/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Basic Network
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3%29%20Additional%20GRN%20Resources/network_models_network_library/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Network Library
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3%29%20Additional%20GRN%20Resources/networks_toolbox_gene_knockout/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Gene Knockout Simulator
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../3%29%20Additional%20GRN%20Resources/networks_toolbox_netplot_plotnetwork/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Network Plotting
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet" class="md-nav__link">
    <span class="md-ellipsis">
      BooleanNet
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.bool_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      bool_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.build_adjacency_matrices" class="md-nav__link">
    <span class="md-ellipsis">
      build_adjacency_matrices
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.build_boolean_model" class="md-nav__link">
    <span class="md-ellipsis">
      build_boolean_model
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.generate_bool_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      generate_bool_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.generate_state_space" class="md-nav__link">
    <span class="md-ellipsis">
      generate_state_space
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_multisequence_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_multisequence_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_sequence_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_sequence_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.net_state_compute" class="md-nav__link">
    <span class="md-ellipsis">
      net_state_compute
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.run_iter_sim" class="md-nav__link">
    <span class="md-ellipsis">
      run_iter_sim
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.save_model_equations" class="md-nav__link">
    <span class="md-ellipsis">
      save_model_equations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cellnition.science.network_models.boolean_networks.BooleanNet.solve_system_equms" class="md-nav__link">
    <span class="md-ellipsis">
      solve_system_equms
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="boolean-network-model">Boolean Network Model</h1>


<div class="doc doc-object doc-class">



<a id="cellnition.science.network_models.boolean_networks.BooleanNet"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="cellnition.science.network_models.network_abc.NetworkABC" href="../network_models_network_abc/#cellnition.science.network_models.network_abc.NetworkABC">NetworkABC</a></code></p>


        <p>This class builds a Boolean model of a regulatory network from a directed graph. The
class can produce and characterize the directed graph upon which the Boolean model is based by importing
from the Cellnition <a class="autorefs autorefs-internal" href="../../3%29%20Additional%20GRN%20Resources/network_models_network_library/#cellnition.science.network_models.network_library"><code>network_library</code></a>,
from user-defined edges, or by using procedurally generated
graphs. One the directed graphs representing the regulatory network is formed, a Boolean, logic-equation based
analytic model of the regulatory network is automatically generated, along with numerical counterparts for
general simulation of the regulatory network. The simulation object produced by this class can be used to
build Network Finite State Machines (NFSMs) using the
<a class="autorefs autorefs-internal" href="../../2%29%20Construction%20of%20NFSMs/networks_toolbox_boolean_state_machine/#cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine"><code>BoolStateMachine</code></a> class.</p>







              <details class="quote">
                <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BooleanNet</span><span class="p">(</span><span class="n">NetworkABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This class builds a Boolean model of a regulatory network from a directed graph. The</span>
<span class="sd">    class can produce and characterize the directed graph upon which the Boolean model is based by importing</span>
<span class="sd">    from the Cellnition [`network_library`][cellnition.science.network_models.network_library],</span>
<span class="sd">    from user-defined edges, or by using procedurally generated</span>
<span class="sd">    graphs. One the directed graphs representing the regulatory network is formed, a Boolean, logic-equation based</span>
<span class="sd">    analytic model of the regulatory network is automatically generated, along with numerical counterparts for</span>
<span class="sd">    general simulation of the regulatory network. The simulation object produced by this class can be used to</span>
<span class="sd">    build Network Finite State Machines (NFSMs) using the</span>
<span class="sd">    [`BoolStateMachine`][cellnition.science.networks_toolbox.boolean_state_machine.BoolStateMachine] class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># Initialize the base class</span>

        <span class="c1"># Init all core attributes:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GG</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_edges</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_f</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_adjacency_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">edge_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">],</span>
                        <span class="n">edges_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">]],</span>
                        <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Initialize an activator matrix:</span>
        <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Initialize an inhibitor matrix:</span>
        <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
        <span class="c1"># and multiplicative interactions:cc</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edges_index</span><span class="p">,</span> <span class="n">edge_types</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                <span class="n">A_acti_s</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                <span class="n">A_inhi_s</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">)</span>
        <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span>


    <span class="c1">#----Boolean Model Building--------</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_boolean_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_node_name</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">multi_coupling_type</span><span class="p">:</span> <span class="n">CouplingType</span><span class="o">=</span><span class="n">CouplingType</span><span class="o">.</span><span class="n">mix1</span><span class="p">,</span>
                            <span class="n">constitutive_express</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s)</span>
<span class="sd">        as well as a vectorized numpy function (A_bool_f) that accepts the list or array of</span>
<span class="sd">        node concentrations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        use_node_name: bool = True</span>
<span class="sd">            If True, the node label is used as the symbolic parameter name. Otherwise a shorter</span>
<span class="sd">            parameter label of &#39;g_#&quot; is used, where # is the node&#39;s index in the network.</span>

<span class="sd">        multi_coupling_type: CouplingType=CouplingType.mixed</span>
<span class="sd">            Specify how factors are combined at individual target nodes.</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">use_node_name</span><span class="p">:</span>
            <span class="n">c_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="n">nde_nme</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">nde_nme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># use the node&#39;s numerical index as a label</span>
            <span class="n">c_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;g_</span><span class="si">{</span><span class="n">nde_i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                            <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">nde_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">mix1</span><span class="p">:</span>
            <span class="c1"># Case #1: Mixed coupling, where inhibitors always act in &quot;OR&quot;</span>
            <span class="c1"># configuration and activators act in &quot;AND&quot; configuration.</span>
            <span class="c1"># Initialize an activator matrix:</span>
            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># onesv = np.ones(self.N_nodes, dtype=int)</span>

            <span class="c1"># Initialize an inhibitor matrix:</span>
            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

            <span class="n">acti_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of activators acting on each node</span>
            <span class="n">inhi_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of inhibitors acting on each node</span>

            <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
            <span class="c1"># and multiplicative interactions:cc</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
                <span class="c1"># print(type(nde_i))</span>
                <span class="c1"># print(c_vect_s[nde_i])</span>
                <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                    <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">acti_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                    <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
                    <span class="n">inhi_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Combine so that presence of activators AND absence of inhibitors required for node expressions:</span>
            <span class="k">if</span> <span class="n">constitutive_express</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span>  <span class="c1"># total number of activators at each node</span>
                <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
                <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
                <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

                <span class="n">A_acti_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># multiply by the normalizing vector coopv</span>
                <span class="n">A_acti_ss</span> <span class="o">=</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">)</span>

                <span class="n">const_inds</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># if there&#39;s inhibitor but no activator, node must be const expressed</span>
                <span class="k">for</span> <span class="n">ndei</span><span class="p">,</span> <span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">ict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">acti_count</span><span class="p">,</span> <span class="n">inhi_count</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">act</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ict</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">const_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndei</span><span class="p">)</span>

                <span class="n">A_acti_ss</span><span class="p">[</span><span class="n">const_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># set this to 1 where the const expressed nodes should me</span>

                <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_ss</span><span class="p">)</span> <span class="c1"># collect terms into &quot;OR&quot; activators at each node</span>
                <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># collect terms into &quot;AND&quot; inhibitors at each node</span>
                <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span> <span class="c1"># Use &quot;AND&quot; to combine acti and inhi</span>

            <span class="c1"># We use and additive &quot;OR&quot; to specify the presence of an activator OR absence of an inhibitor</span>
            <span class="c1"># is required for gene expression for all genes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
                <span class="c1"># sums the number of activators and if inhibitors at each node:</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span>
                <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
                <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
                <span class="n">coopv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span> <span class="c1"># write as fractions for pretty display</span>

                <span class="c1"># Multiply the system through with the normalizing coefficients:</span>
                <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">)))</span>
                <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
                <span class="c1"># Combine activators and inhibitors as &quot;OR&quot; function:</span>
                <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>


        <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">mix2</span><span class="p">:</span>
            <span class="c1"># Mixed coupling #2, where inhibitors always act in &quot;AND&quot;</span>
            <span class="c1"># configuration and activators act in &quot;OR&quot; configuration.</span>
            <span class="c1"># Initialize an inhibitor matrix:</span>
            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">onesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="n">acti_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of activators acting on each node</span>
            <span class="n">inhi_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of inhibitors acting on each node</span>

            <span class="c1"># Initialize an activator matrix:</span>
            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

            <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
            <span class="c1"># and multiplicative interactions:cc</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
                <span class="c1"># print(type(nde_i))</span>
                <span class="c1"># print(c_vect_s[nde_i])</span>
                <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                    <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
                    <span class="n">acti_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                    <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">inhi_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Combine so that presence of activators AND absence of inhibitors required for node expressions:</span>
            <span class="k">if</span> <span class="n">constitutive_express</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span>  <span class="c1"># total number of activators at each node</span>
                <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
                <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
                <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

                <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># multiply by the normalizing vector coopv</span>
                <span class="n">A_inhi_ss</span> <span class="o">=</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">)</span>

                <span class="n">const_inds</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># if there&#39;s inhibitor but no activator, node must be const expressed</span>
                <span class="k">for</span> <span class="n">ndei</span><span class="p">,</span> <span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">ict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">acti_count</span><span class="p">,</span> <span class="n">inhi_count</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">act</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ict</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">const_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndei</span><span class="p">)</span>

                <span class="n">A_inhi_ss</span><span class="p">[</span><span class="n">const_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set this to 1 where the const expressed nodes should me</span>

                <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_ss</span><span class="p">)</span>  <span class="c1"># collect terms into &quot;OR&quot; activators at each node</span>
                <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># collect terms into &quot;AND&quot; inhibitors at each node</span>
                <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span>  <span class="c1"># Use &quot;AND&quot; to combine acti and inhi</span>

            <span class="c1"># We use and additive &quot;OR&quot; to specify the presence of an activator OR absence of an inhibitor</span>
            <span class="c1"># is required for gene expression for all genes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
                <span class="c1"># sums the number of activators and if inhibitors at each node:</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span>
                <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
                <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
                <span class="n">coopv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>  <span class="c1"># write as fractions for pretty display</span>

                <span class="c1"># Multiply the system through with the normalizing coefficients:</span>
                <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">)))</span>
                <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span>
                                               <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
                <span class="c1"># Combine activators and inhibitors as &quot;OR&quot; function:</span>
                <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>


        <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">additive</span><span class="p">:</span>

            <span class="c1"># Case #2: Additive coupling, where all interactions inhibitors always act in</span>
            <span class="c1"># &quot;AND&quot; configuration.</span>
            <span class="c1"># Initialize an activator matrix:</span>
            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># Initialize an inhibitor matrix:</span>
            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Initialize a &quot;ones vector&quot; for each node:</span>
            <span class="n">onesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
            <span class="c1"># and multiplicative interactions:cc</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
                <span class="c1"># print(type(nde_i))</span>
                <span class="c1"># print(c_vect_s[nde_i])</span>
                <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                    <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                    <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ic_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span>

            <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_acti_so</span> <span class="o">+</span> <span class="n">A_inhi_so</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span>
            <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
            <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
            <span class="c1"># coopv = 1 / denom</span>
            <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">))</span>
            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ic_vect_s</span><span class="p">))</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>

        <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">multiplicative</span><span class="p">:</span>
            <span class="c1"># Case #1: Mixed coupling, where inhibitors always act in &quot;OR&quot;</span>
            <span class="c1"># configuration and activators act in &quot;AND&quot; configuration.</span>
            <span class="c1"># Initialize an activator matrix:</span>
            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="c1"># Initialize an inhibitor matrix:</span>
            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

            <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
            <span class="c1"># and multiplicative interactions:cc</span>
            <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
                <span class="c1"># print(type(nde_i))</span>
                <span class="c1"># print(c_vect_s[nde_i])</span>
                <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                    <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                    <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>

            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only additive, multiplicative, and mixed coupling types are supported&quot;</span><span class="p">)</span>

        <span class="c1"># Finally, create a vectorized numpy function to calculate the result:</span>
        <span class="n">A_bool_f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">c_vect_s</span><span class="p">],</span> <span class="n">A_bool_s</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span> <span class="o">=</span> <span class="n">c_vect_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="o">=</span> <span class="n">A_bool_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_f</span> <span class="o">=</span> <span class="n">A_bool_f</span>

        <span class="k">return</span> <span class="n">c_vect_s</span><span class="p">,</span> <span class="n">A_bool_s</span><span class="p">,</span> <span class="n">A_bool_f</span>

    <span class="c1">#---Boolean Model Solving----------</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">net_state_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                              <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                              <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                              <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                              <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cc_o</span>  <span class="c1"># initialize the function values (node values)</span>
        <span class="n">solsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">cc_o</span><span class="p">]</span>  <span class="c1"># holds a list of transient solutions</span>
        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">undetermined</span> <span class="c1"># initialize to undetermined</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># A true &quot;OR&quot; function will return the maximum of the list of booleans. This can</span>
            <span class="c1"># be achieved by using the &quot;np.sign&quot; as a &quot;ceiling&quot; function:</span>

            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values for this next step i</span>

            <span class="c1"># If there are constraints on some node vals, force them to the constraint:</span>
            <span class="k">if</span> <span class="n">constraint_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constraint_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cc_i</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constraint_vals</span>

            <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span>

            <span class="c1"># Detect whether we&#39;re at a steady-state at any point in this analysis:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">solsv</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
                <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">attractor</span>
                <span class="k">break</span>

            <span class="c1"># Otherwise, when we reach the end of the sequence, search for repeated motifs:</span>
            <span class="k">elif</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">n_max_steps</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># test to see if we have a more complicated repetition motif:</span>
                <span class="n">solvr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]</span> <span class="c1"># get the reduced array</span>
                <span class="n">si</span> <span class="o">=</span> <span class="n">solvr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># try selecting the last state to check for repetition...</span>
                <span class="n">matched_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solvr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">si</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="c1"># look for repetition</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># if there&#39;s more than one incidence of the state</span>
                    <span class="n">motif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="c1"># extract a motif from the full array</span>
                    <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">motif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># solution becomes the (non-integer!) mean of the motif</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">motif</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">limit_cycle</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># otherwise the motif is a saddle (metabstable state):</span>
                        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">saddle</span>

        <span class="k">return</span> <span class="n">cc_i</span><span class="p">,</span> <span class="n">sol_char</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">net_sequence_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                              <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                              <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                              <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                              <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the sequence of n_max_step states occurring after an initial state, cc_o,</span>
<span class="sd">        determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic</span>
<span class="sd">        of the eq&#39;m as a point attractor or limit cycle.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cc_o</span>  <span class="c1"># initialize the function values (node values)</span>
        <span class="n">solsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cc_o</span><span class="p">)]</span>  <span class="c1"># holds a list of transient solutions, beginning with the initial state</span>
        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">undetermined</span> <span class="c1"># initialize to undetermined</span>

        <span class="n">motif</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># A true &quot;OR&quot; function will return the maximum of the list of booleans. This can</span>
            <span class="c1"># be achieved by using the &quot;ceiling&quot; function. If cooperative interaction is</span>
            <span class="c1"># desired, then rounding is better</span>

            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values of the sequence</span>

            <span class="c1"># If there are constraints on some node vals, force them to the constraint:</span>
            <span class="k">if</span> <span class="n">constraint_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constraint_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cc_i</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constraint_vals</span>

            <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span> <span class="c1"># append the new state to the sequence vector</span>

        <span class="c1"># Now that the sequence has been collected, determine if it&#39;s a steady-state, and if so,</span>
        <span class="c1"># characterize the eq&#39;m:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
            <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">attractor</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># test to see if we have a more complicated repetition motif:</span>
            <span class="n">solvr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]</span>  <span class="c1"># get the reduced array</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">solvr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># try selecting the last state to check for repetition in the sequence...</span>
            <span class="n">matched_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solvr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">si</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>  <span class="c1"># look for repetition</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if there&#39;s more than one incidence of the state</span>
                <span class="n">motif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>  <span class="c1"># extract a motif from the full seq</span>
                <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">motif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># solution becomes the (non-integer!) mean of the motif</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">motif</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">limit_cycle</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise the motif is a saddle (metabstable state):</span>
                    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">saddle</span>

        <span class="c1"># convert solsv to a numpy array with n_max_steps rows and self.N_Nodes columns:</span>
        <span class="n">solsv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">solsv</span><span class="p">,</span> <span class="n">cc_i</span><span class="p">,</span> <span class="n">sol_char</span><span class="p">,</span> <span class="n">motif</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">net_multisequence_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                                  <span class="n">sigs_vect</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                                  <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                                  <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                                  <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sol_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sol_char_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sequence_results</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">phase_inds</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># tuples marking the start and stop of each input intervention</span>

        <span class="n">tn_0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tn_1</span> <span class="o">=</span> <span class="n">n_max_steps</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sig_vals</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs_vect</span><span class="p">):</span>
            <span class="n">phase_inds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tn_0</span><span class="p">,</span> <span class="n">tn_1</span><span class="p">))</span>

            <span class="n">cc_o</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_vals</span>
            <span class="n">solsv</span><span class="p">,</span> <span class="n">cc_o</span><span class="p">,</span> <span class="n">sol_char</span><span class="p">,</span> <span class="n">motif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_sequence_compute</span><span class="p">(</span><span class="n">cc_o</span><span class="p">,</span>
                                                                     <span class="n">A_bool_f</span><span class="p">,</span>
                                                                     <span class="n">n_max_steps</span><span class="o">=</span><span class="n">n_max_steps</span><span class="p">,</span>
                                                                     <span class="n">constraint_inds</span><span class="o">=</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                     <span class="n">constraint_vals</span><span class="o">=</span><span class="n">sig_vals</span><span class="p">,</span>
                                                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                                                     <span class="p">)</span>

            <span class="n">pseudo_tvect_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tn_0</span><span class="p">,</span> <span class="n">tn_1</span><span class="p">)</span>
            <span class="c1"># update the tn vectors for next time:</span>
            <span class="n">tn_0</span> <span class="o">=</span> <span class="n">tn_1</span>
            <span class="n">tn_1</span> <span class="o">+=</span> <span class="n">n_max_steps</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sequence_results</span> <span class="o">=</span> <span class="n">solsv</span>
                <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="n">pseudo_tvect_i</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">sequence_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sequence_results</span><span class="p">,</span> <span class="n">solsv</span><span class="p">))</span>
                <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pseudo_tvect</span><span class="p">,</span> <span class="n">pseudo_tvect_i</span><span class="p">))</span>

            <span class="n">sol_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_o</span><span class="p">)</span> <span class="c1"># append the final eq&#39;m state value</span>
            <span class="n">sol_char_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_char</span><span class="p">)</span> <span class="c1"># append the eq&#39;m characterization</span>

        <span class="k">return</span> <span class="n">pseudo_tvect</span><span class="p">,</span> <span class="n">sequence_results</span><span class="p">,</span> <span class="n">sol_results</span><span class="p">,</span> <span class="n">sol_char_results</span><span class="p">,</span> <span class="n">phase_inds</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">run_iter_sim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">tvect</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span> <span class="c1"># main time vector</span>
                     <span class="n">cvecti</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span> <span class="c1"># initial state of all the network nodes</span>
                     <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                     <span class="n">sig_inds</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                     <span class="n">sig_vals</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
                         <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns the sequence of n_max_step states occurring after an initial state, cc_o,</span>
<span class="sd">        under a dynamically specified stimulation applied to constraint_inds with value</span>
<span class="sd">        constraint_vals.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cvecti</span>  <span class="c1"># initialize the function values (node values)</span>
        <span class="n">solsv</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># holds a list of transient solutions</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvect</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sig_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Rows of sig_vals array must equal the &#39;</span>
                            <span class="s1">&#39;number of time iterations in tvect!&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tvect</span><span class="p">:</span>

            <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span>  <span class="c1"># append the new state to the sequence vector</span>

            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values of the sequence</span>

            <span class="c1"># Force node values to the value of the dynamic constraint:</span>
            <span class="n">cc_i</span><span class="p">[</span><span class="n">sig_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_vals</span><span class="p">[</span><span class="n">tt</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">solsv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">solsv</span>




    <span class="k">def</span><span class="w"> </span><span class="nf">solve_system_equms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                           <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">signal_constr_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">search_main_nodes_only</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                           <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">node_num_max</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Solve for the equilibrium states of gene product in</span>
<span class="sd">        terms of a given set of boolean (0, 1) values.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># For any network, there may be nodes without regulation that require constraints</span>
        <span class="c1"># (these are in self._constrained_nodes). Therefore, add these to any user-supplied</span>
        <span class="c1"># constraints:</span>
        <span class="n">constrained_inds</span><span class="p">,</span> <span class="n">constrained_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_constrained_nodes</span><span class="p">(</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                            <span class="n">constraint_vals</span><span class="p">,</span>
                                                                            <span class="n">signal_constr_vals</span><span class="o">=</span><span class="n">signal_constr_vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sort_hier_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hier_node_level</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">)[</span><span class="n">sort_hier_inds</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">node_num_max</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">,</span> <span class="n">constrained_inds</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">search_main_nodes_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">:</span>
                <span class="c1"># If the number of nodes is less than 32, use the faster numpy-based method:</span>
                <span class="c1"># NOTE: 32 is a number that is hard-coded into Numpy</span>
                <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
                    <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No main nodes; cannot perform state search with &quot;</span>
                                <span class="s2">&quot;search_main_nodes_only=True.&quot;</span><span class="p">)</span>

        <span class="n">sol_Mo</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sol_char</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cvecto</span> <span class="ow">in</span> <span class="n">M_pstates</span><span class="p">:</span> <span class="c1"># for each test vector:</span>
            <span class="c1"># Need to modify the cvect vector to hold the value of the input nodes:</span>
            <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cvecto</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

            <span class="c1"># get values for the genes we&#39;re solving for:</span>
            <span class="n">sol_i</span><span class="p">,</span> <span class="n">char_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_state_compute</span><span class="p">(</span><span class="n">cvecto</span><span class="p">,</span>
                                                   <span class="n">A_bool_f</span><span class="p">,</span>
                                                   <span class="n">n_max_steps</span><span class="o">=</span><span class="n">n_max_steps</span><span class="p">,</span>
                                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">constraint_inds</span> <span class="o">=</span> <span class="n">constrained_inds</span><span class="p">,</span>
                                                   <span class="n">constraint_vals</span> <span class="o">=</span> <span class="n">constrained_vals</span>
                                                   <span class="p">)</span>

            <span class="n">sol_Mo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_i</span><span class="p">)</span>
            <span class="n">sol_char</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_i</span><span class="p">)</span>

            <span class="c1"># if i == 0:</span>
            <span class="c1">#     sol_Mo.append(sol_i)</span>
            <span class="c1">#     sol_char.append(char_i)</span>
            <span class="c1">#     i += 1</span>
            <span class="c1">#</span>
            <span class="c1"># else:</span>
            <span class="c1">#     if sol_i not in np.asarray(sol_Mo):</span>
            <span class="c1">#         sol_Mo.append(sol_i)</span>
            <span class="c1">#         sol_char.append(char_i)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">cvecto</span><span class="p">,</span> <span class="n">sol_i</span><span class="p">,</span> <span class="n">char_i</span><span class="p">)</span>


        <span class="n">_</span><span class="p">,</span> <span class="n">unique_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sol_Mo</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sol_M</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sol_Mo</span><span class="p">)[</span><span class="n">unique_inds</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sol_char</span><span class="p">)[</span><span class="n">unique_inds</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sol_M</span><span class="p">,</span> <span class="n">sol_char</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">c_inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate a discrete state space over the range of probabilities of</span>
<span class="sd">        each individual gene in the network.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">c_lins</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_inds</span><span class="p">:</span>
            <span class="n">c_lins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

        <span class="n">cGrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">c_lins</span><span class="p">)</span>

        <span class="n">N_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="n">cM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cGrid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c_inds</span><span class="p">,</span> <span class="n">cGrid</span><span class="p">):</span>
            <span class="n">cM</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cGrid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cM</span><span class="p">,</span> <span class="n">c_lins</span><span class="p">,</span> <span class="n">cGrid</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">c_inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                             <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Generate a discrete state space over the range of probabilities of</span>
<span class="sd">        each individual gene in the network.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># FIXME: this should not be expanded but code should be redeveloped to use only the iterator...</span>
        <span class="n">c_lins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">c_inds</span><span class="p">)))</span>
        <span class="n">cM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">c_lins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">cM</span><span class="p">[:,</span> <span class="n">c_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lins</span>

        <span class="k">return</span> <span class="n">cM</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_handle_constrained_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">constr_inds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">constr_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">signal_constr_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
                                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Networks will often have nodes without regulation that need to</span>
<span class="sd">        be constrained during optimization. This helper-method augments</span>
<span class="sd">        these naturally-occuring nodes with any additional constraints</span>
<span class="sd">        supplied by the user.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">len_constr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_node_inds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signal_constr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># default to zero</span>
            <span class="n">sig_vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">len_constr</span><span class="p">)))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig_vals</span> <span class="o">=</span> <span class="n">signal_constr_vals</span>

        <span class="k">if</span> <span class="n">len_constr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">constrained_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node_inds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">constrained_vals</span> <span class="o">=</span> <span class="n">sig_vals</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">constrained_inds</span> <span class="o">=</span> <span class="n">constr_inds</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_node_inds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">constrained_vals</span> <span class="o">=</span> <span class="n">constr_vals</span> <span class="o">+</span> <span class="n">sig_vals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">constr_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constr_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">constrained_inds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">constrained_vals</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">constrained_inds</span> <span class="o">=</span> <span class="n">constr_inds</span><span class="o">*</span><span class="mi">1</span>
                <span class="n">constrained_vals</span> <span class="o">=</span> <span class="n">constr_vals</span><span class="o">*</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">constrained_inds</span><span class="p">,</span> <span class="n">constrained_vals</span>


    <span class="c1">#---State Space Search -----------------</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                         <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">signal_constr_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">search_main_nodes_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                         <span class="n">node_num_max</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
                         <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">constrained_inds</span><span class="p">,</span> <span class="n">constrained_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_constrained_nodes</span><span class="p">(</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                            <span class="n">constraint_vals</span><span class="p">,</span>
                                                                            <span class="n">signal_constr_vals</span><span class="o">=</span><span class="n">signal_constr_vals</span><span class="p">)</span>

        <span class="n">sort_hier_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hier_node_level</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">)[</span><span class="n">sort_hier_inds</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">node_num_max</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">,</span> <span class="n">constrained_inds</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">search_main_nodes_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
                <span class="c1"># If the number of nodes is less than 32, use the faster numpy-based method:</span>
                <span class="c1"># NOTE: 32 is a number that is hard-coded into Numpy</span>
                <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if it&#39;s greater than 32, numpy can&#39;t work with this, therefore use python itertools method:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
                    <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No main nodes; cannot perform state search with &quot;</span>
                                <span class="s2">&quot;search_main_nodes_only=True.&quot;</span><span class="p">)</span>

        <span class="n">net_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># store the edges of the boolean state diagram</span>
        <span class="n">pos</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># Holds node state position on the state transition diagram</span>

        <span class="c1"># FIXME: this should be an enumeration not a matrix of 1 gillion states in M_pstates!!</span>
        <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cvecto</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M_pstates</span><span class="p">):</span> <span class="c1"># for each test vector:</span>
            <span class="c1"># Need to modify the cvect vector to hold the value of the input nodes:</span>
            <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cvecto</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cvecto</span>  <span class="c1"># initialize the function values (node values)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>
                <span class="n">cc_o</span> <span class="o">=</span> <span class="n">cc_i</span> <span class="c1"># save the initial value</span>
                <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values</span>

                <span class="c1"># Need to modify the new concentrations vector to hold the value of the input nodes:</span>
                <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cc_i</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

                <span class="n">nde1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_o</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]))</span>
                <span class="n">nde2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]))</span>

                <span class="c1"># nde1 = &#39;&#39;.join(str(int(i)) for i in cc_o[self.noninput_node_inds])</span>
                <span class="c1"># nde2 = &#39;&#39;.join(str(int(i)) for i in cc_i[self.noninput_node_inds])</span>

                <span class="n">net_edges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nde1</span><span class="p">,</span> <span class="n">nde2</span><span class="p">))</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">nde1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc_o</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">nde2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>

                <span class="c1"># Detect whether we&#39;re at a steady-state:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cc_i</span> <span class="o">==</span> <span class="n">cc_o</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="n">boolG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">net_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">boolG</span><span class="p">,</span> <span class="n">pos</span>


    <span class="c1"># ----Plots and Data Export---------------</span>

    <span class="c1"># FIXME: work this up</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_model_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">save_eqn_image</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="n">save_eqn_csv</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save images of the model equations, as well as a csv file that has</span>
<span class="sd">        model equations written in LaTeX format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        save_eqn_image : str</span>
<span class="sd">            The path and filename to save the main model equations as an image.</span>

<span class="sd">        save_reduced_eqn_image : str|None = None</span>
<span class="sd">            The path and filename to save the reduced main model equations as an image (if model is reduced).</span>

<span class="sd">        save_eqn_csv : str|None = None</span>
<span class="sd">            The path and filename to save the main and reduced model equations as LaTex in a csv file.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No model built; cannot save model equations.&quot;</span><span class="p">)</span>

        <span class="n">_c_vect_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span>

        <span class="n">c_name</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">_c_vect_s</span><span class="p">])</span>
        <span class="c1"># eqn_net = sp.Eq(c_name, self._A_bool_s)</span>

        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">cnme</span><span class="p">,</span> <span class="n">beqn</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">c_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span><span class="p">)):</span>
            <span class="n">eqn_net</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">cnme</span><span class="p">,</span> <span class="n">beqn</span><span class="p">)</span>

            <span class="n">save_eqn_image_i</span> <span class="o">=</span> <span class="n">save_eqn_image</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">cnme</span><span class="si">}</span><span class="s1">_.png&#39;</span>

            <span class="n">sp</span><span class="o">.</span><span class="n">preview</span><span class="p">(</span><span class="n">eqn_net</span><span class="p">,</span>
                       <span class="n">viewer</span><span class="o">=</span><span class="s1">&#39;file&#39;</span><span class="p">,</span>
                       <span class="n">filename</span><span class="o">=</span><span class="n">save_eqn_image_i</span><span class="p">,</span>
                       <span class="n">euler</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">dvioptions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-T&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;tight&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;-z&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;--truecolor&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;-D 600&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;-bg&quot;</span><span class="p">,</span>
                                   <span class="s2">&quot;Transparent&quot;</span><span class="p">])</span>

        <span class="c1"># Save the equations for the graph to a file:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Concentrations&#39;</span><span class="p">,</span> <span class="s1">&#39;Formula&#39;</span><span class="p">]</span>
        <span class="n">eqns_to_write</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">_c_vect_s</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span><span class="p">)]]</span>

        <span class="k">if</span> <span class="n">save_eqn_csv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_eqn_csv</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">csvwriter</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>  <span class="c1"># 2. create a csvwriter object</span>
                <span class="n">csvwriter</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>  <span class="c1"># 4. write the header</span>
                <span class="n">csvwriter</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">eqns_to_write</span><span class="p">)</span>  <span class="c1"># 5. write the rest of the data</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">()</span></code>

</h2>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  <span class="c1"># Initialize the base class</span>

    <span class="c1"># Init all core attributes:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">edges_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">GG</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_edges</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_f</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.bool_state_space" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">bool_state_space</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">,</span> <span class="n">constraint_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraint_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal_constr_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_main_nodes_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_max_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">node_num_max</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                     <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">signal_constr_vals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">search_main_nodes_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                     <span class="n">node_num_max</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">constrained_inds</span><span class="p">,</span> <span class="n">constrained_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_constrained_nodes</span><span class="p">(</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                        <span class="n">constraint_vals</span><span class="p">,</span>
                                                                        <span class="n">signal_constr_vals</span><span class="o">=</span><span class="n">signal_constr_vals</span><span class="p">)</span>

    <span class="n">sort_hier_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hier_node_level</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">)[</span><span class="n">sort_hier_inds</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">node_num_max</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">,</span> <span class="n">constrained_inds</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">search_main_nodes_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
            <span class="c1"># If the number of nodes is less than 32, use the faster numpy-based method:</span>
            <span class="c1"># NOTE: 32 is a number that is hard-coded into Numpy</span>
            <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if it&#39;s greater than 32, numpy can&#39;t work with this, therefore use python itertools method:</span>
            <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
                <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No main nodes; cannot perform state search with &quot;</span>
                            <span class="s2">&quot;search_main_nodes_only=True.&quot;</span><span class="p">)</span>

    <span class="n">net_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># store the edges of the boolean state diagram</span>
    <span class="n">pos</span><span class="o">=</span><span class="p">{}</span> <span class="c1"># Holds node state position on the state transition diagram</span>

    <span class="c1"># FIXME: this should be an enumeration not a matrix of 1 gillion states in M_pstates!!</span>
    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">cvecto</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">M_pstates</span><span class="p">):</span> <span class="c1"># for each test vector:</span>
        <span class="c1"># Need to modify the cvect vector to hold the value of the input nodes:</span>
        <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cvecto</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cvecto</span>  <span class="c1"># initialize the function values (node values)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>
            <span class="n">cc_o</span> <span class="o">=</span> <span class="n">cc_i</span> <span class="c1"># save the initial value</span>
            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values</span>

            <span class="c1"># Need to modify the new concentrations vector to hold the value of the input nodes:</span>
            <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cc_i</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

            <span class="n">nde1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_o</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]))</span>
            <span class="n">nde2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">cc_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]))</span>

            <span class="c1"># nde1 = &#39;&#39;.join(str(int(i)) for i in cc_o[self.noninput_node_inds])</span>
            <span class="c1"># nde2 = &#39;&#39;.join(str(int(i)) for i in cc_i[self.noninput_node_inds])</span>

            <span class="n">net_edges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nde1</span><span class="p">,</span> <span class="n">nde2</span><span class="p">))</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">nde1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc_o</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">nde2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cc_i</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>

            <span class="c1"># Detect whether we&#39;re at a steady-state:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cc_i</span> <span class="o">==</span> <span class="n">cc_o</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="n">boolG</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">net_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">boolG</span><span class="p">,</span> <span class="n">pos</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.build_adjacency_matrices" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build_adjacency_matrices</span><span class="p">(</span><span class="n">edge_types</span><span class="p">,</span> <span class="n">edges_index</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_adjacency_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">edge_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">EdgeType</span><span class="p">],</span>
                    <span class="n">edges_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">]],</span>
                    <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Initialize an activator matrix:</span>
    <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Initialize an inhibitor matrix:</span>
    <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
    <span class="c1"># and multiplicative interactions:cc</span>
    <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edges_index</span><span class="p">,</span> <span class="n">edge_types</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
            <span class="n">A_acti_s</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
            <span class="n">A_inhi_s</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">)</span>
    <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.build_boolean_model" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build_boolean_model</span><span class="p">(</span><span class="n">use_node_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">multi_coupling_type</span><span class="o">=</span><span class="n">CouplingType</span><span class="o">.</span><span class="n">mix1</span><span class="p">,</span> <span class="n">constitutive_express</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s)
as well as a vectorized numpy function (A_bool_f) that accepts the list or array of
node concentrations.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>use_node_name</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-external" href="https://docs.python.org/3/library/functions.html#bool">bool</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, the node label is used as the symbolic parameter name. Otherwise a shorter
parameter label of 'g_#" is used, where # is the node's index in the network.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>multi_coupling_type</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="CouplingType (cellnition.science.network_models.network_enums.CouplingType)" href="../network_models_network_enums/#cellnition.science.network_models.network_enums.CouplingType">CouplingType</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specify how factors are combined at individual target nodes.</p>
              </div>
            </td>
            <td>
                  <code><span title="cellnition.science.network_models.network_enums.CouplingType.mix1">mix1</span></code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_boolean_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_node_name</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">multi_coupling_type</span><span class="p">:</span> <span class="n">CouplingType</span><span class="o">=</span><span class="n">CouplingType</span><span class="o">.</span><span class="n">mix1</span><span class="p">,</span>
                        <span class="n">constitutive_express</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construct a Boolean solver for a network.Returns both the symbolic equations (A_bool_s)</span>
<span class="sd">    as well as a vectorized numpy function (A_bool_f) that accepts the list or array of</span>
<span class="sd">    node concentrations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    use_node_name: bool = True</span>
<span class="sd">        If True, the node label is used as the symbolic parameter name. Otherwise a shorter</span>
<span class="sd">        parameter label of &#39;g_#&quot; is used, where # is the node&#39;s index in the network.</span>

<span class="sd">    multi_coupling_type: CouplingType=CouplingType.mixed</span>
<span class="sd">        Specify how factors are combined at individual target nodes.</span>


<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">use_node_name</span><span class="p">:</span>
        <span class="n">c_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="n">nde_nme</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">nde_nme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_list</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># use the node&#39;s numerical index as a label</span>
        <span class="n">c_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;g_</span><span class="si">{</span><span class="n">nde_i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                                        <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">nde_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">mix1</span><span class="p">:</span>
        <span class="c1"># Case #1: Mixed coupling, where inhibitors always act in &quot;OR&quot;</span>
        <span class="c1"># configuration and activators act in &quot;AND&quot; configuration.</span>
        <span class="c1"># Initialize an activator matrix:</span>
        <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># onesv = np.ones(self.N_nodes, dtype=int)</span>

        <span class="c1"># Initialize an inhibitor matrix:</span>
        <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

        <span class="n">acti_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of activators acting on each node</span>
        <span class="n">inhi_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of inhibitors acting on each node</span>

        <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
        <span class="c1"># and multiplicative interactions:cc</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
            <span class="c1"># print(type(nde_i))</span>
            <span class="c1"># print(c_vect_s[nde_i])</span>
            <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">acti_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
                <span class="n">inhi_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Combine so that presence of activators AND absence of inhibitors required for node expressions:</span>
        <span class="k">if</span> <span class="n">constitutive_express</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span>  <span class="c1"># total number of activators at each node</span>
            <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
            <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
            <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

            <span class="n">A_acti_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># multiply by the normalizing vector coopv</span>
            <span class="n">A_acti_ss</span> <span class="o">=</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">)</span>

            <span class="n">const_inds</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># if there&#39;s inhibitor but no activator, node must be const expressed</span>
            <span class="k">for</span> <span class="n">ndei</span><span class="p">,</span> <span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">ict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">acti_count</span><span class="p">,</span> <span class="n">inhi_count</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">act</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ict</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">const_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndei</span><span class="p">)</span>

            <span class="n">A_acti_ss</span><span class="p">[</span><span class="n">const_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># set this to 1 where the const expressed nodes should me</span>

            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_ss</span><span class="p">)</span> <span class="c1"># collect terms into &quot;OR&quot; activators at each node</span>
            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># collect terms into &quot;AND&quot; inhibitors at each node</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span> <span class="c1"># Use &quot;AND&quot; to combine acti and inhi</span>

        <span class="c1"># We use and additive &quot;OR&quot; to specify the presence of an activator OR absence of an inhibitor</span>
        <span class="c1"># is required for gene expression for all genes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
            <span class="c1"># sums the number of activators and if inhibitors at each node:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span>
            <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
            <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
            <span class="n">coopv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span> <span class="c1"># write as fractions for pretty display</span>

            <span class="c1"># Multiply the system through with the normalizing coefficients:</span>
            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">)))</span>
            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
            <span class="c1"># Combine activators and inhibitors as &quot;OR&quot; function:</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>


    <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">mix2</span><span class="p">:</span>
        <span class="c1"># Mixed coupling #2, where inhibitors always act in &quot;AND&quot;</span>
        <span class="c1"># configuration and activators act in &quot;OR&quot; configuration.</span>
        <span class="c1"># Initialize an inhibitor matrix:</span>
        <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">onesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">acti_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of activators acting on each node</span>
        <span class="n">inhi_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">)]</span>  <span class="c1"># counts the number of inhibitors acting on each node</span>

        <span class="c1"># Initialize an activator matrix:</span>
        <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

        <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
        <span class="c1"># and multiplicative interactions:cc</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
            <span class="c1"># print(type(nde_i))</span>
            <span class="c1"># print(c_vect_s[nde_i])</span>
            <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
                <span class="n">acti_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">inhi_count</span><span class="p">[</span><span class="n">nde_j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Combine so that presence of activators AND absence of inhibitors required for node expressions:</span>
        <span class="k">if</span> <span class="n">constitutive_express</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span>  <span class="c1"># total number of activators at each node</span>
            <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
            <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
            <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

            <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># multiply by the normalizing vector coopv</span>
            <span class="n">A_inhi_ss</span> <span class="o">=</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">)</span>

            <span class="n">const_inds</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># if there&#39;s inhibitor but no activator, node must be const expressed</span>
            <span class="k">for</span> <span class="n">ndei</span><span class="p">,</span> <span class="p">(</span><span class="n">act</span><span class="p">,</span> <span class="n">ict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">acti_count</span><span class="p">,</span> <span class="n">inhi_count</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">act</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ict</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">const_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndei</span><span class="p">)</span>

            <span class="n">A_inhi_ss</span><span class="p">[</span><span class="n">const_inds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set this to 1 where the const expressed nodes should me</span>

            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_ss</span><span class="p">)</span>  <span class="c1"># collect terms into &quot;OR&quot; activators at each node</span>
            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># collect terms into &quot;AND&quot; inhibitors at each node</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span>  <span class="c1"># Use &quot;AND&quot; to combine acti and inhi</span>

        <span class="c1"># We use and additive &quot;OR&quot; to specify the presence of an activator OR absence of an inhibitor</span>
        <span class="c1"># is required for gene expression for all genes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Need to create a normalized vector for managing cooperativity of the &quot;OR&quot;</span>
            <span class="c1"># sums the number of activators and if inhibitors at each node:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inhi_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span>
            <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
            <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
            <span class="n">coopv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>  <span class="c1"># write as fractions for pretty display</span>

            <span class="c1"># Multiply the system through with the normalizing coefficients:</span>
            <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">)))</span>
            <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">coopv</span><span class="p">,</span>
                                           <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">acti_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
            <span class="c1"># Combine activators and inhibitors as &quot;OR&quot; function:</span>
            <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>


    <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">additive</span><span class="p">:</span>

        <span class="c1"># Case #2: Additive coupling, where all interactions inhibitors always act in</span>
        <span class="c1"># &quot;AND&quot; configuration.</span>
        <span class="c1"># Initialize an activator matrix:</span>
        <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Initialize an inhibitor matrix:</span>
        <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Initialize a &quot;ones vector&quot; for each node:</span>
        <span class="n">onesv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
        <span class="c1"># and multiplicative interactions:cc</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
            <span class="c1"># print(type(nde_i))</span>
            <span class="c1"># print(c_vect_s[nde_i])</span>
            <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">ic_vect_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span> <span class="o">-</span> <span class="n">c_vect_s</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_acti_so</span> <span class="o">+</span> <span class="n">A_inhi_so</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">onesv</span><span class="p">)</span>
        <span class="n">idenom</span> <span class="o">=</span> <span class="p">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># indices where denom is zero</span>
        <span class="n">denom</span><span class="p">[</span><span class="n">idenom</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># set those equal to 1</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
        <span class="c1"># coopv = 1 / denom</span>
        <span class="n">coopv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">denom</span><span class="p">])</span>

        <span class="n">A_acti_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_acti_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="p">(</span><span class="n">coopv</span> <span class="o">*</span> <span class="n">A_inhi_so</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_acti_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c_vect_s</span><span class="p">))</span>
        <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ic_vect_s</span><span class="p">))</span>
        <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">A_acti_s</span> <span class="o">+</span> <span class="n">A_inhi_s</span>

    <span class="k">elif</span> <span class="n">multi_coupling_type</span> <span class="ow">is</span> <span class="n">CouplingType</span><span class="o">.</span><span class="n">multiplicative</span><span class="p">:</span>
        <span class="c1"># Case #1: Mixed coupling, where inhibitors always act in &quot;OR&quot;</span>
        <span class="c1"># configuration and activators act in &quot;AND&quot; configuration.</span>
        <span class="c1"># Initialize an activator matrix:</span>
        <span class="n">A_acti_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
        <span class="c1"># Initialize an inhibitor matrix:</span>
        <span class="n">A_inhi_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>

        <span class="c1"># Build A_full_s, an adjacency matrix that doesn&#39;t distinguish between additive</span>
        <span class="c1"># and multiplicative interactions:cc</span>
        <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="p">((</span><span class="n">nde_i</span><span class="p">,</span> <span class="n">nde_j</span><span class="p">),</span> <span class="n">etype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_types</span><span class="p">)):</span>
            <span class="c1"># print(type(nde_i))</span>
            <span class="c1"># print(c_vect_s[nde_i])</span>
            <span class="k">if</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">A</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">As</span><span class="p">:</span>
                <span class="n">A_acti_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">I</span> <span class="ow">or</span> <span class="n">etype</span> <span class="ow">is</span> <span class="n">EdgeType</span><span class="o">.</span><span class="n">Is</span><span class="p">:</span>
                <span class="n">A_inhi_so</span><span class="p">[</span><span class="n">nde_j</span><span class="p">,</span> <span class="n">nde_i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c_vect_s</span><span class="p">[</span><span class="n">nde_i</span><span class="p">]</span>

        <span class="n">A_acti_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_acti_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">A_inhi_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">A_inhi_so</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">A_bool_s</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">hadamard_product</span><span class="p">(</span><span class="n">A_acti_s</span><span class="p">,</span> <span class="n">A_inhi_s</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only additive, multiplicative, and mixed coupling types are supported&quot;</span><span class="p">)</span>

    <span class="c1"># Finally, create a vectorized numpy function to calculate the result:</span>
    <span class="n">A_bool_f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">([</span><span class="n">c_vect_s</span><span class="p">],</span> <span class="n">A_bool_s</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span> <span class="o">=</span> <span class="n">c_vect_s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="o">=</span> <span class="n">A_bool_s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_f</span> <span class="o">=</span> <span class="n">A_bool_f</span>

    <span class="k">return</span> <span class="n">c_vect_s</span><span class="p">,</span> <span class="n">A_bool_s</span><span class="p">,</span> <span class="n">A_bool_f</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.generate_bool_state_space" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="n">c_inds</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Generate a discrete state space over the range of probabilities of
each individual gene in the network.</p>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">c_inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a discrete state space over the range of probabilities of</span>
<span class="sd">    each individual gene in the network.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># FIXME: this should not be expanded but code should be redeveloped to use only the iterator...</span>
    <span class="n">c_lins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">c_inds</span><span class="p">)))</span>
    <span class="n">cM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">c_lins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">cM</span><span class="p">[:,</span> <span class="n">c_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_lins</span>

    <span class="k">return</span> <span class="n">cM</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.generate_state_space" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">generate_state_space</span><span class="p">(</span><span class="n">c_inds</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Generate a discrete state space over the range of probabilities of
each individual gene in the network.</p>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">c_inds</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a discrete state space over the range of probabilities of</span>
<span class="sd">    each individual gene in the network.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">c_lins</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c_inds</span><span class="p">:</span>
        <span class="n">c_lins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>

    <span class="n">cGrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">c_lins</span><span class="p">)</span>

    <span class="n">N_pts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

    <span class="n">cM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_nodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cGrid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c_inds</span><span class="p">,</span> <span class="n">cGrid</span><span class="p">):</span>
        <span class="n">cM</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cGrid</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">cM</span><span class="p">,</span> <span class="n">c_lins</span><span class="p">,</span> <span class="n">cGrid</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.net_multisequence_compute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">net_multisequence_compute</span><span class="p">(</span><span class="n">cc_o</span><span class="p">,</span> <span class="n">sigs_vect</span><span class="p">,</span> <span class="n">A_bool_f</span><span class="p">,</span> <span class="n">n_max_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">constraint_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">net_multisequence_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                              <span class="n">sigs_vect</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                              <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                              <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                              <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">sol_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sol_char_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sequence_results</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">phase_inds</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># tuples marking the start and stop of each input intervention</span>

    <span class="n">tn_0</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tn_1</span> <span class="o">=</span> <span class="n">n_max_steps</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">sig_vals</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sigs_vect</span><span class="p">):</span>
        <span class="n">phase_inds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tn_0</span><span class="p">,</span> <span class="n">tn_1</span><span class="p">))</span>

        <span class="n">cc_o</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_vals</span>
        <span class="n">solsv</span><span class="p">,</span> <span class="n">cc_o</span><span class="p">,</span> <span class="n">sol_char</span><span class="p">,</span> <span class="n">motif</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_sequence_compute</span><span class="p">(</span><span class="n">cc_o</span><span class="p">,</span>
                                                                 <span class="n">A_bool_f</span><span class="p">,</span>
                                                                 <span class="n">n_max_steps</span><span class="o">=</span><span class="n">n_max_steps</span><span class="p">,</span>
                                                                 <span class="n">constraint_inds</span><span class="o">=</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                 <span class="n">constraint_vals</span><span class="o">=</span><span class="n">sig_vals</span><span class="p">,</span>
                                                                 <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
                                                                 <span class="p">)</span>

        <span class="n">pseudo_tvect_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tn_0</span><span class="p">,</span> <span class="n">tn_1</span><span class="p">)</span>
        <span class="c1"># update the tn vectors for next time:</span>
        <span class="n">tn_0</span> <span class="o">=</span> <span class="n">tn_1</span>
        <span class="n">tn_1</span> <span class="o">+=</span> <span class="n">n_max_steps</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sequence_results</span> <span class="o">=</span> <span class="n">solsv</span>
            <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="n">pseudo_tvect_i</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">sequence_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sequence_results</span><span class="p">,</span> <span class="n">solsv</span><span class="p">))</span>
            <span class="n">pseudo_tvect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pseudo_tvect</span><span class="p">,</span> <span class="n">pseudo_tvect_i</span><span class="p">))</span>

        <span class="n">sol_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_o</span><span class="p">)</span> <span class="c1"># append the final eq&#39;m state value</span>
        <span class="n">sol_char_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_char</span><span class="p">)</span> <span class="c1"># append the eq&#39;m characterization</span>

    <span class="k">return</span> <span class="n">pseudo_tvect</span><span class="p">,</span> <span class="n">sequence_results</span><span class="p">,</span> <span class="n">sol_results</span><span class="p">,</span> <span class="n">sol_char_results</span><span class="p">,</span> <span class="n">phase_inds</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.net_sequence_compute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">net_sequence_compute</span><span class="p">(</span><span class="n">cc_o</span><span class="p">,</span> <span class="n">A_bool_f</span><span class="p">,</span> <span class="n">n_max_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">constraint_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraint_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the sequence of n_max_step states occurring after an initial state, cc_o,
determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic
of the eq'm as a point attractor or limit cycle.</p>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">net_sequence_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                          <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                          <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                          <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the sequence of n_max_step states occurring after an initial state, cc_o,</span>
<span class="sd">    determines if the sequence reaches a dynamic equilibrium, and if so, the characteristic</span>
<span class="sd">    of the eq&#39;m as a point attractor or limit cycle.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cc_o</span>  <span class="c1"># initialize the function values (node values)</span>
    <span class="n">solsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cc_o</span><span class="p">)]</span>  <span class="c1"># holds a list of transient solutions, beginning with the initial state</span>
    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">undetermined</span> <span class="c1"># initialize to undetermined</span>

    <span class="n">motif</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># A true &quot;OR&quot; function will return the maximum of the list of booleans. This can</span>
        <span class="c1"># be achieved by using the &quot;ceiling&quot; function. If cooperative interaction is</span>
        <span class="c1"># desired, then rounding is better</span>

        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values of the sequence</span>

        <span class="c1"># If there are constraints on some node vals, force them to the constraint:</span>
        <span class="k">if</span> <span class="n">constraint_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constraint_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cc_i</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constraint_vals</span>

        <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span> <span class="c1"># append the new state to the sequence vector</span>

    <span class="c1"># Now that the sequence has been collected, determine if it&#39;s a steady-state, and if so,</span>
    <span class="c1"># characterize the eq&#39;m:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
        <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">attractor</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># test to see if we have a more complicated repetition motif:</span>
        <span class="n">solvr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]</span>  <span class="c1"># get the reduced array</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">solvr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># try selecting the last state to check for repetition in the sequence...</span>
        <span class="n">matched_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solvr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">si</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>  <span class="c1"># look for repetition</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if there&#39;s more than one incidence of the state</span>
            <span class="n">motif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>  <span class="c1"># extract a motif from the full seq</span>
            <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">motif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># solution becomes the (non-integer!) mean of the motif</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">motif</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">limit_cycle</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise the motif is a saddle (metabstable state):</span>
                <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">saddle</span>

    <span class="c1"># convert solsv to a numpy array with n_max_steps rows and self.N_Nodes columns:</span>
    <span class="n">solsv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">solsv</span><span class="p">,</span> <span class="n">cc_i</span><span class="p">,</span> <span class="n">sol_char</span><span class="p">,</span> <span class="n">motif</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.net_state_compute" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">net_state_compute</span><span class="p">(</span><span class="n">cc_o</span><span class="p">,</span> <span class="n">A_bool_f</span><span class="p">,</span> <span class="n">n_max_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">constraint_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraint_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">net_state_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                          <span class="n">cc_o</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                          <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                          <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                          <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
                          <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cc_o</span>  <span class="c1"># initialize the function values (node values)</span>
    <span class="n">solsv</span> <span class="o">=</span> <span class="p">[</span><span class="n">cc_o</span><span class="p">]</span>  <span class="c1"># holds a list of transient solutions</span>
    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">undetermined</span> <span class="c1"># initialize to undetermined</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_max_steps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># A true &quot;OR&quot; function will return the maximum of the list of booleans. This can</span>
        <span class="c1"># be achieved by using the &quot;np.sign&quot; as a &quot;ceiling&quot; function:</span>

        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values for this next step i</span>

        <span class="c1"># If there are constraints on some node vals, force them to the constraint:</span>
        <span class="k">if</span> <span class="n">constraint_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constraint_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cc_i</span><span class="p">[</span><span class="n">constraint_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constraint_vals</span>

        <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span>

        <span class="c1"># Detect whether we&#39;re at a steady-state at any point in this analysis:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">solsv</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">==</span> <span class="n">solsv</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">is</span> <span class="n">NumpyTrue</span><span class="p">:</span>
            <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">attractor</span>
            <span class="k">break</span>

        <span class="c1"># Otherwise, when we reach the end of the sequence, search for repeated motifs:</span>
        <span class="k">elif</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">n_max_steps</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># test to see if we have a more complicated repetition motif:</span>
            <span class="n">solvr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">]</span> <span class="c1"># get the reduced array</span>
            <span class="n">si</span> <span class="o">=</span> <span class="n">solvr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># try selecting the last state to check for repetition...</span>
            <span class="n">matched_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solvr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">si</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span> <span class="c1"># look for repetition</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># if there&#39;s more than one incidence of the state</span>
                <span class="n">motif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)[</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span><span class="n">matched_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="c1"># extract a motif from the full array</span>
                <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">motif</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># solution becomes the (non-integer!) mean of the motif</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">motif</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">limit_cycle</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># otherwise the motif is a saddle (metabstable state):</span>
                    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">EquilibriumType</span><span class="o">.</span><span class="n">saddle</span>

    <span class="k">return</span> <span class="n">cc_i</span><span class="p">,</span> <span class="n">sol_char</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.run_iter_sim" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">run_iter_sim</span><span class="p">(</span><span class="n">tvect</span><span class="p">,</span> <span class="n">cvecti</span><span class="p">,</span> <span class="n">A_bool_f</span><span class="p">,</span> <span class="n">sig_inds</span><span class="p">,</span> <span class="n">sig_vals</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Returns the sequence of n_max_step states occurring after an initial state, cc_o,
under a dynamically specified stimulation applied to constraint_inds with value
constraint_vals.</p>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_iter_sim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">tvect</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span> <span class="c1"># main time vector</span>
                 <span class="n">cvecti</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span> <span class="c1"># initial state of all the network nodes</span>
                 <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                 <span class="n">sig_inds</span><span class="p">:</span> <span class="n">ndarray</span><span class="o">|</span><span class="nb">list</span><span class="p">,</span>
                 <span class="n">sig_vals</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the sequence of n_max_step states occurring after an initial state, cc_o,</span>
<span class="sd">    under a dynamically specified stimulation applied to constraint_inds with value</span>
<span class="sd">    constraint_vals.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">cc_i</span> <span class="o">=</span> <span class="n">cvecti</span>  <span class="c1"># initialize the function values (node values)</span>
    <span class="n">solsv</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># holds a list of transient solutions</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tvect</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sig_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Rows of sig_vals array must equal the &#39;</span>
                        <span class="s1">&#39;number of time iterations in tvect!&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tvect</span><span class="p">:</span>

        <span class="n">solsv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)</span>  <span class="c1"># append the new state to the sequence vector</span>

        <span class="n">cc_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">(</span><span class="n">cc_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># calculate new state values of the sequence</span>

        <span class="c1"># Force node values to the value of the dynamic constraint:</span>
        <span class="n">cc_i</span><span class="p">[</span><span class="n">sig_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig_vals</span><span class="p">[</span><span class="n">tt</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">solsv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">solsv</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">solsv</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.save_model_equations" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">save_model_equations</span><span class="p">(</span><span class="n">save_eqn_image</span><span class="p">,</span> <span class="n">save_eqn_csv</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Save images of the model equations, as well as a csv file that has
model equations written in LaTeX format.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>save_eqn_image</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-external" href="https://docs.python.org/3/library/stdtypes.html#str">str</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The path and filename to save the main model equations as an image.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>save_reduced_eqn_image</code>
            </td>
            <td>
                  <code>str|None = None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The path and filename to save the reduced main model equations as an image (if model is reduced).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>save_eqn_csv</code>
            </td>
            <td>
                  <code>str|None = None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The path and filename to save the main and reduced model equations as LaTex in a csv file.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">save_model_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">save_eqn_image</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">save_eqn_csv</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Save images of the model equations, as well as a csv file that has</span>
<span class="sd">    model equations written in LaTeX format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    save_eqn_image : str</span>
<span class="sd">        The path and filename to save the main model equations as an image.</span>

<span class="sd">    save_reduced_eqn_image : str|None = None</span>
<span class="sd">        The path and filename to save the reduced main model equations as an image (if model is reduced).</span>

<span class="sd">    save_eqn_csv : str|None = None</span>
<span class="sd">        The path and filename to save the main and reduced model equations as LaTex in a csv file.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No model built; cannot save model equations.&quot;</span><span class="p">)</span>

    <span class="n">_c_vect_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_vect_s</span>

    <span class="n">c_name</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">ci</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">_c_vect_s</span><span class="p">])</span>
    <span class="c1"># eqn_net = sp.Eq(c_name, self._A_bool_s)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">cnme</span><span class="p">,</span> <span class="n">beqn</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">c_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span><span class="p">)):</span>
        <span class="n">eqn_net</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Eq</span><span class="p">(</span><span class="n">cnme</span><span class="p">,</span> <span class="n">beqn</span><span class="p">)</span>

        <span class="n">save_eqn_image_i</span> <span class="o">=</span> <span class="n">save_eqn_image</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">cnme</span><span class="si">}</span><span class="s1">_.png&#39;</span>

        <span class="n">sp</span><span class="o">.</span><span class="n">preview</span><span class="p">(</span><span class="n">eqn_net</span><span class="p">,</span>
                   <span class="n">viewer</span><span class="o">=</span><span class="s1">&#39;file&#39;</span><span class="p">,</span>
                   <span class="n">filename</span><span class="o">=</span><span class="n">save_eqn_image_i</span><span class="p">,</span>
                   <span class="n">euler</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">dvioptions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-T&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;tight&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;-z&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;--truecolor&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;-D 600&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;-bg&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;Transparent&quot;</span><span class="p">])</span>

    <span class="c1"># Save the equations for the graph to a file:</span>
    <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Concentrations&#39;</span><span class="p">,</span> <span class="s1">&#39;Formula&#39;</span><span class="p">]</span>
    <span class="n">eqns_to_write</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="n">_c_vect_s</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">latex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_A_bool_s</span><span class="p">)]]</span>

    <span class="k">if</span> <span class="n">save_eqn_csv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_eqn_csv</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">csvwriter</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>  <span class="c1"># 2. create a csvwriter object</span>
            <span class="n">csvwriter</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>  <span class="c1"># 4. write the header</span>
            <span class="n">csvwriter</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">eqns_to_write</span><span class="p">)</span>  <span class="c1"># 5. write the rest of the data</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="cellnition.science.network_models.boolean_networks.BooleanNet.solve_system_equms" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">solve_system_equms</span><span class="p">(</span><span class="n">A_bool_f</span><span class="p">,</span> <span class="n">constraint_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraint_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">signal_constr_vals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_main_nodes_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_max_steps</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">node_num_max</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

        <p>Solve for the equilibrium states of gene product in
terms of a given set of boolean (0, 1) values.</p>


            <details class="quote">
              <summary>Source code in <code>cellnition/science/network_models/boolean_networks.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">solve_system_equms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">A_bool_f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                       <span class="n">constraint_inds</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">constraint_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">signal_constr_vals</span><span class="p">:</span> <span class="nb">list</span><span class="o">|</span><span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">search_main_nodes_only</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">n_max_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">node_num_max</span><span class="p">:</span> <span class="nb">int</span><span class="o">|</span><span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Solve for the equilibrium states of gene product in</span>
<span class="sd">    terms of a given set of boolean (0, 1) values.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># For any network, there may be nodes without regulation that require constraints</span>
    <span class="c1"># (these are in self._constrained_nodes). Therefore, add these to any user-supplied</span>
    <span class="c1"># constraints:</span>
    <span class="n">constrained_inds</span><span class="p">,</span> <span class="n">constrained_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_constrained_nodes</span><span class="p">(</span><span class="n">constraint_inds</span><span class="p">,</span>
                                                                        <span class="n">constraint_vals</span><span class="p">,</span>
                                                                        <span class="n">signal_constr_vals</span><span class="o">=</span><span class="n">signal_constr_vals</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sort_hier_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hier_node_level</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noninput_node_inds</span><span class="p">)[</span><span class="n">sort_hier_inds</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">node_num_max</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unconstrained_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_index</span><span class="p">,</span> <span class="n">constrained_inds</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">search_main_nodes_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">:</span>
            <span class="c1"># If the number of nodes is less than 32, use the faster numpy-based method:</span>
            <span class="c1"># NOTE: 32 is a number that is hard-coded into Numpy</span>
            <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="n">unconstrained_inds</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node_num_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">node_num_max</span><span class="p">:</span>
                <span class="n">M_pstates</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_nodes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M_pstates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_bool_state_space</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">influence_node_inds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No main nodes; cannot perform state search with &quot;</span>
                            <span class="s2">&quot;search_main_nodes_only=True.&quot;</span><span class="p">)</span>

    <span class="n">sol_Mo</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sol_char</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">cvecto</span> <span class="ow">in</span> <span class="n">M_pstates</span><span class="p">:</span> <span class="c1"># for each test vector:</span>
        <span class="c1"># Need to modify the cvect vector to hold the value of the input nodes:</span>
        <span class="k">if</span> <span class="n">constrained_inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constrained_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cvecto</span><span class="p">[</span><span class="n">constrained_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">constrained_vals</span>

        <span class="c1"># get values for the genes we&#39;re solving for:</span>
        <span class="n">sol_i</span><span class="p">,</span> <span class="n">char_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_state_compute</span><span class="p">(</span><span class="n">cvecto</span><span class="p">,</span>
                                               <span class="n">A_bool_f</span><span class="p">,</span>
                                               <span class="n">n_max_steps</span><span class="o">=</span><span class="n">n_max_steps</span><span class="p">,</span>
                                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">constraint_inds</span> <span class="o">=</span> <span class="n">constrained_inds</span><span class="p">,</span>
                                               <span class="n">constraint_vals</span> <span class="o">=</span> <span class="n">constrained_vals</span>
                                               <span class="p">)</span>

        <span class="n">sol_Mo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol_i</span><span class="p">)</span>
        <span class="n">sol_char</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">char_i</span><span class="p">)</span>

        <span class="c1"># if i == 0:</span>
        <span class="c1">#     sol_Mo.append(sol_i)</span>
        <span class="c1">#     sol_char.append(char_i)</span>
        <span class="c1">#     i += 1</span>
        <span class="c1">#</span>
        <span class="c1"># else:</span>
        <span class="c1">#     if sol_i not in np.asarray(sol_Mo):</span>
        <span class="c1">#         sol_Mo.append(sol_i)</span>
        <span class="c1">#         sol_char.append(char_i)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">cvecto</span><span class="p">,</span> <span class="n">sol_i</span><span class="p">,</span> <span class="n">char_i</span><span class="p">)</span>


    <span class="n">_</span><span class="p">,</span> <span class="n">unique_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sol_Mo</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">sol_M</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sol_Mo</span><span class="p">)[</span><span class="n">unique_inds</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">sol_char</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sol_char</span><span class="p">)[</span><span class="n">unique_inds</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sol_M</span><span class="p">,</span> <span class="n">sol_char</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["search.highlight", "search.suggest"], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.c8b220af.min.js"></script>
      
    
  </body>
</html>